* Copyright 2010, 2012-2022 Richard Dymond (rjdymond@gmail.com)

* Attribute buffer (cavern + Willy + guardians + items + portal)
* 
* The routine at #R34574 initialises this buffer with the contents of the
* attribute buffer at #R24064 (empty cavern), writes the attributes for Willy,
* the guardians, the items and the portal into it, and then copies the result
* to the attribute file.
attr_buffer_2:                         ; 23552
       bss 512

* Attribute buffer (empty cavern)
* 
* Initialised upon entry to a cavern by the routine at #R34436, and updated by
* the routines at #R35770 and #R37173.
attr_buffer_1:                         ; 24064
       bss 512

* Screen buffer (cavern + Willy + guardians + items + portal)
* 
* The routine at #R34574 initialises this buffer with the contents of the
* screen buffer at #R28672 (empty cavern), draws Willy, the guardians, the
* items and the portal over this background, and then copies the result to the
* display file.
scrn_buffer_2:                         ; 24576
       bss 4096

* Screen buffer (empty cavern)
* 
* Initialised upon entry to a cavern by the routine at #R35445, and updated by
* the routines at #R35770, #R37125 and #R37173.
scrn_buffer_1:                         ; 28672
       bss 4096

* Manic Miner disassembly
* https://skoolkit.ca
* 
* Copyright 1983 Bug-Byte Ltd (Manic Miner)
* Copyright 2010, 2012-2022 Richard Dymond (this disassembly)

;       b    @begin                     ; JP 33792

* Cavern name
* 
* The cavern name is copied here and then used by the routine at #R34436.
cavernname:                            ; 32768
       bss 32

* Cavern tiles
* 
* The cavern tiles are copied here by the routine at #R34436 and then used to
* draw the cavern by the routine at #R35445.
* .
* The extra tile at #R32863 behaves like a floor tile, and is used as such in
* #R54272(The Endorian Forest), #R55296(Attack of the Mutant Telephones),
* #R57344(Ore Refinery), #R58368(Skylab Landing Bay) and #R59392(The Bank). It
* is also used in #R47104(The Menagerie) as spider silk, and in #R52224(Miner
* Willy meets the Kong Beast) and #R56320(Return of the Alien Kong Beast) as a
* switch.
background:                            ; 32800
       bss 9                                                         ; Background tile (also used by the routines at #R35515,
                                                                     ; #R35770, #R36211, #R36344, #R37173 and #R37471)
floor:                                 ; 32809
       bss 9                                                         ; Floor tile (also used by the routine at #R36211)
crumbling:                             ; 32818
       bss 9                                                         ; Crumbling floor tile (also used by the routine at
                                                                     ; #R35515)
wall:                                  ; 32827
       bss 9                                                         ; Wall tile (also used by the routines at #R35515, #R35805
                                                                     ; and #R36211)
conveyor:                              ; 32836
       bss 9                                                         ; Conveyor tile (also used by the routine at #R35805)
nasty1:                                ; 32845
       bss 9                                                         ; Nasty tile 1 (also used by the routines at #R35515 and
                                                                     ; #R37471)
nasty2:                                ; 32854
       bss 9                                                         ; Nasty tile 2 (also used by the routines at #R35515 and
                                                                     ; #R37471)
extra:                                 ; 32863
       bss 9                                                         ; Extra tile (also used by the routine at #R37403)

* Willy's y-coordinate
* 
* Initialised by the routine at #R34436, and used by the routines at #R35515,
* #R35805, #R37434 and #R37503. Holds the LSB of the address of the entry in
* the screen buffer address lookup table at #R33536 that corresponds to Willy's
* pixel y-coordinate; in practice, this LSB is twice Willy's actual pixel
* y-coordinate.
willy_y:                               ; 32872
       byte 0

* Willy's animation frame
* 
* Initialised upon entry to a cavern or after losing a life by the routine at
* #R34436, used by the routine at #R37503, and updated by the routine at
* #R35805. Possible values are 0, 1, 2 and 3.
frame:                                 ; 32873
       byte 0

* Willy's direction and movement flags
* 
* Initialised by the routine at #R34436.
* .
* #TABLE(default,centre,:w)
* { =h Bit(s) | =h Meaning | =h Used by }
* { 0 | Direction Willy is facing (reset=right, set=left) | #R35805, #R37503 }
* { 1 | Willy's movement flag (set=moving) | #R35515, #R35805 }
* { 2-7 | Unused (always reset) | }
* TABLE#
dmflags:                               ; 32874
       byte 0

* Airborne status indicator
* 
* Initialised by the routine at #R34436, and used by the routines at #R34574,
* #R35515, #R35805 and #R36101. Possible values are:
* .
* #TABLE(default,centre,:w)
* { =h Value | =h Meaning }
* { #b0      | Willy is neither falling nor jumping }
* { #b1      | Willy is jumping }
* { #b2-#b11 | Willy is falling, and can land safely }
* { #b12+    | Willy is falling, and has fallen too far to land safely (see
* #R35805#35805) }
* { #b255    | Willy has collided with a nasty or a guardian (see #R36101) }
* TABLE#
airborne:                              ; 32875
       byte 0

* Address of Willy's location in the attribute buffer at #N23552
* 
* Initialised by the routine at #R34436, used by the routines at #R35515,
* #R36805, #R37403, #R37434 and #R37503, and updated by the routine at #R35805.
location:                              ; 32876
       data 0

* Jumping animation counter
* 
* Initialised by the routine at #R34436, and used by the routines at #R35515
* and #R35805.
jumping:                               ; 32878
       byte 0

* Conveyor definition
* 
* The conveyor definition is copied here by the routine at #R34436.
convdir:                               ; 32879
       byte 0                                                        ; Direction (0=left, 1=right; used by the routines at
                                                                     ; #R35805 and #R37125)
convloc:                               ; 32880
       data 0                                                        ; Address of the conveyor's location in the screen buffer
                                                                     ; at #R28672 (used by the routine at #R37125)
convlen:                               ; 32882
       byte 0                                                        ; Length (used by the routine at #R37125)

* Border colour
* 
* Initialised and used by the routine at #R34436, and also used by the routines
* at #R34574, #R35515 and #R37173.
border:                                ; 32883
       byte 0

* Attribute of the last item drawn
* 
* Used by the routines at #R36344 and #R36707. Holds the attribute byte of the
* last item drawn, or #b0 if all the items have been collected.
itemattr:                              ; 32884
       byte 0

* Item definitions
* 
* The item definitions are copied here by the routine at #R34436, and then used
* by the routine at #R36707. An item definition contains the following
* information:
* .
* #TABLE(default,centre,:w)
* { =h Byte(s) | =h Contents }
* { 0 | Current attribute }
* { 1,2 | Address of the item's location in the attribute buffer at #R23552 }
* { 3 | MSB of the address of the item's location in the screen buffer at
* #R24576 }
* { 4 | Unused (always #b255) }
* TABLE#
items:                                 ; 32885
       bss 5                                                         ; Item 1
       bss 5                                                         ; Item 2
       bss 5                                                         ; Item 3
       bss 5                                                         ; Item 4
       bss 5                                                         ; Item 5
       byte 0                                                        ; Terminator (set to #b255)

* Portal definition
* 
* The portal definition is copied here by the routine at #R34436.
portal:                                ; 32911
       byte 0                                                        ; Attribute byte (used by the routines at #R36707 and
                                                                     ; #R36805)
portalg:                               ; 32912
       bss 32                                                        ; Graphic data (used by the routine at #R36805)
portalloc1:                            ; 32944
       data 0                                                        ; Address of the portal's location in the attribute buffer
                                                                     ; at #R23552 (used by the routine at #R36805)
portalloc2:                            ; 32946
       data 0                                                        ; Address of the portal's location in the screen buffer at
                                                                     ; #R24576 (used by the routine at #R36805)

* Item graphic
* 
* The item graphic is copied here by the routine at #R34436, and then used by
* the routine at #R36707.
item:                                  ; 32948
       bss 8

* Remaining air supply
* 
* Initialised (always to #b63 in practice) and used by the routine at #R34436,
* updated by the routine at #R35388, and also used by the routine at #R36904.
* Its value ranges from #b36 to #b63 and is actually the LSB of the display
* file address for the cell at the right end of the air bar. The amount of air
* to draw in this cell is determined by the value of the game clock at #R32957.
air:                                   ; 32956
       byte 0

* Game clock
* 
* Initialised by the routine at #R34436, updated on every pass through the main
* loop by the routine at #R35388, and used for timing purposes by the routines
* at #R36111, #R36344 and #R37173. Its value (which is always a multiple of 4)
* is also used by the routine at #R35388 to compute the amount of air to draw
* in the cell at the right end of the air bar.
clock:                                 ; 32957
       byte 0

* Horizontal guardians
* 
* The horizontal guardian definitions are copied here by the routine at
* #R34436, and then used by the routines at #R36111 and #R36266. There are four
* slots, each one seven bytes long, used to hold the state of the horizontal
* guardians in the current cavern.
* .
* For each horizontal guardian, the seven bytes are used as follows:
* .
* #TABLE(default,centre,:w)
* { =h Byte | =h Contents }
* { =r2 0 | Bit 7: animation speed (0=normal, 1=slow) }
* { Bits 0-6: attribute (BRIGHT, PAPER and INK) }
* { 1,2 | Address of the guardian's location in the attribute buffer at #R23552
* }
* { 3 | MSB of the address of the guardian's location in the screen buffer at
* #R24576 }
* { 4 | Animation frame }
* { 5 | LSB of the address of the leftmost point of the guardian's path in the
* attribute buffer }
* { 6 | LSB of the address of the rightmost point of the guardian's path in the
* attribute buffer }
* TABLE#
hguards:                               ; 32958
       bss 7                                                         ; Horizontal guardian 1
hguard2:                               ; 32965
       bss 7                                                         ; Horizontal guardian 2
       bss 7                                                         ; Horizontal guardian 3
       bss 7                                                         ; Horizontal guardian 4
       byte 0                                                        ; Terminator (set to #b255)

* Eugene's direction or the Kong Beast's status
* 
* Initialised by the routine at #R34436, and used by the routines at #R36344
* (to hold Eugene's direction: 0=down, 1=up) and #R37173 (to hold the Kong
* Beast's status: 0=on the ledge, 1=falling, 2=dead).
eugdir:                                ; 32987
       byte 0

* Eugene's or the Kong Beast's pixel y-coordinate
* 
* Initialised by the routine at #R34436, and used by the routines at #R34252
* (to hold the index into the message scrolled across the screen after the
* theme tune has finished playing), #R35140 (to hold the distance of the boot
* from the top of the screen as it descends onto Willy), #R36344 (to hold
* Eugene's pixel y-coordinate) and #R37173 (to hold the Kong Beast's pixel
* y-coordinate).
eughgt:                                ; 32988
       byte 0

* Vertical guardians
* 
* The vertical guardian definitions are copied here by the routine at #R34436,
* and then used by the routines at #R36469 and #R36593. There are four slots,
* each one seven bytes long, used to hold the state of the vertical guardians
* in the current cavern.
* .
* For each vertical guardian, the seven bytes are used as follows:
* .
* #TABLE(default,centre,:w)
* { =h Byte | =h Contents }
* { 0 | Attribute }
* { 1 | Animation frame }
* { 2 | Pixel y-coordinate }
* { 3 | x-coordinate }
* { 4 | Pixel y-coordinate increment }
* { 5 | Minimum pixel y-coordinate }
* { 6 | Maximum pixel y-coordinate }
* TABLE#
* .
* In most of the caverns that do not have vertical guardians, this area is
* overwritten by unused bytes from the cavern definition. The exception is
* #R49152(Eugene's Lair): the routine at #R34436 copies the graphic data for
* the Eugene sprite into the last 32 bytes of this area, where it is then used
* by the routine at #R36344.
vguards:                               ; 32989
       bss 7                                                         ; Vertical guardian 1
       bss 7                                                         ; Vertical guardian 2
       bss 7                                                         ; Vertical guardian 3
       bss 7                                                         ; Vertical guardian 4
       byte 0                                                        ; Terminator (set to #b255 in caverns that have four
                                                                     ; vertical guardians)
       bss 6                                                         ; Spare

* Guardian graphic data
* 
* The guardian graphic data is copied here by the routine at #R34436, and then
* used by the routines at #R36266, #R36469, #R36593 and #R37173.
ggdata:                                ; 33024
       bss 256

* Willy sprite graphic data
* 
* Used by the routines at #R34252, #R34574 and #R37503.
* .
* #UDGTABLE
* { #FOR(0,3)//n/#UDGARRAY2,7,2,2;(33280+32*n)-(33297+32*n)-1-16(willyn*)/ | //
* | #UDGARRAY*willy0;willy1;willy2;willy3(willy_r) }
* { #FOR(4,7)//n/#UDGARRAY2,7,2,2;(33280+32*n)-(33297+32*n)-1-16(willyn*)/ | //
* | #UDGARRAY*willy7;willy6;willy5;willy4(willy_l) }
* TABLE#
mandat:                                ; 33280
       byte 6,0,62,0,124,0,52,0,62,0,60,0,24,0,60,0
       byte 126,0,126,0,247,0,251,0,60,0,118,0,110,0,119,0
       byte 1,128,15,128,31,0,13,0,15,128,15,0,6,0,15,0
       byte 27,128,27,128,27,128,29,128,15,0,6,0,6,0,7,0
willyr2:                               ; 33344
       byte 0,96,3,224,7,192,3,64,3,224,3,192,1,128,3,192
       byte 7,224,7,224,15,112,15,176,3,192,7,96,6,224,7,112
willyr3:                               ; 33376
       byte 0,24,0,248,1,240,0,208,0,248,0,240,0,96,0,240
       byte 1,248,3,252,7,254,6,246,0,248,1,218,3,14,3,132
       byte 24,0,31,0,15,128,11,0,31,0,15,0,6,0,15,0
       byte 31,128,63,192,127,224,111,96,31,0,91,128,112,192,33,192
       byte 6,0,7,192,3,224,2,192,7,192,3,192,1,128,3,192
       byte 7,224,7,224,14,240,13,240,3,192,6,224,7,96,14,224
       byte 1,128,1,240,0,248,0,176,1,240,0,240,0,96,0,240
       byte 1,248,1,216,1,216,1,184,0,240,0,96,0,96,0,224
       byte 0,96,0,124,0,62,0,44,0,124,0,60,0,24,0,60
       byte 0,126,0,126,0,239,0,223,0,60,0,110,0,118,0,238

* Screen buffer address lookup table
* 
* Used by the routines at #R35140, #R36344, #R36469, #R36593, #R37173 and
* #R37503. The value of the Nth entry (0<=N<=127) in this lookup table is the
* screen buffer address for the point with pixel coordinates (x,y)=(0,N), with
* the origin (0,0) at the top-left corner.
sbufaddrs:                             ; 33536
       data scrn_buffer_2                                            ; y=0
       data scrn_buffer_2+256                                        ; y=1
       data scrn_buffer_2+512                                        ; y=2
       data scrn_buffer_2+768                                        ; y=3
       data scrn_buffer_2+1024                                       ; y=4
       data scrn_buffer_2+1280                                       ; y=5
       data scrn_buffer_2+1536                                       ; y=6
       data scrn_buffer_2+1792                                       ; y=7
       data scrn_buffer_2+32                                         ; y=8
       data scrn_buffer_2+288                                        ; y=9
       data scrn_buffer_2+544                                        ; y=10
       data scrn_buffer_2+800                                        ; y=11
       data scrn_buffer_2+1056                                       ; y=12
       data scrn_buffer_2+1312                                       ; y=13
       data scrn_buffer_2+1568                                       ; y=14
       data scrn_buffer_2+1824                                       ; y=15
       data scrn_buffer_2+64                                         ; y=16
       data scrn_buffer_2+320                                        ; y=17
       data scrn_buffer_2+576                                        ; y=18
       data scrn_buffer_2+832                                        ; y=19
       data scrn_buffer_2+1088                                       ; y=20
       data scrn_buffer_2+1344                                       ; y=21
       data scrn_buffer_2+1600                                       ; y=22
       data scrn_buffer_2+1856                                       ; y=23
       data scrn_buffer_2+96                                         ; y=24
       data scrn_buffer_2+352                                        ; y=25
       data scrn_buffer_2+608                                        ; y=26
       data scrn_buffer_2+864                                        ; y=27
       data scrn_buffer_2+1120                                       ; y=28
       data scrn_buffer_2+1376                                       ; y=29
       data scrn_buffer_2+1632                                       ; y=30
       data scrn_buffer_2+1888                                       ; y=31
       data scrn_buffer_2+128                                        ; y=32
       data scrn_buffer_2+384                                        ; y=33
       data scrn_buffer_2+640                                        ; y=34
       data scrn_buffer_2+896                                        ; y=35
       data scrn_buffer_2+1152                                       ; y=36
       data scrn_buffer_2+1408                                       ; y=37
       data scrn_buffer_2+1664                                       ; y=38
       data scrn_buffer_2+1920                                       ; y=39
       data scrn_buffer_2+160                                        ; y=40
       data scrn_buffer_2+416                                        ; y=41
       data scrn_buffer_2+672                                        ; y=42
       data scrn_buffer_2+928                                        ; y=43
       data scrn_buffer_2+1184                                       ; y=44
       data scrn_buffer_2+1440                                       ; y=45
       data scrn_buffer_2+1696                                       ; y=46
       data scrn_buffer_2+1952                                       ; y=47
       data scrn_buffer_2+192                                        ; y=48
       data scrn_buffer_2+448                                        ; y=49
       data scrn_buffer_2+704                                        ; y=50
       data scrn_buffer_2+960                                        ; y=51
       data scrn_buffer_2+1216                                       ; y=52
       data scrn_buffer_2+1472                                       ; y=53
       data scrn_buffer_2+1728                                       ; y=54
       data scrn_buffer_2+1984                                       ; y=55
       data scrn_buffer_2+224                                        ; y=56
       data scrn_buffer_2+480                                        ; y=57
       data scrn_buffer_2+736                                        ; y=58
       data scrn_buffer_2+992                                        ; y=59
       data scrn_buffer_2+1248                                       ; y=60
       data scrn_buffer_2+1504                                       ; y=61
       data scrn_buffer_2+1760                                       ; y=62
       data scrn_buffer_2+2016                                       ; y=63
       data scrn_buffer_2+2048                                       ; y=64
       data scrn_buffer_2+2304                                       ; y=65
       data scrn_buffer_2+2560                                       ; y=66
       data scrn_buffer_2+2816                                       ; y=67
       data scrn_buffer_2+3072                                       ; y=68
       data scrn_buffer_2+3328                                       ; y=69
       data scrn_buffer_2+3584                                       ; y=70
       data scrn_buffer_2+3840                                       ; y=71
       data scrn_buffer_2+2080                                       ; y=72
       data scrn_buffer_2+2336                                       ; y=73
       data scrn_buffer_2+2592                                       ; y=74
       data scrn_buffer_2+2848                                       ; y=75
       data scrn_buffer_2+3104                                       ; y=76
       data scrn_buffer_2+3360                                       ; y=77
       data scrn_buffer_2+3616                                       ; y=78
       data scrn_buffer_2+3872                                       ; y=79
       data scrn_buffer_2+2112                                       ; y=80
       data scrn_buffer_2+2368                                       ; y=81
       data scrn_buffer_2+2624                                       ; y=82
       data scrn_buffer_2+2880                                       ; y=83
       data scrn_buffer_2+3136                                       ; y=84
       data scrn_buffer_2+3392                                       ; y=85
       data scrn_buffer_2+3648                                       ; y=86
       data scrn_buffer_2+3904                                       ; y=87
       data scrn_buffer_2+2144                                       ; y=88
       data scrn_buffer_2+2400                                       ; y=89
       data scrn_buffer_2+2656                                       ; y=90
       data scrn_buffer_2+2912                                       ; y=91
       data scrn_buffer_2+3168                                       ; y=92
       data scrn_buffer_2+3424                                       ; y=93
       data scrn_buffer_2+3680                                       ; y=94
       data scrn_buffer_2+3936                                       ; y=95
       data scrn_buffer_2+2176                                       ; y=96
       data scrn_buffer_2+2432                                       ; y=97
       data scrn_buffer_2+2688                                       ; y=98
       data scrn_buffer_2+2944                                       ; y=99
       data scrn_buffer_2+3200                                       ; y=100
       data scrn_buffer_2+3456                                       ; y=101
       data scrn_buffer_2+3712                                       ; y=102
       data scrn_buffer_2+3968                                       ; y=103
       data scrn_buffer_2+2208                                       ; y=104
       data scrn_buffer_2+2464                                       ; y=105
       data scrn_buffer_2+2720                                       ; y=106
       data scrn_buffer_2+2976                                       ; y=107
       data scrn_buffer_2+3232                                       ; y=108
       data scrn_buffer_2+3488                                       ; y=109
       data scrn_buffer_2+3744                                       ; y=110
       data scrn_buffer_2+4000                                       ; y=111
       data scrn_buffer_2+2240                                       ; y=112
       data scrn_buffer_2+2496                                       ; y=113
       data scrn_buffer_2+2752                                       ; y=114
       data scrn_buffer_2+3008                                       ; y=115
       data scrn_buffer_2+3264                                       ; y=116
       data scrn_buffer_2+3520                                       ; y=117
       data scrn_buffer_2+3776                                       ; y=118
       data scrn_buffer_2+4032                                       ; y=119
       data scrn_buffer_2+2272                                       ; y=120
       data scrn_buffer_2+2528                                       ; y=121
       data scrn_buffer_2+2784                                       ; y=122
       data scrn_buffer_2+3040                                       ; y=123
       data scrn_buffer_2+3296                                       ; y=124
       data scrn_buffer_2+3552                                       ; y=125
       data scrn_buffer_2+3808                                       ; y=126
       data scrn_buffer_2+4064                                       ; y=127

sbufaddrs_msb_byte:
       equ  bytes+(sbufaddrs//8)     ; Unsigned division

* The game has just loaded
begin:                                 ; 33792
       limi 0                          ; DI                ; Disable interrupts
;      li   sp,_40190                  ; LD SP,40190       ; Place the stack somewhere safe (near the end of the
                                                           ; source code remnants at #R37708)
       b    @start                     ; JP 34252          ; Display the title screen and play the theme tune

* Current cavern number
* 
* Initialised by the routine at #R34252, used by the routines at #R34436,
* #R34574, #R35445 and #R36266, and updated by the routine at #R36904.
sheet:                                 ; 33799
       byte 0

* Left-right movement table
* 
* Used by the routine at #R35805. The entries in this table are used to map the
* existing value (V) of Willy's direction and movement flags at #R32874 to a
* new value (V'), depending on the direction Willy is facing and how he is
* moving or being moved (by 'left' and 'right' keypresses and joystick input,
* or by a conveyor).
* .
* One of the first four entries is used when Willy is not moving.
lrmovement:                            ; 33800
       byte 0                                                        ; V=0 (facing right, no movement) + no movement: V'=0 (no
                                                                     ; change)
       byte 1                                                        ; V=1 (facing left, no movement) + no movement: V'=1 (no
                                                                     ; change)
       byte 0                                                        ; V=2 (facing right, moving) + no movement: V'=0 (facing
                                                                     ; right, no movement) (i.e. stop)
       byte 1                                                        ; V=3 (facing left, moving) + no movement: V'=1 (facing
                                                                     ; left, no movement) (i.e. stop)
* One of the next four entries is used when Willy is moving left.
       byte 1                                                        ; V=0 (facing right, no movement) + move left: V'=1
                                                                     ; (facing left, no movement) (i.e. turn around)
       byte 3                                                        ; V=1 (facing left, no movement) + move left: V'=3 (facing
                                                                     ; left, moving)
       byte 1                                                        ; V=2 (facing right, moving) + move left: V'=1 (facing
                                                                     ; left, no movement) (i.e. turn around)
       byte 3                                                        ; V=3 (facing left, moving) + move left: V'=3 (no change)
* One of the next four entries is used when Willy is moving right.
       byte 2                                                        ; V=0 (facing right, no movement) + move right: V'=2
                                                                     ; (facing right, moving)
       byte 0                                                        ; V=1 (facing left, no movement) + move right: V'=0
                                                                     ; (facing right, no movement) (i.e. turn around)
       byte 2                                                        ; V=2 (facing right, moving) + move right: V'=2 (no
                                                                     ; change)
       byte 0                                                        ; V=3 (facing left, moving) + move right: V'=0 (facing
                                                                     ; right, no movement) (i.e. turn around)
* One of the final four entries is used when Willy is being pulled both left
* and right; each entry leaves the flags at #R32874 unchanged (so Willy carries
* on moving in the direction he's already moving, or remains stationary).
       byte 0                                                        ; V=V'=0 (facing right, no movement)
       byte 1                                                        ; V=V'=1 (facing left, no movement)
       byte 2                                                        ; V=V'=2 (facing right, moving)
       byte 3                                                        ; V=V'=3 (facing left, moving)

* 'AIR'
* 
* Used by the routine at #R34436.
messair:                               ; 33816
       text 'AIR'

* Unused
       text '0000'

* High score
* 
* Used by the routine at #R34574 and updated by the routine at #R35140.
hghscor:                               ; 33823
       text '000000'

* Score
* 
* Initialised by the routine at #R34436, and used by the routines at #R34574,
* #R35140, #R36904 and #R37098.
score:                                 ; 33829
       text '0000'                                                   ; Overflow digits (these may be updated, but are never
                                                                     ; printed)
scorbuf:                               ; 33833
       text '000000'

* 'High Score 000000#SPACE(3)Score 000000'
* 
* Used by the routine at #R34436.
messhssc:                              ; 33839
       text 'HIGH SCORE 000000   SCORE 000000'

* 'Game'
* 
* Used by the routine at #R35140.
messg:                                 ; 33871
       text 'GAME'

* 'Over'
* 
* Used by the routine at #R35140.
messo:                                 ; 33875
       text 'OVER'

* Lives remaining
* 
* Initialised to 2 by the routine at #R34252, and used and updated by the
* routines at #R34574 and #R37098.
nomen:                                 ; 33879
       byte 0

* Screen flash counter
* 
* Initialised by the routine at #R34252, and used by the routines at #R34574
* and #R37098.
flash:                                 ; 33880
       byte 0

* Kempston joystick indicator
* 
* Initialised by the routine at #R34252, and used by the routines at #R34574,
* #R35805 and #R37687. Holds 1 if a joystick is present, 0 otherwise.
kemp:                                  ; 33881
       byte 0

* Game mode indicator
* 
* Initialised by the routine at #R34252, and used by the routines at #R34436,
* #R34574 and #R36904. Holds #b0 when a game is in progress, or a value from
* #b1 to #b64 when in demo mode.
demo:                                  ; 33882
       byte 0

* In-game music note index
* 
* Initialised by the routine at #R34252, and used and updated by the routine at
* #R34574.
noteindex:                             ; 33883
       byte 0

* Music flags
* 
* The keypress flag in bit 0 is initialised by the routine at #R34252; bits 0
* and 1 are checked and updated by the routine at #R34574.
* .
* #TABLE(default,centre,:w)
* { =h Bit(s) | =h Meaning }
* { 0 | Keypress flag (set=H-ENTER being pressed, reset=no key pressed) }
* { 1 | In-game music flag (set=music off, reset=music on) }
* { 2-7 | Unused }
* TABLE#
musicflags:                            ; 33884
       byte 0

* 6031769 key counter
* 
* Used by the routines at #R34574 and #R36904.
cheat:                                 ; 33885
       byte 0

* 6031769
* 
* Used by the routine at #R34574. In each pair of bytes here, bits 0-4 of the
* first byte correspond to keys 1-2-3-4-5, and bits 0-4 of the second byte
* correspond to keys 0-9-8-7-6; among those bits, a zero indicates a key being
* pressed.
       byte :00011111,:00011111                                      ; (no keys pressed)
cheatdt:                               ; 33888
       byte :00011111,:00001111                                      ; 6
       byte :00011111,:00011110                                      ; 0
       byte :00011011,:00011111                                      ; 3
       byte :00011110,:00011111                                      ; 1
       byte :00011111,:00010111                                      ; 7
       byte :00011111,:00001111                                      ; 6
       byte :00011111,:00011101                                      ; 9

* Title screen tune data (The Blue Danube)
* 
* Used by the routine at #R37596. The tune data is organised into 95 groups of
* three bytes each, one group for each note in the tune. The first byte in each
* group determines the duration of the note, and the second and third bytes
* determine the frequency (and also the piano keys that light up).
themetune:                             ; 33902
       byte 80,128,129
       byte 80,102,103
       byte 80,86,87
       byte 50,86,87
       byte 50,171,203
       byte 50,43,51
       byte 50,43,51
       byte 50,171,203
       byte 50,51,64
       byte 50,51,64
       byte 50,171,203
       byte 50,128,129
       byte 50,128,129
       byte 50,102,103
       byte 50,86,87
       byte 50,96,86
       byte 50,171,192
       byte 50,43,48
       byte 50,43,48
       byte 50,171,192
       byte 50,48,68
       byte 50,48,68
       byte 50,171,192
       byte 50,136,137
       byte 50,136,137
       byte 50,114,115
       byte 50,76,77
       byte 50,76,77
       byte 50,171,192
       byte 50,38,48
       byte 50,38,48
       byte 50,171,192
       byte 50,48,68
       byte 50,48,68
       byte 50,171,192
       byte 50,136,137
       byte 50,136,137
       byte 50,114,115
       byte 50,76,77
       byte 50,76,77
       byte 50,171,203
       byte 50,38,51
       byte 50,38,51
       byte 50,171,203
       byte 50,51,64
       byte 50,51,64
       byte 50,171,203
       byte 50,128,129
       byte 50,128,129
       byte 50,102,103
       byte 50,86,87
       byte 50,64,65
       byte 50,128,171
       byte 50,32,43
       byte 50,32,43
       byte 50,128,171
       byte 50,43,51
       byte 50,43,51
       byte 50,128,171
       byte 50,128,129
       byte 50,128,129
       byte 50,102,103
       byte 50,86,87
       byte 50,64,65
       byte 50,128,152
       byte 50,32,38
       byte 50,32,38
       byte 50,128,152
       byte 50,38,48
       byte 50,38,48
       byte 50,0,0
       byte 50,114,115
       byte 50,114,115
       byte 50,96,97
       byte 50,76,77
       byte 50,76,153
       byte 50,76,77
       byte 50,76,77
       byte 50,76,153
       byte 50,91,92
       byte 50,86,87
       byte 50,51,205
       byte 50,51,52
       byte 50,51,52
       byte 50,51,205
       byte 50,64,65
       byte 50,102,103
       byte 100,102,103
       byte 50,114,115
       byte 100,76,77
       byte 50,86,87
       byte 50,128,203
       byte 25,128,0
       byte 25,128,129
       byte 50,128,203
       byte 255                                                      ; End marker

* In-game tune data (In the Hall of the Mountain King)
* 
* Used by the routine at #R34574.
gametune:                              ; 34188
       byte 128,114,102,96,86,102,86,86,81,96,81,81,86,102,86,86
       byte 128,114,102,96,86,102,86,86,81,96,81,81,86,86,86,86
       byte 128,114,102,96,86,102,86,86,81,96,81,81,86,102,86,86
       byte 128,114,102,96,86,102,86,64,86,102,128,102,86,86,86,86

* Display the title screen and play the theme tune
* 
* Used by the routines at #R33792, #R34574 and #R35140.
* .
* The first thing this routine does is initialise some game status buffer
* variables in preparation for the next game.
start:                                 ; 34252
       sb   a,a                        ; XOR A             ; #REGa=0
       movb a,@sheet                   ; LD (33799),A      ; Initialise the current cavern number at #R33799
       movb a,@kemp                    ; LD (33881),A      ; Initialise the Kempston joystick indicator at #R33881
       movb a,@demo                    ; LD (33882),A      ; Initialise the game mode indicator at #R33882
       movb a,@noteindex               ; LD (33883),A      ; Initialise the in-game music note index at #R33883
       movb a,@flash                   ; LD (33880),A      ; Initialise the screen flash counter at #R33880
       movb @bytes+2,a                 ; LD A,2            ; {Initialise the number of lives remaining at #R33879
       movb a,@nomen                   ; LD (33879),A      ; }
       li   hl,musicflags              ; LD HL,33884       ; {Initialise the keypress flag in bit 0 at #R33884
       socb @bits+0,*hl                ; SET 0,(HL)        ; }
* Next, prepare the screen.
       li   hl,zx_screen               ; LD HL,16384       ; {Clear the entire display file
       li   de,zx_screen+1             ; LD DE,16385       ; 
       li   bc,6143                    ; LD BC,6143        ; 
       sb   *hl,*hl                    ; LD (HL),0         ; 
       .ldir                           ; LDIR              ; }
       seto @title_screen_bank_select
       li   hl,titlescr1               ; LD HL,40960       ; {Copy the graphic data at #R40960 to the top two-thirds
       li   de,zx_screen               ; LD DE,16384       ; of the display file
       li   bc,4096                    ; LD BC,4096        ; 
       .ldir                           ; LDIR              ; }
       li   hl,zx_screen+2109          ; LD HL,18493       ; {Draw Willy at (9,29)
       li   de,willyr2                 ; LD DE,33344       ;
       sb   @c,@c                      ; LD C,0            ;
       .call @drwfix                   ; CALL 36852        ; }
       seto @caverns_13_19_bank_select
       li   hl,cavern19                ; LD HL,64512       ; {Copy the attribute bytes from #R64512 to the top third
       li   de,zx_attrs                ; LD DE,22528       ; of the attribute file
       li   bc,256                     ; LD BC,256         ;
       .ldir                           ; LDIR              ; }
       seto @title_screen_bank_select
       li   hl,lowerattrs              ; LD HL,40448       ; {Copy the attribute bytes from #R40448 to the bottom
       li   bc,512                     ; LD BC,512         ; two-thirds of the attribute file
       .ldir                           ; LDIR              ; }
       bl   @upload_zx_screen
       bl   @ti_wait_fire
       jmp  start_demo

* Now check whether there is a joystick connected.
       li   bc,31                      ; LD BC,31          ; This is the joystick port
       limi 0                          ; DI                ; Disable interrupts (which are already disabled)
       sb   a,a                        ; XOR A             ; #REGa=0
_34337:
       ; IN E,(C)                      ; IN E,(C)          ; {Combine 256 readings of the joystick port in #REGa; if
       socb @e,a                       ; OR E              ; no joystick is connected, some of these readings will
       sb   one,b                      ; DJNZ 34337        ; have bit 5 set}
       jne  _34337                     ;                   
       andi a,32*256                   ; AND 32            ; Is a joystick connected (bit 5 reset)?
       jne  _34351                     ; JR NZ,34351       ; Jump if not
       movb one,a                      ; LD A,1            ; {Set the Kempston joystick indicator at #R33881 to 1
       movb a,@kemp                    ; LD (33881),A      ; }
* And finally, play the theme tune and check for keypresses.
* .
* #AUDIO4(tune.wav)(34351,34358)
_34351:
       li   iy,themetune               ; LD IY,33902       ; Point #REGiy at the theme tune data at #R33902
       .call @playtune                 ; CALL 37596        ; Play the theme tune
       jeq  !                          ; JP NZ,34436       ; Start the game if ENTER or the fire button was pressed
       b    @startgame                 ;                   
!
       sb   a,a                        ; XOR A             ; {Initialise the game status buffer variable at #R32988;
       movb a,@eughgt                  ; LD (32988),A      ; this will be used as an index for the message scrolled
                                                           ; across the screen}
_34365:
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the message index from #R32988
       li   ix,messintro               ; LD IX,40192       ; {Point #REGix at the corresponding location in the
       movb a,@ixl                     ; LD IXL,A          ; message at #R40192}
       li   de,zx_screen+4192          ; LD DE,20576       ; {Print 32 characters of the message at (19,0)
       movb @bytes+32,@c               ; LD C,32           ; 
       .call @pmess                    ; CALL 37562        ; }
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the message index from #R32988
       andi a,6*256                    ; AND 6             ; {Keep only bits 1 and 2, and move them into bits 6 and
       srl  a,1                        ; RRCA              ; TODO: check code. 7, so that #REGa holds #b0, #b64, #b128 or #b192; this
       srl  a,1                        ; RRCA              ; TODO: check code. value determines the animation frame to use for Willy
       srl  a,1                        ; RRCA              ; TODO: check code. }
       movb a,@e                       ; LD E,A            ; {Point #REGde at the graphic data for Willy's sprite
       movb @bytes+(mandat//256),d     ; LD D,130          ; (#R33280+#REGa)}
       li   hl,zx_screen+2109          ; LD HL,18493       ; {Draw Willy at (9,29)
       sb   @c,@c                      ; LD C,0            ; 
       .call @drwfix                   ; CALL 36852        ; }
       li   bc,100                     ; LD BC,100         ; {Pause for about 0.1s
_34404:
       sb   one,b                      ; DJNZ 34404        ; 
       jne  _34404                     ;                   
       sb   one,@c                     ; DEC C             ; 
       jne  _34404                     ; JR NZ,34404       ; }
       li   bc,49150                   ; LD BC,49150       ; {Read keys H-J-K-L-ENTER
       ; IN A,(C)                      ; IN A,(C)          ; }
       andi a,1*256                    ; AND 1             ; Keep only bit 0 of the result (ENTER)
       cb   a,one                      ; CP 1              ; Is ENTER being pressed?
       jne  startgame                  ; JR NZ,34436       ; If so, start the game
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the message index from #R32988
       ab   one,a                      ; INC A             ; Increment it
       cb   a,@bytes+224               ; CP 224            ; Set the zero flag if we've reached the end of the
                                                           ; message
       movb a,@eughgt                  ; LD (32988),A      ; Store the new message index at #R32988
       jne  _34365                     ; JR NZ,34365       ; Jump back unless we've finished scrolling the message
                                                           ; across the screen
start_demo:
       movb @bytes+64,a                ; LD A,64           ; {Initialise the game mode indicator at #R33882 to #b64:
       movb a,@demo                    ; LD (33882),A      ; demo mode}
* This routine continues into the one at #R34436.

* Start the game (or demo mode)
* 
* Used by the routine at #R34252.
startgame:                             ; 34436
       li   hl,score                   ; LD HL,33829       ; {Initialise the score at #R33829
       li   de,score+1                 ; LD DE,33830       ; 
       li   bc,9                       ; LD BC,9           ; 
       movb @bytes+48,*hl              ; LD (HL),48        ; 
       .ldir                           ; LDIR              ; }
* This entry point is used by the routines at #R34574 (when teleporting into a
* cavern or reinitialising the current cavern after Willy has lost a life) and
* #R36904.
newsht:                                ; 34449
       movb @sheet,a                   ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   a,@bytes+7
       jhe  !
       seto @caverns_0_6_bank_select
       jmp  !!!
!      cb   a,@bytes+13
       jhe  !
       seto @caverns_7_12_bank_select
       jmp  !!
!      seto @caverns_13_19_bank_select
!
       sla  a,1                        ; SLA A             ; {Point #REGhl at the first byte of the cavern definition
       sla  a,1                        ; SLA A             ;
;       ab   @bytes+176,a               ; ADD A,176         ;
       movb a,h                        ; LD H,A            ;
       sb   @l,@l                      ; LD L,0            ; }
       ai   hl,cavern0
       li   de,attr_buffer_1           ; LD DE,24064       ; {Copy the cavern's attribute bytes into the buffer at
       li   bc,512                     ; LD BC,512         ; #R24064
       .ldir                           ; LDIR              ; }
       li   de,cavernname              ; LD DE,32768       ; {Copy the rest of the cavern definition into the game
       li   bc,512                     ; LD BC,512         ; status buffer at #GBUF32768
       .ldir                           ; LDIR              ; }
       .call @drawsheet                ; CALL 35445        ; Draw the current cavern to the screen buffer at #R28672
       li   hl,zx_screen+4096          ; LD HL,20480       ; {Clear the bottom third of the display file
       li   de,zx_screen+4097          ; LD DE,20481       ; 
       li   bc,2047                    ; LD BC,2047        ; 
       sb   *hl,*hl                    ; LD (HL),0         ; 
       .ldir                           ; LDIR              ; }
       li   ix,cavernname              ; LD IX,32768       ; {Print the cavern name (see #R32768) at (16,0)
       movb @bytes+32,@c               ; LD C,32           ; 
       li   de,zx_screen+4096          ; LD DE,20480       ; 
       .call @pmess                    ; CALL 37562        ; }
       li   ix,messair                 ; LD IX,33816       ; {Print 'AIR' (see #R33816) at (17,0)
       movb @bytes+3,@c                ; LD C,3            ; 
       li   de,zx_screen+4128          ; LD DE,20512       ; 
       .call @pmess                    ; CALL 37562        ; }
       movb @bytes+zx_screen_msb+18,a  ; LD A,82           ; Initialise #REGa to #b82; this is the MSB of the display
                                                           ; file address at which to start drawing the bar that
                                                           ; represents the air supply
_34519:
       movb a,h                        ; LD H,A            ; {Prepare #REGhl and #REGde for drawing a row of pixels
       movb a,d                        ; LD D,A            ; in the air bar
       movb @bytes+36,@l               ; LD L,36           ;
       movb @bytes+37,@e               ; LD E,37           ; }
       movb a,b                        ; LD B,A            ; Save the display file address MSB in #REGb briefly
       movb @air,a                     ; LD A,(32956)      ; Pick up the value of the initial air supply from #R32956
       sb   @bytes+36,a                ; SUB 36            ; {Now #REGc determines the length of the air bar (in cell
       movb a,@c                       ; LD C,A            ; widths)}
       movb b,a                        ; LD A,B            ; Restore the display file address MSB to #REGa
       sb   b,b                        ; LD B,0            ; Now #REGbc determines the length of the air bar (in cell
                                                           ; widths)
       movb @b255,*hl                  ; LD (HL),255       ; {Draw a single row of pixels across #REGc cells
       .ldir                           ; LDIR              ; }
       ab   one,a                      ; INC A             ; Increment the display file address MSB in #REGa (moving
                                                           ; down to the next row of pixels)
       cb   a,@bytes+zx_screen_msb+22  ; CP 86             ; Have we drawn all four rows of pixels in the air bar
                                                           ; yet?
       jne  _34519                     ; JR NZ,34519       ; If not, jump back to draw the next one
       li   ix,messhssc                ; LD IX,33839       ; {Print 'High Score 000000#SPACE(3)Score 000000' (see
       li   de,zx_screen+4192          ; LD DE,20576       ; #R33839) at (19,0)
       movb @bytes+32,@c               ; LD C,32           ; 
       .call @pmess                    ; CALL 37562        ; }
       movb @border,a                  ; LD A,(32883)      ; Pick up the border colour for the current cavern from
       ; movb @b254,@c                 ; LD C,254          ; {Set the border colour
       ; OUT (C),A                     ; OUT (C),A         ; }
       bl   @ti_set_border_color
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
       socb a,a                        ; OR A              ; Are we in demo mode?
       jeq  loop                       ; JR Z,34574        ; If not, enter the main loop now
       movb @bytes+64,a                ; LD A,64           ; {Reset the game mode indicator at #R33882 to #b64 (we're
       movb a,@demo                    ; LD (33882),A      ; in demo mode)}
* This routine continues into the main loop at #R34574.

* Main loop
* 
* The routine at #R34436 continues here.
* .
* The first thing to do is check whether there are any remaining lives to draw
* at the bottom of the screen.
loop:                                  ; 34574
       movb @nomen,a                   ; LD A,(33879)      ; Pick up the number of lives remaining from #R33879
       li   hl,zx_screen+4256          ; LD HL,20640       ; Set #REGhl to the display file address at which to draw
                                                           ; the first Willy sprite
       socb a,a                        ; OR A              ; Are there any lives remaining?
       jeq  _34608                     ; JR Z,34608        ; Jump if not
       movb a,b                        ; LD B,A            ; Initialise #REGb to the number of lives remaining
* The following loop draws the remaining lives at the bottom of the screen.
_34584:
       sb   @c,@c                      ; LD C,0            ; #REGc=0; this tells the sprite-drawing routine at
                                                           ; #R36852 to overwrite any existing graphics
       .push hl                        ; PUSH HL           ; {Save #REGhl and #REGbc briefly
       .push bc                        ; PUSH BC           ; }
       movb @noteindex,a               ; LD A,(33883)      ; Pick up the in-game music note index from #R33883; this
                                                           ; will determine the animation frame for the Willy sprites
       sla  a,1                        ; RLCA              ; TODO: check code. {Now #REGa=#b0 (frame 0), #b32 (frame 1), #b64 (frame 2)
       sla  a,1                        ; RLCA              ; TODO: check code. or #b96 (frame 3)
       sla  a,1                        ; RLCA              ; TODO: check code. 
       andi a,96*256                   ; AND 96            ; }
       movb a,@e                       ; LD E,A            ; {Point #REGde at the corresponding Willy sprite (at
       movb @bytes+(mandat//256),d     ; LD D,130          ; #R33280+#REGa)}
       .call @drwfix                   ; CALL 36852        ; Draw the Willy sprite on the screen
       .pop bc                         ; POP BC            ; {Restore #REGhl and #REGbc
       .pop hl                         ; POP HL            ; }
       inc  hl                         ; INC HL            ; {Move #REGhl along to the location at which to draw the
       inc  hl                         ; INC HL            ; next Willy sprite}
       sb   one,b                      ; DJNZ 34584        ; Jump back to draw any remaining sprites
       jne  _34584                     ;                   
* Now draw a boot if cheat mode has been activated.
_34608:
       movb @cheat,a                   ; LD A,(33885)      ; Pick up the 6031769 key counter from #R33885
       cb   a,@bytes+7                 ; CP 7              ; Has 6031769 been keyed in yet?
       jne  _34623                     ; JR NZ,34623       ; Jump if not
       li   de,boot                    ; LD DE,47840       ; Point #REGde at the graphic data for the boot (at
                                                           ; #R47840)
       sb   @c,@c                      ; LD C,0            ; #REGc=0 (overwrite mode)
       .call @drwfix                   ; CALL 36852        ; Draw the boot at the bottom of the screen next to the
                                                           ; remaining lives
* Next, prepare the screen and attribute buffers for drawing to the screen.
_34623:
       li   hl,attr_buffer_1           ; LD HL,24064       ; {Copy the contents of the attribute buffer at #R24064
       li   de,attr_buffer_2           ; LD DE,23552       ; (the attributes for the empty cavern) into the attribute
       li   bc,512                     ; LD BC,512         ; buffer at #R23552
       .ldir                           ; LDIR              ; }
       li   hl,scrn_buffer_1           ; LD HL,28672       ; {Copy the contents of the screen buffer at #R28672 (the
       li   de,scrn_buffer_2           ; LD DE,24576       ; tiles for the empty cavern) into the screen buffer at
       li   bc,4096                    ; LD BC,4096        ; #R24576
       .ldir                           ; LDIR              ; }
;       .call @movehg                   ; CALL 36111        ; Move the horizontal guardians in the current cavern
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
       socb a,a                        ; OR A              ; Are we in demo mode?
       jne  !                          ; CALL Z,35515      ; If not, move Willy
       .call @movewilly                ;                   
!
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
       socb a,a                        ; OR A              ; Are we in demo mode?
       jne  !                          ; CALL Z,37434      ; If not, check and set the attribute bytes for Willy's
       .call @willyattrs               ;                   
!
                                                           ; sprite in the buffer at #R23552, and draw Willy to the
                                                           ; screen buffer at #R24576
;       .call @drawhg                   ; CALL 36266        ; Draw the horizontal guardians in the current cavern
;       .call @mvconveyor               ; CALL 37125        ; Move the conveyor in the current cavern
;       .call @drawitems                ; CALL 36707        ; Draw the items in the current cavern and collect any
                                                           ; that Willy is touching
       movb @sheet,a                   ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   a,@bytes+4                 ; CP 4              ; Are we in #R49152(Eugene's Lair)?
       jne  !                          ; CALL Z,36344      ; If so, move and draw Eugene
       .call @eugene                   ;                   
!
       movb @sheet,a                   ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   a,@bytes+13                ; CP 13             ; Are we in #R58368(Skylab Landing Bay)?
       jne  !                          ; JP Z,36469        ; If so, move and draw the Skylabs
       b    @skylabs                   ;                   
!
       movb @sheet,a                   ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   a,@bytes+8                 ; CP 8              ; Are we in #R53248(Wacky Amoebatrons) or beyond?
       jl   !                          ; CALL NC,36593     ; If so, move and draw the vertical guardians
       .call @vguardians               ;                   
!
       movb @sheet,a                   ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   a,@bytes+7                 ; CP 7              ; Are we in #R52224(Miner Willy meets the Kong Beast)?
       jne  !                          ; CALL Z,37173      ; If so, move and draw the Kong Beast
       .call @kongbeast                ;                   
!
       movb @sheet,a                   ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   a,@bytes+11                ; CP 11             ; Are we in #R56320(Return of the Alien Kong Beast)?
       jne  !                          ; CALL Z,37173      ; If so, move and draw the Kong Beast
       .call @kongbeast                ;                   
!
       movb @sheet,a                   ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   a,@bytes+18                ; CP 18             ; Are we in #R63488(Solar Power Generator)?
       jne  !                          ; CALL Z,36211      ; If so, move and draw the light beam
       .call @lightbeam                ;                   
!
* This entry point is used by the routine at #R36469.
_34719:
       equ  $
       .call @chkportal                ; CALL 36805        ; Draw the portal, or move to the next cavern if Willy has
                                                           ; entered it
* This entry point is used by the routine at #R36101.
_34722:
       li   hl,scrn_buffer_2           ; LD HL,24576       ; {Copy the contents of the screen buffer at #R24576 to
       li   de,zx_screen               ; LD DE,16384       ; the display file
       li   bc,4096                    ; LD BC,4096        ; 
       .ldir                           ; LDIR              ; }
       movb @flash,a                   ; LD A,(33880)      ; Pick up the screen flash counter from #R33880
       socb a,a                        ; OR A              ; Is it zero?
       jeq  _34760                     ; JR Z,34760        ; Jump if so
       sb   one,a                      ; DEC A             ; {Decrement the screen flash counter at #R33880
       movb a,@flash                   ; LD (33880),A      ; }
       sla  a,1                        ; RLCA              ; TODO: check code. {Move bits 0-2 into bits 3-5 and clear all the other
       sla  a,1                        ; RLCA              ; TODO: check code. bits
       sla  a,1                        ; RLCA              ; TODO: check code. 
       andi a,56*256                   ; AND 56            ; }
       li   hl,attr_buffer_2           ; LD HL,23552       ; {Set every attribute byte in the buffer at #R23552 to
       li   de,attr_buffer_2+1         ; LD DE,23553       ; this value
       li   bc,511                     ; LD BC,511         ; 
       movb a,*hl                      ; LD (HL),A         ; 
       .ldir                           ; LDIR              ; }
_34760:
       li   hl,attr_buffer_2           ; LD HL,23552       ; {Copy the contents of the attribute buffer at #R23552 to
       li   de,zx_attrs                ; LD DE,22528       ; the attribute file
       li   bc,512                     ; LD BC,512         ; 
       .ldir                           ; LDIR              ; }
       li   ix,scorbuf                 ; LD IX,33833       ; {Print the score (see #R33833) at (19,26)
       li   de,zx_screen+4218          ; LD DE,20602       ; 
       movb @bytes+6,@c                ; LD C,6            ; 
       .call @pmess                    ; CALL 37562        ; }
       li   ix,hghscor                 ; LD IX,33823       ; {Print the high score (see #R33823) at (19,11)
       li   de,zx_screen+4203          ; LD DE,20587       ; 
       movb @bytes+6,@c                ; LD C,6            ; 
       .call @pmess                    ; CALL 37562        ; }

       bl   @upload_zx_screen

       .call @decair                   ; CALL 35388        ; Decrease the air remaining in the current cavern
       jne  !                          ; JP Z,35071        ; Jump if there's no air left
       b    @mandead                   ;                   
!
* Now check whether SHIFT and SPACE are being pressed.
       li   bc,65278                   ; LD BC,65278       ; {Read keys SHIFT-Z-X-C-V
       ; IN A,(C)                      ; IN A,(C)          ; }
       movb a,@e                       ; LD E,A            ; Save the result in #REGe
       movb @bytes+127,b               ; LD B,127          ; {Read keys B-N-M-SS-SPACE
       ; IN A,(C)                      ; IN A,(C)          ; }
       socb @e,a                       ; OR E              ; Combine the results
       andi a,1*256                    ; AND 1             ; Are SHIFT and SPACE being pressed?
       jne  !                          ; JP Z,34252        ; If so, quit the game
       b    @start                     ;                   
!
* Now read the keys A, S, D, F and G (which pause the game).
       movb @bytes+253,b               ; LD B,253          ; {Read keys A-S-D-F-G
       ; IN A,(C)                      ; IN A,(C)          ; }
       andi a,31*256                   ; AND 31            ; {Are any of these keys being pressed?
       cb   a,@bytes+31                ; CP 31             ; }
       jeq  _34837                     ; JR Z,34837        ; Jump if not
_34827:
       movb @bytes+2,b                 ; LD B,2            ; {Read every half-row of keys except A-S-D-F-G
       ; IN A,(C)                      ; IN A,(C)          ; }
       andi a,31*256                   ; AND 31            ; {Are any of these keys being pressed?
       cb   a,@bytes+31                ; CP 31             ; }
       jeq  _34827                     ; JR Z,34827        ; Jump back if not (the game is still paused)
* Here we check whether Willy has had a fatal accident.
_34837:
       movb @airborne,a                ; LD A,(32875)      ; Pick up the airborne status indicator from #R32875
       cb   a,@b255                    ; CP 255            ; Has Willy landed after falling from too great a height,
                                                           ; or collided with a nasty or a guardian?
       jne  !                          ; JP Z,35071        ; Jump if so
       b    @mandead                   ;                   
!
* Now read the keys H, J, K, L and ENTER (which toggle the in-game music).
       movb @bytes+191,b               ; LD B,191          ; Prepare #REGb for reading keys H-J-K-L-ENTER
       li   hl,musicflags              ; LD HL,33884       ; Point #REGhl at the music flags at #R33884
       ; IN A,(C)                      ; IN A,(C)          ; Read keys H-J-K-L-ENTER
       andi a,31*256                   ; AND 31            ; {Are any of these keys being pressed?
       cb   a,@bytes+31                ; CP 31             ; }
       jeq  _34868                     ; JR Z,34868        ; Jump if not
       movb *hl,r0                     ; BIT 0,(HL)        ; Were any of these keys being pressed the last time we
       andi r0,1*256                   ;                   
                                                           ; checked?
       jne  _34870                     ; JR NZ,34870       ; Jump if so
       movb *hl,a                      ; LD A,(HL)         ; {Set bit 0 (the keypress flag) and flip bit 1 (the
       li   r0,3*256                   ; XOR 3             ; in-game music flag) at #R33884
       xor  r0,a                       ;                   
       movb a,*hl                      ; LD (HL),A         ; }
       jmp  _34870                     ; JR 34870          ; 
_34868:
       szcb @bits+0,*hl                ; RES 0,(HL)        ; Reset bit 0 (the keypress flag) at #R33884
_34870:
       movb *hl,r0                     ; BIT 1,(HL)        ; Has the in-game music been switched off?
       andi r0,2*256                   ;                   
       jne  nonote4                    ; JR NZ,34911       ; Jump if so
* The next section of code plays a note of the in-game music.
* .
* #AUDIO(in-game-tune.wav)(#INCLUDE(InGameTune))
       movb @noteindex,a               ; LD A,(33883)      ; {Increment the in-game music note index at #R33883
       ab   one,a                      ; INC A             ; 
       movb a,@noteindex               ; LD (33883),A      ; }
       andi a,126*256                  ; AND 126           ; {Point #REGhl at the appropriate entry in the tune data
       srl  a,1                        ; RRCA              ; TODO: check code. table at #R34188
       movb a,@e                       ; LD E,A            ; 
       sb   d,d                        ; LD D,0            ; 
       li   hl,gametune                ; LD HL,34188       ; 
       a    de,hl                      ; ADD HL,DE         ; }
       movb @border,a                  ; LD A,(32883)      ; Pick up the border colour for the current cavern from
                                                           ; #R32883
       movb *hl,@e                     ; LD E,(HL)         ; Initialise the pitch delay counter in #REGe
       li   bc,3                       ; LD BC,3           ; Initialise the duration delay counters in #REGb (0) and
                                                           ; #REGc (3)
tm51:                                  ; 34898
       ; OUT (254),A                   ; OUT (254),A       ; {Produce a note of the in-game music
see37708:                              ; 34900
       sb   one,@e                     ; DEC E             ; 
       jne  noflp6                     ; JR NZ,34906       ; 
       movb *hl,@e                     ; LD E,(HL)         ; 
       li   r0,24*256                  ; XOR 24            ; 
       xor  r0,a                       ;                   
noflp6:                                ; 34906
       sb   one,b                      ; DJNZ 34898        ; 
       jne  tm51                       ;                   
       sb   one,@c                     ; DEC C             ; 
       jne  tm51                       ; JR NZ,34898       ; }
* If we're in demo mode, check the keyboard and joystick and return to the
* title screen if there's any input.
nonote4:                               ; 34911
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
       socb a,a                        ; OR A              ; Are we in demo mode?
       jeq  nodem1                     ; JR Z,34948        ; Jump if not
       sb   one,a                      ; DEC A             ; We're in demo mode; is it time to show the next cavern?
       jne  !                          ; JP Z,35071        ; Jump if so
       b    @mandead                   ;                   
!
       movb a,@demo                    ; LD (33882),A      ; Update the game mode indicator at #R33882
       li   bc,254                     ; LD BC,254         ; {Read every row of keys on the keyboard
       ; IN A,(C)                      ; IN A,(C)          ; }
       andi a,31*256                   ; AND 31            ; {Are any keys being pressed?
       cb   a,@bytes+31                ; CP 31             ; }
       jeq  !                          ; JP NZ,34252       ; If so, return to the title screen
       b    @start                     ;                   
!
       movb @kemp,a                    ; LD A,(33881)      ; Pick up the Kempston joystick indicator from #R33881
       socb a,a                        ; OR A              ; Is there a joystick connected?
       jeq  nodem1                     ; JR Z,34948        ; Jump if not
       ; IN A,(31)                     ; IN A,(31)         ; Collect input from the joystick
       socb a,a                        ; OR A              ; Is the joystick being moved or the fire button being
                                                           ; pressed?
       jeq  !                          ; JP NZ,34252       ; If so, return to the title screen
       b    @start                     ;                   
!
* Here we check the teleport keys.
nodem1:                                ; 34948
       equ  $
       li   bc,cavern15+1022           ; LD BC,61438       ; {Read keys 6-7-8-9-0
       ; IN A,(C)                      ; IN A,(C)          ; }
       movb a,r0                       ; BIT 4,A           ; Is '6' (the activator key) being pressed?
       andi r0,16*256                  ;                   
       jeq  !                          ; JP NZ,34984       ; Jump if not
       b    @ckcheat                   ;                   
!
       movb @cheat,a                   ; LD A,(33885)      ; Pick up the 6031769 key counter from #R33885
       cb   a,@bytes+7                 ; CP 7              ; Has 6031769 been keyed in yet?
       jeq  !                          ; JP NZ,34984       ; Jump if not
       b    @ckcheat                   ;                   
!
       movb @bytes+247,b               ; LD B,247          ; {Read keys 1-2-3-4-5
       ; IN A,(C)                      ; IN A,(C)          ; }
       inv  a                          ; CPL               ; {Keep only bits 0-4 and flip them
       andi a,31*256                   ; AND 31            ; }
       cb   a,@bytes+20                ; CP 20             ; Is the result #b20 or greater?
       jl   !                          ; JP NC,34984       ; Jump if so (this is not a cavern number)
       b    @ckcheat                   ;                   
!
       movb a,@sheet                   ; LD (33799),A      ; Store the cavern number at #R33799
       b    @newsht                    ; JP 34449          ; Teleport into the cavern
* Now check the 6031769 keys.
ckcheat:                               ; 34984
       movb @cheat,a                   ; LD A,(33885)      ; Pick up the 6031769 key counter from #R33885
       cb   a,@bytes+7                 ; CP 7              ; Has 6031769 been keyed in yet?
       jne  !                          ; JP Z,34574        ; If so, jump back to the start of the main loop
       b    @loop                      ;                   
!
       sla  a,1                        ; RLCA              ; TODO: check code. {Point #REGix at the corresponding entry in the 6031769
       movb a,@e                       ; LD E,A            ; table at #R33888
       sb   d,d                        ; LD D,0            ; 
       li   ix,cheatdt                 ; LD IX,33888       ; 
       a    de,ix                      ; ADD IX,DE         ; }
       li   bc,cavern17+1022           ; LD BC,63486       ; {Read keys 1-2-3-4-5
       ; IN A,(C)                      ; IN A,(C)          ; }
       andi a,31*256                   ; AND 31            ; Keep only bits 0-4
       cb   a,*ix                      ; CP (IX+0)         ; Does this match the first byte of the entry in the
                                                           ; 6031769 table?
       jeq  cknxcht                    ; JR Z,35032        ; Jump if so
       cb   a,@bytes+31                ; CP 31             ; Are any of the keys 1-2-3-4-5 being pressed?
       jne  !                          ; JP Z,34574        ; If not, jump back to the start of the main loop
       b    @loop                      ;                   
!
       cb   a,@-2(ix)                  ; CP (IX-2)         ; Does the keyboard reading match the first byte of the
                                                           ; previous entry in the 6031769 table?
       jne  !                          ; JP Z,34574        ; If so, jump back to the start of the main loop
       b    @loop                      ;                   
!
       sb   a,a                        ; XOR A             ; {Reset the 6031769 key counter at #R33885 to 0 (an
       movb a,@cheat                   ; LD (33885),A      ; incorrect key is being pressed)}
       b    @loop                      ; JP 34574          ; Jump back to the start of the main loop
cknxcht:                               ; 35032
       movb @bytes+239,b               ; LD B,239          ; {Read keys 6-7-8-9-0
       ; IN A,(C)                      ; IN A,(C)          ; }
       andi a,31*256                   ; AND 31            ; Keep only bits 0-4
       cb   a,@1(ix)                   ; CP (IX+1)         ; Does this match the second byte of the entry in the
                                                           ; 6031769 table?
       jeq  inccht                     ; JR Z,35061        ; If so, jump to increment the 6031769 key counter
       cb   a,@bytes+31                ; CP 31             ; Are any of the keys 6-7-8-9-0 being pressed?
       jne  !                          ; JP Z,34574        ; If not, jump back to the start of the main loop
       b    @loop                      ;                   
!
       cb   a,@-1(ix)                  ; CP (IX-1)         ; Does the keyboard reading match the second byte of the
                                                           ; previous entry in the 6031769 table?
       jne  !                          ; JP Z,34574        ; If so, jump back to the start of the main loop
       b    @loop                      ;                   
!
       sb   a,a                        ; XOR A             ; {Reset the 6031769 key counter at #R33885 to 0 (an
       movb a,@cheat                   ; LD (33885),A      ; incorrect key is being pressed)}
       b    @loop                      ; JP 34574          ; Jump back to the start of the main loop
inccht:                                ; 35061
       movb @cheat,a                   ; LD A,(33885)      ; {Increment the 6031769 key counter at #R33885 (the next
       ab   one,a                      ; INC A             ; key in the sequence is being pressed)
       movb a,@cheat                   ; LD (33885),A      ; }
       b    @loop                      ; JP 34574          ; Jump back to the start of the main loop
* The air in the cavern has run out, or Willy has had a fatal accident, or it's
* demo mode and it's time to show the next cavern.
mandead:                               ; 35071
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
       socb a,a                        ; OR A              ; Is it demo mode?
       jeq  !                          ; JP NZ,36904       ; If so, move to the next cavern
       b    @nxsheet                   ;                   
!
       movb @bytes+71,a                ; LD A,71           ; #REGa=#b71 (INK 7: PAPER 0: BRIGHT 1)
* The following loop fills the top two thirds of the attribute file with a
* single value (#b71, #b70, #b69, #b68, #b67, #b66, #b65 or #b64) and makes a
* sound effect.
* .
* #AUDIO(die.wav)(#FOR(7,63,8,7)(d,[13*d+33]*(259-4*d),13*d+10895))
lpdead1:                               ; 35080
       li   hl,zx_attrs                ; LD HL,22528       ; {Fill the top two thirds of the attribute file with the
       li   de,zx_attrs+1              ; LD DE,22529       ; value in #REGa
       li   bc,511                     ; LD BC,511         ; 
       movb a,*hl                      ; LD (HL),A         ; 
       .ldir                           ; LDIR              ; }
       movb a,@e                       ; LD E,A            ; Save the attribute byte (#b64-#b71) in #REGe for later
                                                           ; retrieval
       inv  a                          ; CPL               ; {#REGd=63-8*(#REGe #S/AND/ 7); this value determines the
       andi a,7*256                    ; AND 7             ; pitch of the short note that will be played
       sla  a,1                        ; RLCA              ; TODO: check code. 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       socb @bytes+7,a                 ; OR 7              ; 
       movb a,d                        ; LD D,A            ; }
       movb @e,@c                      ; LD C,E            ; {#REGc=8+32*(#REGe #S/AND/ 7); this value determines the
       ; RRC C                         ; RRC C             ; duration of the short note that will be played
       ; RRC C                         ; RRC C             ; 
       ; RRC C                         ; RRC C             ; }
       socb @bytes+16,a                ; OR 16             ; Set bit 4 of #REGa (for no apparent reason)
       sb   a,a                        ; XOR A             ; Set #REGa=0 (this will make the border black)
tm21:                                  ; 35112
       ; OUT (254),A                   ; OUT (254),A       ; {Produce a short note whose pitch is determined by #REGd
       li   r0,24*256                  ; XOR 24            ; and whose duration is determined by #REGc
       xor  r0,a                       ;                   
       movb d,b                        ; LD B,D            ; 
tm22:                                  ; 35117
       sb   one,b                      ; DJNZ 35117        ; 
       jne  tm22                       ;                   
       sb   one,@c                     ; DEC C             ; 
       jne  tm21                       ; JR NZ,35112       ; }
       movb @e,a                       ; LD A,E            ; Restore the attribute byte (originally #b71) to #REGa
       sb   one,a                      ; DEC A             ; Decrement it (effectively decrementing the INK colour)
       cb   a,@bytes+63                ; CP 63             ; Have we used attribute value #b64 (INK 0) yet?
       jne  lpdead1                    ; JR NZ,35080       ; If not, jump back to update the INK colour in the top
                                                           ; two thirds of the screen and make another sound effect
* Finally, check whether any lives remain.
       li   hl,nomen                   ; LD HL,33879       ; {Pick up the number of lives remaining from #R33879
       movb *hl,a                      ; LD A,(HL)         ; }
       socb a,a                        ; OR A              ; Are there any lives remaining?
       jne  !                          ; JP Z,35140        ; If not, display the game over sequence
       b    @endgam                    ;                   
!
       sb   one,*hl                    ; DEC (HL)          ; Decrease the number of lives remaining by one
       b    @newsht                    ; JP 34449          ; Jump back to reinitialise the current cavern

* Display the game over sequence
* 
* Used by the routine at #R34574. First check whether we have a new high score.
endgam:                                ; 35140
       li   hl,hghscor                 ; LD HL,33823       ; Point #REGhl at the high score at #R33823
       li   de,scorbuf                 ; LD DE,33833       ; Point #REGde at the current score at #R33833
       movb @bytes+6,b                 ; LD B,6            ; There are 6 digits to compare
lphgh:                                 ; 35148
       movb *de,a                      ; LD A,(DE)         ; Pick up a digit of the current score
       cb   a,*hl                      ; CP (HL)           ; Compare it with the corresponding digit of the high
                                                           ; score
       jhe  !                          ; JP C,35171        ; Jump if it's less than the corresponding digit of the
       b    @feet                      ;                   
!
                                                           ; high score
       jeq  !                          ; JP NZ,35160       ; Jump if it's greater than the corresponding digit of the
       b    @newhgh                    ;                   
!
                                                           ; high score
       inc  hl                         ; INC HL            ; Point #REGhl at the next digit of the high score
       inc  de                         ; INC DE            ; Point #REGde at the next digit of the current score
       sb   one,b                      ; DJNZ 35148        ; Jump back to compare the next pair of digits
       jne  lphgh                      ;                   
newhgh:                                ; 35160
       li   hl,scorbuf                 ; LD HL,33833       ; {Replace the high score with the current score
       li   de,hghscor                 ; LD DE,33823       ; 
       li   bc,6                       ; LD BC,6           ; 
       .ldir                           ; LDIR              ; }
* Now prepare the screen for the game over sequence.
feet:                                  ; 35171
       li   hl,zx_screen               ; LD HL,16384       ; {Clear the top two-thirds of the display file
       li   de,zx_screen+1             ; LD DE,16385       ; 
       li   bc,4095                    ; LD BC,4095        ; 
       sb   *hl,*hl                    ; LD (HL),0         ; 
       .ldir                           ; LDIR              ; }
       sb   a,a                        ; XOR A             ; {Initialise the game status buffer variable at #R32988;
       movb a,@eughgt                  ; LD (32988),A      ; this variable will determine the distance of the boot
                                                           ; from the top of the screen}
       li   de,willyr2                 ; LD DE,33344       ; {Draw Willy at (12,15)
       li   hl,zx_screen+2191          ; LD HL,18575       ; 
       sb   @c,@c                      ; LD C,0            ; 
       .call @drwfix                   ; CALL 36852        ; }
       li   de,plinth                  ; LD DE,46816       ; {Draw the plinth (see #R46816) underneath Willy at
       li   hl,zx_screen+2255          ; LD HL,18639       ; (14,15)
       sb   @c,@c                      ; LD C,0            ; 
       .call @drwfix                   ; CALL 36852        ; }
* The following loop draws the boot's descent onto the plinth that supports
* Willy while producing a sound effect.
* .
* #AUDIO(game-over.wav)(#GAMEOVER)
loopft:                                ; 35210
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the distance variable from #R32988
       movb a,@c                       ; LD C,A            ; {Point #REGbc at the corresponding entry in the screen
       movb @sbufaddrs_msb_byte,b      ; LD B,131          ; buffer address lookup table at #R33536}
       movb *bc,a                      ; LD A,(BC)         ; {Point #REGhl at the corresponding location in the
       socb @bytes+15,a                ; OR 15             ; display file
       movb a,@l                       ; LD L,A            ; 
       inc  bc                         ; INC BC            ; 
       movb *bc,a                      ; LD A,(BC)         ; 
       sb   @bytes+32,a                ; SUB 32            ; 
       movb a,h                        ; LD H,A            ; }
       li   de,boot                    ; LD DE,47840       ; {Draw the boot (see #R47840) at this location, without
       sb   @c,@c                      ; LD C,0            ; erasing the boot at the previous location; this leaves
       .call @drwfix                   ; CALL 36852        ; the portion of the boot sprite that's above the ankle in
                                                           ; place, and makes the boot appear as if it's at the end
                                                           ; of a long, extending trouser leg}
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the distance variable from #R32988
       inv  a                          ; CPL               ; #REGa=#b255-#REGa
       movb a,@e                       ; LD E,A            ; Store this value (#b63-#b255) in #REGe; it determines
                                                           ; the (rising) pitch of the sound effect that will be made
       sb   a,a                        ; XOR A             ; #REGa=0 (black border)
       li   bc,64                      ; LD BC,64          ; #REGc=#b64; this value determines the duration of the
                                                           ; sound effect
tm111:                                 ; 35242
       ; OUT (254),A                   ; OUT (254),A       ; {Produce a short note whose pitch is determined by #REGe
       li   r0,24*256                  ; XOR 24            ; 
       xor  r0,a                       ;                   
       movb @e,b                       ; LD B,E            ; 
tm112:                                 ; 35247
       sb   one,b                      ; DJNZ 35247        ; 
       jne  tm112                      ;                   
       sb   one,@c                     ; DEC C             ; 
       jne  tm111                      ; JR NZ,35242       ; }
       li   hl,zx_attrs                ; LD HL,22528       ; {Prepare #REGbc, #REGde and #REGhl for setting the
       li   de,zx_attrs+1              ; LD DE,22529       ; attribute bytes in the top two-thirds of the screen
       li   bc,511                     ; LD BC,511         ; }
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the distance variable from #R32988
       andi a,12*256                   ; AND 12            ; Keep only bits 2 and 3
       sla  a,1                        ; RLCA              ; TODO: check code. Shift bits 2 and 3 into bits 3 and 4; these bits
                                                           ; determine the PAPER colour: 0, 1, 2 or 3
       socb @bytes+71,a                ; OR 71             ; Set bits 0-2 (INK 7) and 6 (BRIGHT 1)
       movb a,*hl                      ; LD (HL),A         ; {Copy this attribute value into the top two-thirds of
       .ldir                           ; LDIR              ; the screen}
       movb @eughgt,a                  ; LD A,(32988)      ; {Add 4 to the distance variable at #R32988; this will
       ab   @bytes+4,a                 ; ADD A,4           ; move the boot sprite down two pixel rows
       movb a,@eughgt                  ; LD (32988),A      ; }
       cb   a,@bytes+196               ; CP 196            ; Has the boot met the plinth yet?
       jne  loopft                     ; JR NZ,35210       ; Jump back if not
* Now print the "Game Over" message, just to drive the point home.
       li   ix,messg                   ; LD IX,33871       ; {Print "Game" (see #R33871) at (6,10)
       movb @bytes+4,@c                ; LD C,4            ; 
       li   de,zx_screen+202           ; LD DE,16586       ; 
       .call @pmess                    ; CALL 37562        ; }
       li   ix,messo                   ; LD IX,33875       ; {Print "Over" (see #R33875) at (6,18)
       movb @bytes+4,@c                ; LD C,4            ; 
       li   de,zx_screen+210           ; LD DE,16594       ; 
       .call @pmess                    ; CALL 37562        ; }
       li   bc,0                       ; LD BC,0           ; {Prepare the delay counters for the following loop; the
       movb @bytes+6,d                 ; LD D,6            ; counter in #REGc will also determine the INK colours to
                                                           ; use for the "Game Over" message}
* The following loop makes the "Game Over" message glisten for about 1.57s.
tm91:                                  ; 35313
       sb   one,b                      ; DJNZ 35313        ; Delay for about a millisecond
       jne  tm91                       ;                   
       movb @c,a                       ; LD A,C            ; {Change the INK colour of the "G" in "Game" at (6,10)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+202            ; LD (22730),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "a" in "Game" at (6,11)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+203            ; LD (22731),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "m" in "Game" at (6,12)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+204            ; LD (22732),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "e" in "Game" at (6,13)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+205            ; LD (22733),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "O" in "Over" at (6,18)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+210            ; LD (22738),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "v" in "Over" at (6,19)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+211            ; LD (22739),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "e" in "Over" at (6,20)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+212            ; LD (22740),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "r" in "Over" at (6,21)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+213            ; LD (22741),A      ; }
       sb   one,@c                     ; DEC C             ; Decrement the counter in #REGc
       jne  tm91                       ; JR NZ,35313       ; Jump back unless it's zero
       sb   one,d                      ; DEC D             ; Decrement the counter in #REGd (initially 6)
       jne  tm91                       ; JR NZ,35313       ; Jump back unless it's zero
       b    @start                     ; JP 34252          ; Display the title screen and play the theme tune

* Decrease the air remaining in the current cavern
* 
* Used by the routines at #R34574, #R36211 and #R36904. Returns with the zero
* flag set if there is no air remaining.
decair:                                ; 35388
       movb @clock,a                   ; LD A,(32957)      ; {Update the game clock at #R32957
       sb   @bytes+4,a                 ; SUB 4             ; 
       movb a,@clock                   ; LD (32957),A      ; }
       cb   a,@bytes+252               ; CP 252            ; Was it just decreased from zero?
       jne  _35413                     ; JR NZ,35413       ; Jump if not
       movb @air,a                     ; LD A,(32956)      ; Pick up the value of the remaining air supply from
                                                           ; #R32956
       cb   a,@bytes+36                ; CP 36             ; Has the air supply run out?
       jne  !                          ; RET Z             ; Return (with the zero flag set) if so
       .ret                            ;                   
!
       sb   one,a                      ; DEC A             ; {Decrement the air supply at #R32956
       movb a,@air                     ; LD (32956),A      ; }
       movb @clock,a                   ; LD A,(32957)      ; Pick up the value of the game clock at #R32957
_35413:
       andi a,224*256                  ; AND 224           ; {#REGa=INT(#REGa/32); this value specifies how many
       sla  a,1                        ; RLCA              ; TODO: check code. pixels to draw from left to right in the cell at the
       sla  a,1                        ; RLCA              ; TODO: check code. right end of the air bar
       sla  a,1                        ; RLCA              ; TODO: check code. }
       sb   @e,@e                      ; LD E,0            ; Initialise #REGe to 0 (all bits reset)
       socb a,a                        ; OR A              ; Do we need to draw any pixels in the cell at the right
                                                           ; end of the air bar?
       jeq  _35430                     ; JR Z,35430        ; Jump if not
       movb a,b                        ; LD B,A            ; Copy the number of pixels to draw (1-7) to #REGb
_35424:
       ; RRC E                         ; RRC E             ; {Set this many bits in #REGe (from bit 7 towards bit 0)
       socb @bits+7,@e                 ; SET 7,E           ; 
       sb   one,b                      ; DJNZ 35424        ; }
       jne  _35424                     ;                   
_35430:
       movb @air,a                     ; LD A,(32956)      ; Pick up the value of the remaining air supply from
                                                           ; #R32956
       movb a,@l                       ; LD L,A            ; {Set #REGhl to the display file address at which to draw
       movb @bytes+82,h                ; LD H,82           ; the top row of pixels in the cell at the right end of
                                                           ; the air bar}
       movb @bytes+4,b                 ; LD B,4            ; There are four rows of pixels to draw
_35438:
       movb @e,*hl                     ; LD (HL),E         ; {Draw the four rows of pixels at the right end of the
       ab   one,h                      ; INC H             ; air bar
       sb   one,b                      ; DJNZ 35438        ; }
       jne  _35438                     ;                   
       sb   a,a                        ; XOR A             ; {Reset the zero flag to indicate that there is still
       ab   one,a                      ; INC A             ; some air remaining; these instructions are redundant,
                                                           ; since the zero flag is already reset at this point}
       .ret                            ; RET               ; 

* Draw the current cavern to the screen buffer at #N28672
* 
* Used by the routine at #R34436.
drawsheet:                             ; 35445
       li   ix,attr_buffer_1           ; LD IX,24064       ; Point #REGix at the first byte of the attribute buffer
                                                           ; at #R24064
;       movb @bytes+112,a               ; LD A,112          ; {Set the operand of the '#S/LD D/,n' instruction at
;       movb a,@sbmsb+1                 ; LD (35484),A      ; #R35483 (below) to #n112}
       li   r0,bytes+(scrn_buffer_1//256)
       mov  r0,@sbmsb+2
       .call @_35466                   ; CALL 35466        ; Draw the tiles for the top half of the cavern to the
                                                           ; screen buffer at #R28672
       li   ix,attr_buffer_1+256       ; LD IX,24320       ; Point #REGix at the 256th byte of the attribute buffer
                                                           ; at #R24064 in preparation for drawing the bottom half of
                                                           ; the cavern; this instruction is redundant, since #REGix
                                                           ; already holds #N24320
;       movb @bytes+120,a               ; LD A,120          ; {Set the operand of the '#S/LD D/,n' instruction at
;       movb a,@sbmsb+1                 ; LD (35484),A      ; #R35483 (below) to #n120}
       li   r0,bytes+(scrn_buffer_1//256)+8
       mov  r0,@sbmsb+2
_35466:
       sb   @c,@c                      ; LD C,0            ; #REGc will count 256 tiles
* The following loop draws 256 tiles (for either the top half or the bottom
* half of the cavern) to the screen buffer at #R28672.
_35468:
       movb @c,@e                      ; LD E,C            ; #REGe holds the LSB of the screen buffer address
       movb *ix,a                      ; LD A,(IX+0)       ; Pick up an attribute byte from the buffer at #R24064;
                                                           ; this identifies the type of tile to draw
       li   hl,background              ; LD HL,32800       ; {Move #REGhl through the attribute bytes and graphic
       li   bc,72                      ; LD BC,72          ; data of the background, floor, crumbling floor, wall,
!      cb   a,*hl+                     ; CPIR              ; conveyor and nasty tiles starting at #R32800 until we
       jeq  !                                              ; find a byte that matches the attribute byte of the tile
       dec  bc                                             ; to be drawn}
       jne  -!
!      dec  hl

       movb @e,@c                      ; LD C,E            ; Restore the value of the tile counter in #REGc
       movb @bytes+8,b                 ; LD B,8            ; There are eight bytes in the tile
sbmsb:                                 ; 35483
       movb @bytes+0,d                 ; LD D,0            ; This instruction is set to either '#S/LD D/,#n112' or
                                                           ; '#S/LD D/,#n120' above; now #REGde holds the appropriate
                                                           ; address in the screen buffer at #R28672
_35485:
       movb *hl,a                      ; LD A,(HL)         ; {Copy the tile graphic data to the screen buffer at
       movb a,*de                      ; LD (DE),A         ; #R28672
       inc  hl                         ; INC HL            ; 
       ab   one,d                      ; INC D             ; 
       sb   one,b                      ; DJNZ 35485        ; }
       jne  _35485                     ;                   
       inc  ix                         ; INC IX            ; Move #REGix along to the next byte in the attribute
                                                           ; buffer
       ab   one,@c                     ; INC C             ; Have we drawn 256 tiles yet?
       jeq  !                          ; JP NZ,35468       ; If not, jump back to draw the next one
       b    @_35468                    ;                   
!
* The empty cavern has been drawn to the screen buffer at #R28672. If we're in
* #R64512(The Final Barrier), however, there is further work to do.
       movb @sheet,a                   ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   a,@bytes+19                ; CP 19             ; Is it #R64512(The Final Barrier)?
       jeq  !                          ; RET NZ            ; Return if not
       .ret                            ;                   
!
       seto @title_screen_bank_select
       li   hl,titlescr1               ; LD HL,40960       ; {Copy the graphic data from #R40960 to the top half of
       li   de,scrn_buffer_1           ; LD DE,28672       ; the screen buffer at #R28672
       li   bc,2048                    ; LD BC,2048        ; 
       .ldir                           ; LDIR              ; }
       .ret                            ; RET               ; 

* Move Willy (1)
* 
* Used by the routine at #R34574. This routine deals with Willy if he's jumping
* or falling.
movewilly:                             ; 35515
       movb @airborne,a                ; LD A,(32875)      ; Pick up the airborne status indicator from #R32875
       cb   a,one                      ; CP 1              ; Is Willy jumping?
       jne  _35600                     ; JR NZ,35600       ; Jump if not
* Willy is currently jumping.
* .
* #AUDIO(jumping.wav)(#FOR1,18,,3(j,[104*(#IF(j>8)(j-8,8-j))+137]*31,280000))
       movb @jumping,a                 ; LD A,(32878)      ; Pick up the jumping animation counter (0-17) from
                                                           ; #R32878
       szcb @bits+0,a                  ; RES 0,A           ; {Now -8<=#REGa<=8 (and #REGa is even)
       sb   @bytes+8,a                 ; SUB 8             ; }
       li   hl,willy_y                 ; LD HL,32872       ; {Adjust Willy's y-coordinate at #R32872 depending on
       ab   *hl,a                      ; ADD A,(HL)        ; where Willy is in the jump
       movb a,*hl                      ; LD (HL),A         ; }
       .call @_35714                   ; CALL 35714        ; Adjust Willy's attribute buffer location at #R32876
                                                           ; depending on his y-coordinate
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
       cb   a,*hl                      ; CP (HL)           ; Is the top-left cell of Willy's sprite overlapping a
                                                           ; wall tile?
       jne  !                          ; JP Z,35746        ; Jump if so
       b    @_35746                    ;                   
!
       inc  hl                         ; INC HL            ; Point #REGhl at the top-right cell occupied by Willy's
                                                           ; sprite
       cb   a,*hl                      ; CP (HL)           ; Is the top-right cell of Willy's sprite overlapping a
                                                           ; wall tile?
       jne  !                          ; JP Z,35746        ; Jump if so
       b    @_35746                    ;                   
!
       movb @jumping,a                 ; LD A,(32878)      ; {Increment the jumping animation counter at #R32878
       ab   one,a                      ; INC A             ; 
       movb a,@jumping                 ; LD (32878),A      ; }
       sb   @bytes+8,a                 ; SUB 8             ; #REGa=J-8, where J (1-18) is the new value of the
                                                           ; jumping animation counter
       ; JP P,35563                    ; JP P,35563        ; Jump if J>=8
       neg a                           ; NEG               ; #REGa=8-J (1<=J<=7, 1<=#REGa<=7)
_35563:
       ab   one,a                      ; INC A             ; #REGa=1+ABS(J-8)
       sla  a,1                        ; RLCA              ; TODO: check code. {#REGd=8*(1+ABS(J-8)); this value determines the pitch
       sla  a,1                        ; RLCA              ; TODO: check code. of the jumping sound effect (rising as Willy rises,
       sla  a,1                        ; RLCA              ; TODO: check code. falling as Willy falls)
       movb a,d                        ; LD D,A            ; }
       movb @bytes+32,@c               ; LD C,32           ; This value determines the duration of the jumping sound
                                                           ; effect
       movb @border,a                  ; LD A,(32883)      ; Pick up the border colour for the current cavern from
                                                           ; #R32883
_35573:
       ; OUT (254),A                   ; OUT (254),A       ; {Make a jumping sound effect
       li   r0,24*256                  ; XOR 24            ; 
       xor  r0,a                       ;                   
       movb d,b                        ; LD B,D            ; 
_35578:
       sb   one,b                      ; DJNZ 35578        ; 
       jne  _35578                     ;                   
       sb   one,@c                     ; DEC C             ; 
       jne  _35573                     ; JR NZ,35573       ; }
       movb @jumping,a                 ; LD A,(32878)      ; Pick up the jumping animation counter (1-18) from
                                                           ; #R32878
       cb   a,@bytes+18                ; CP 18             ; Has Willy reached the end of the jump?
       jne  !                          ; JP Z,35734        ; Jump if so
       b    @_35734                    ;                   
!
       cb   a,@bytes+16                ; CP 16             ; Is the jumping animation counter now 16?
       jeq  _35600                     ; JR Z,35600        ; Jump if so
       cb   a,@bytes+13                ; CP 13             ; Is the jumping animation counter now 13?
       jeq  !                          ; JP NZ,35971       ; Jump if not
       b    @_35971                    ;                   
!
* If we get here, then Willy is standing on the floor, or he's falling, or his
* jumping animation counter is 13 (at which point Willy is on his way down and
* is exactly two cell-heights above where he started the jump) or 16 (at which
* point Willy is on his way down and is exactly one cell-height above where he
* started the jump).
_35600:
       equ  $
       movb @willy_y,a                 ; LD A,(32872)      ; Pick up Willy's y-coordinate from #R32872
       andi a,15*256                   ; AND 15            ; Does Willy's sprite occupy six cells at the moment?
       jne  _35665                     ; JR NZ,35665       ; Jump if so
       mov  @location,hl               ; LD HL,(32876)     ; Pick up Willy's attribute buffer coordinates from
                                                           ; #R32876
       li   de,64                      ; LD DE,64          ; {Point #REGhl at the left-hand cell below Willy's sprite
       a    de,hl                      ; ADD HL,DE         ; }
       movb @crumbling,a               ; LD A,(32818)      ; Pick up the attribute byte of the crumbling floor tile
                                                           ; for the current cavern from #R32818
       cb   a,*hl                      ; CP (HL)           ; Does the left-hand cell below Willy's sprite contain a
                                                           ; crumbling floor tile?
       jne  !                          ; CALL Z,35770      ; If so, make it crumble
       .call @crumble                  ;                   
!
       movb @nasty1,a                  ; LD A,(32845)      ; Pick up the attribute byte of the first nasty tile for
                                                           ; the current cavern from #R32845
       cb   a,*hl                      ; CP (HL)           ; Does the left-hand cell below Willy's sprite contain a
                                                           ; nasty tile?
       jeq  _35665                     ; JR Z,35665        ; Jump if so
       movb @nasty2,a                  ; LD A,(32854)      ; Pick up the attribute byte of the second nasty tile for
                                                           ; the current cavern from #R32854
       cb   a,*hl                      ; CP (HL)           ; Does the left-hand cell below Willy's sprite contain a
                                                           ; nasty tile?
       jeq  _35665                     ; JR Z,35665        ; Jump if so
       inc  hl                         ; INC HL            ; Point #REGhl at the right-hand cell below Willy's sprite
       movb @crumbling,a               ; LD A,(32818)      ; Pick up the attribute byte of the crumbling floor tile
                                                           ; for the current cavern from #R32818
       cb   a,*hl                      ; CP (HL)           ; Does the right-hand cell below Willy's sprite contain a
                                                           ; crumbling floor tile?
       jne  !                          ; CALL Z,35770      ; If so, make it crumble
       .call @crumble                  ;                   
!
       movb @nasty1,a                  ; LD A,(32845)      ; Pick up the attribute byte of the first nasty tile for
                                                           ; the current cavern from #R32845
       cb   a,*hl                      ; CP (HL)           ; Does the right-hand cell below Willy's sprite contain a
                                                           ; nasty tile?
       jeq  _35665                     ; JR Z,35665        ; Jump if so
       movb @nasty2,a                  ; LD A,(32854)      ; Pick up the attribute byte of the second nasty tile for
                                                           ; the current cavern from #R32854
       cb   a,*hl                      ; CP (HL)           ; Does the right-hand cell below Willy's sprite contain a
                                                           ; nasty tile?
       jeq  _35665                     ; JR Z,35665        ; Jump if so
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       cb   a,*hl                      ; CP (HL)           ; Set the zero flag if the right-hand cell below Willy's
                                                           ; sprite is empty
       dec  hl                         ; DEC HL            ; Point #REGhl at the left-hand cell below Willy's sprite
       jeq  !                          ; JP NZ,35805       ; Jump if the right-hand cell below Willy's sprite is not
       b    @movewilly2                ;                   
!
                                                           ; empty
       cb   a,*hl                      ; CP (HL)           ; Is the left-hand cell below Willy's sprite empty?
       jeq  !                          ; JP NZ,35805       ; Jump if not
       b    @movewilly2                ;                   
!
_35665:
       equ  $
       movb @airborne,a                ; LD A,(32875)      ; Pick up the airborne status indicator from #R32875
       cb   a,one                      ; CP 1              ; Is Willy jumping?
       jne  !                          ; JP Z,35971        ; Jump if so
       b    @_35971                    ;                   
!
* If we get here, then Willy is either in the process of falling or just about
* to start falling.
* .
* #AUDIO(falling.wav)(#FOR(3,28,1,3)(a,[(208*a+33)%3315]*31,280000))
       li   hl,dmflags                 ; LD HL,32874       ; {Reset bit 1 at #R32874: Willy is not moving left or
       szcb @bits+1,*hl                ; RES 1,(HL)        ; right}
       socb a,a                        ; OR A              ; Is Willy already falling?
       jne  !                          ; JP Z,35740        ; Jump if not
       b    @_35740                    ;                   
!
       ab   one,a                      ; INC A             ; {Increment the airborne status indicator at #R32875
       movb a,@airborne                ; LD (32875),A      ; }
       sla  a,1                        ; RLCA              ; TODO: check code. {The value of #REGd determines the pitch of the falling
       sla  a,1                        ; RLCA              ; TODO: check code. sound effect
       sla  a,1                        ; RLCA              ; TODO: check code. 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       movb a,d                        ; LD D,A            ; }
       movb @bytes+32,@c               ; LD C,32           ; This value determines the duration of the falling sound
                                                           ; effect
       movb @border,a                  ; LD A,(32883)      ; Pick up the border colour for the current cavern from
                                                           ; #R32883
_35696:
       ; OUT (254),A                   ; OUT (254),A       ; {Make a falling sound effect
       li   r0,24*256                  ; XOR 24            ; 
       xor  r0,a                       ;                   
       movb d,b                        ; LD B,D            ; 
_35701:
       sb   one,b                      ; DJNZ 35701        ; 
       jne  _35701                     ;                   
       sb   one,@c                     ; DEC C             ; 
       jne  _35696                     ; JR NZ,35696       ; }
       movb @willy_y,a                 ; LD A,(32872)      ; {Add 8 to Willy's y-coordinate at #R32872; this moves
       ab   @bytes+8,a                 ; ADD A,8           ; Willy downwards by 4 pixels
       movb a,@willy_y                 ; LD (32872),A      ; }
_35714:
       andi a,240*256                  ; AND 240           ; {#REGl=16*Y, where Y is Willy's screen y-coordinate
       movb a,@l                       ; LD L,A            ; (0-14)}
       sb   a,a                        ; XOR A             ; Clear #REGa and the carry flag
       ; RL L                          ; RL L              ; Now #REGl=32*(Y-8*INT(Y/8)), and the carry flag is set
                                                           ; if Willy is in the lower half of the cavern (Y>=8)
       ab   @bytes+92,a                ; ADC A,92          ; {#REGh=#b92 or #b93 (MSB of the address of Willy's
       movb a,h                        ; LD H,A            ; location in the attribute buffer)}
       movb @location,a                ; LD A,(32876)      ; {Pick up Willy's screen x-coordinate (1-29) from bits
       andi a,31*256                   ; AND 31            ; 0-4 at #R32876}
       socb @l,a                       ; OR L              ; {Now #REGl holds the LSB of Willy's attribute buffer
       movb a,@l                       ; LD L,A            ; address}
       mov  hl,@location               ; LD (32876),HL     ; Store Willy's updated attribute buffer location at
                                                           ; #R32876
       .ret                            ; RET               ; 
* Willy has just finished a jump.
_35734:
       movb @bytes+6,a                 ; LD A,6            ; {Set the airborne status indicator at #R32875 to #b6:
       movb a,@airborne                ; LD (32875),A      ; Willy will continue to fall unless he's landed on a wall
                                                           ; or floor block}
       .ret                            ; RET               ; 
* Willy has just started falling.
_35740:
       movb @bytes+2,a                 ; LD A,2            ; {Set the airborne status indicator at #R32875 to #b2
       movb a,@airborne                ; LD (32875),A      ; }
       .ret                            ; RET               ; 
* The top-left or top-right cell of Willy's sprite is overlapping a wall tile.
_35746:
       movb @willy_y,a                 ; LD A,(32872)      ; {Adjust Willy's y-coordinate at #R32872 so that the top
       ab   @bytes+16,a                ; ADD A,16          ; row of cells of his sprite is just below the wall tile
       andi a,240*256                  ; AND 240           ; 
       movb a,@willy_y                 ; LD (32872),A      ; }
       .call @_35714                   ; CALL 35714        ; Adjust Willy's attribute buffer location at #R32876 to
                                                           ; account for this new y-coordinate
       movb @bytes+2,a                 ; LD A,2            ; {Set the airborne status indicator at #R32875 to #b2:
       movb a,@airborne                ; LD (32875),A      ; Willy has started falling}
       li   hl,dmflags                 ; LD HL,32874       ; {Reset bit 1 at #R32874: Willy is not moving left or
       szcb @bits+1,*hl                ; RES 1,(HL)        ; right}
       .ret                            ; RET               ; 

* Animate a crumbling floor tile in the current cavern
* 
* Used by the routine at #R35515.
* 
* HL Address of the crumbling floor tile's location in the attribute buffer at
* .  #R23552
crumble:                               ; 35770
       movb @l,@c                      ; LD C,L            ; {Point #REGbc at the bottom row of pixels of the
       movb h,a                        ; LD A,H            ; crumbling floor tile in the screen buffer at #R28672
       ab   @bytes+27,a                ; ADD A,27          ; 
       socb @bytes+7,a                 ; OR 7              ; 
       movb a,b                        ; LD B,A            ; }
_35777:
       sb   one,b                      ; DEC B             ; {Collect the pixels from the row above in #REGa
       movb *bc,a                      ; LD A,(BC)         ; }
       ab   one,b                      ; INC B             ; {Copy these pixels into the row below it
       movb a,*bc                      ; LD (BC),A         ; }
       sb   one,b                      ; DEC B             ; Point #REGbc at the next row of pixels up
       movb b,a                        ; LD A,B            ; {Have we dealt with the bottom seven pixel rows of the
       andi a,7*256                    ; AND 7             ; crumbling floor tile yet?}
       jne  _35777                     ; JR NZ,35777       ; If not, jump back to deal with the next one up
       sb   a,a                        ; XOR A             ; {Clear the top row of pixels in the crumbling floor tile
       movb a,*bc                      ; LD (BC),A         ; }
       movb b,a                        ; LD A,B            ; {Point #REGbc at the bottom row of pixels in the
       ab   @bytes+7,a                 ; ADD A,7           ; crumbling floor tile
       movb a,b                        ; LD B,A            ; }
       movb *bc,a                      ; LD A,(BC)         ; Pick up the bottom row of pixels in #REGa
       socb a,a                        ; OR A              ; Is the bottom row clear?
       jeq  !                          ; RET NZ            ; Return if not
       .ret                            ;                   
!
* The bottom row of pixels in the crumbling floor tile is clear. Time to put a
* background tile in its place.
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       ab   one,h                      ; INC H             ; {Set #REGhl to the address of the crumbling floor tile's
       ab   one,h                      ; INC H             ; location in the attribute buffer at #R24064}
       movb a,*hl                      ; LD (HL),A         ; Set the attribute at this location to that of the
                                                           ; background tile
       sb   one,h                      ; DEC H             ; {Set #REGhl back to the address of the crumbling floor
       sb   one,h                      ; DEC H             ; tile's location in the attribute buffer at #R23552}
       .ret                            ; RET               ; 

* Move Willy (2)
* 
* Used by the routine at #R35515. This routine checks the keyboard and
* joystick, and moves Willy left or right if necessary.
* 
* HL Attribute buffer address of the left-hand cell below Willy's sprite
movewilly2:                            ; 35805
       movb @airborne,a                ; LD A,(32875)      ; Pick up the airborne status indicator from #R32875
       cb   a,@bytes+12                ; CP 12             ; Has Willy just landed after falling from too great a
                                                           ; height?
       jl   !                          ; JP NC,36102       ; If so, kill him
       b    @_36102                    ;                   
!
       movb @b255,@e                   ; LD E,255          ; Initialise #REGe to #b255 (all bits set); it will be
                                                           ; used to hold keyboard and joystick readings
       sb   a,a                        ; XOR A             ; {Reset the airborne status indicator at #R32875 (Willy
       movb a,@airborne                ; LD (32875),A      ; has landed safely)}
       movb @conveyor,a                ; LD A,(32836)      ; Pick up the attribute byte of the conveyor tile for the
                                                           ; current cavern from #R32836
       cb   a,*hl                      ; CP (HL)           ; Does the attribute byte of the left-hand cell below
                                                           ; Willy's sprite match that of the conveyor tile?
       jeq  _35829                     ; JR Z,35829        ; Jump if so
       inc  hl                         ; INC HL            ; Point #REGhl at the right-hand cell below Willy's sprite
       cb   a,*hl                      ; CP (HL)           ; Does the attribute byte of the right-hand cell below
                                                           ; Willy's sprite match that of the conveyor tile?
       jne  _35835                     ; JR NZ,35835       ; Jump if not
_35829:
       movb @convdir,a                 ; LD A,(32879)      ; Pick up the direction byte of the conveyor definition
                                                           ; from #R32879 (0=left, 1=right)
       sb   @bytes+3,a                 ; SUB 3             ; {Now #REGe=#b253 (bit 1 reset) if the conveyor is moving
       movb a,@e                       ; LD E,A            ; left, or #b254 (bit 0 reset) if it's moving right}
_35835:
       li   bc,cavern11+1022           ; LD BC,57342       ; {Read keys P-O-I-U-Y (right, left, right, left, right)
       ; IN A,(C)                      ; IN A,(C)          ; into bits 0-4 of #REGa}
       andi a,31*256                   ; AND 31            ; {Set bit 5 and reset bits 6 and 7
       socb @bytes+32,a                ; OR 32             ; }
       ; AND E                         ; AND E             ; Reset bit 0 if the conveyor is moving right, or bit 1 if
                                                           ; it's moving left
       movb a,@e                       ; LD E,A            ; Save the result in #REGe
       li   bc,cavern18+1022           ; LD BC,64510       ; {Read keys Q-W-E-R-T (left, right, left, right, left)
       ; IN A,(C)                      ; IN A,(C)          ; into bits 0-4 of #REGa}
       andi a,31*256                   ; AND 31            ; {Keep only bits 0-4, shift them into bits 1-5, and set
       sla  a,1                        ; RLC A             ; TODO: check code. bit 0
       socb one,a                      ; OR 1              ; }
       ; AND E                         ; AND E             ; {Merge this keyboard reading into bits 1-5 of #REGe
       movb a,@e                       ; LD E,A            ; }
       movb @bytes+247,b               ; LD B,247          ; {Read keys 1-2-3-4-5 ('5' is left) into bits 0-4 of
       ; IN A,(C)                      ; IN A,(C)          ; #REGa}
       srl  a,1                        ; RRCA              ; TODO: check code. {Rotate the result right and set bits 0-2 and 4-7; this
       socb @bytes+247,a               ; OR 247            ; ignores every key except '5' (left)}
       ; AND E                         ; AND E             ; {Merge this reading of the '5' key into bit 3 of #REGe
       movb a,@e                       ; LD E,A            ; }
       movb @bytes+239,b               ; LD B,239          ; {Read keys 0-9-8-7-6 ('8' is right) into bits 0-4 of
       ; IN A,(C)                      ; IN A,(C)          ; #REGa}
       socb @bytes+251,a               ; OR 251            ; Set bits 0, 1 and 3-7; this ignores every key except '8'
                                                           ; (right)
       ; AND E                         ; AND E             ; {Merge this reading of the '8' key into bit 2 of #REGe
       movb a,@e                       ; LD E,A            ; }
       movb @kemp,a                    ; LD A,(33881)      ; Collect the Kempston joystick indicator from #R33881
       socb a,a                        ; OR A              ; Is the joystick connected?
       jeq  _35892                     ; JR Z,35892        ; Jump if not
       li   bc,31                      ; LD BC,31          ; {Collect input from the joystick
       ; IN A,(C)                      ; IN A,(C)          ; }
       andi a,3*256                    ; AND 3             ; {Keep only bits 0 (right) and 1 (left) and flip them
       inv  a                          ; CPL               ; }
       ; AND E                         ; AND E             ; {Merge this reading of the joystick right and left
       movb a,@e                       ; LD E,A            ; buttons into bits 0 and 1 of #REGe}
* At this point, bits 0-5 in #REGe indicate the direction in which Willy is
* being moved or trying to move. If bit 0, 2 or 4 is reset, Willy is being
* moved or trying to move right; if bit 1, 3 or 5 is reset, Willy is being
* moved or trying to move left.
_35892:
       sb   @c,@c                      ; LD C,0            ; Initialise #REGc to 0 (no movement)
       movb @e,a                       ; LD A,E            ; Copy the movement bits into #REGa
       andi a,42*256                   ; AND 42            ; Keep only bits 1, 3 and 5 (the 'left' bits)
       cb   a,@bytes+42                ; CP 42             ; Are any of these bits reset?
       jeq  _35903                     ; JR Z,35903        ; Jump if not
       movb @bytes+4,@c                ; LD C,4            ; Set bit 2 of #REGc: Willy is moving left
_35903:
       movb @e,a                       ; LD A,E            ; Copy the movement bits into #REGa
       andi a,21*256                   ; AND 21            ; Keep only bits 0, 2 and 4 (the 'right' bits)
       cb   a,@bytes+21                ; CP 21             ; Are any of these bits reset?
       jeq  _35912                     ; JR Z,35912        ; Jump if not
       socb @bits+3,@c                 ; SET 3,C           ; Set bit 3 of #REGc: Willy is moving right
_35912:
       movb @dmflags,a                 ; LD A,(32874)      ; Pick up Willy's direction and movement flags from
                                                           ; #R32874
       ab   @c,a                       ; ADD A,C           ; {Point #REGhl at the entry in the left-right movement
       movb a,@c                       ; LD C,A            ; table at #R33800 that corresponds to the direction Willy
       sb   b,b                        ; LD B,0            ; is facing, and the direction in which he is being moved
       li   hl,lrmovement              ; LD HL,33800       ; or trying to move
       a    bc,hl                      ; ADD HL,BC         ; }
       movb *hl,a                      ; LD A,(HL)         ; {Update Willy's direction and movement flags at #R32874
       movb a,@dmflags                 ; LD (32874),A      ; with the entry from the left-right movement table}
* That is left-right movement taken care of. Now check the jump keys.
       li   bc,scrn_buffer_1+3838      ; LD BC,32510       ; {Read keys SHIFT-Z-X-C-V and B-N-M-SS-SPACE
       ; IN A,(C)                      ; IN A,(C)          ; }
       andi a,31*256                   ; AND 31            ; {Are any of these keys being pressed?
       cb   a,@bytes+31                ; CP 31             ; }
       jne  _35963                     ; JR NZ,35963       ; Jump if so
       movb @bytes+239,b               ; LD B,239          ; {Read keys 0-9-8-7-6 into bits 0-4 of #REGa
       ; IN A,(C)                      ; IN A,(C)          ; }
       andi a,9*256                    ; AND 9             ; Keep only bits 0 (the '0' key) and 3 (the '7' key)
       cb   a,@bytes+9                 ; CP 9              ; Is '0' or '7' being pressed?
       jne  _35963                     ; JR NZ,35963       ; Jump if so
       movb @kemp,a                    ; LD A,(33881)      ; Collect the Kempston joystick indicator from #R33881
       socb a,a                        ; OR A              ; Is the joystick connected?
       jeq  _35971                     ; JR Z,35971        ; Jump if not
       li   bc,31                      ; LD BC,31          ; {Collect input from the joystick
       ; IN A,(C)                      ; IN A,(C)          ; }
       movb a,r0                       ; BIT 4,A           ; Is the fire button being pressed?
       andi r0,16*256                  ;                   
       jeq  _35971                     ; JR Z,35971        ; Jump if not
* A jump key or the fire button is being pressed. Time to make Willy jump.
_35963:
       sb   a,a                        ; XOR A             ; {Initialise the jumping animation counter at #R32878
       movb a,@jumping                 ; LD (32878),A      ; }
       ab   one,a                      ; INC A             ; {Set the airborne status indicator at #R32875 to 1:
       movb a,@airborne                ; LD (32875),A      ; Willy is jumping}
* This entry point is used by the routine at #R35515.
_35971:
       movb @dmflags,a                 ; LD A,(32874)      ; Pick up Willy's direction and movement flags from
                                                           ; #R32874
       andi a,2*256                    ; AND 2             ; Is Willy moving?
       jne  !                          ; RET Z             ; Return if not
       .ret                            ;                   
!
       movb @dmflags,a                 ; LD A,(32874)      ; Pick up Willy's direction and movement flags from
                                                           ; #R32874
       andi a,1*256                    ; AND 1             ; Is Willy facing right?
       jne  !                          ; JP Z,36042        ; Jump if so
       b    @_36042                    ;                   
!
* Willy is moving left.
       movb @frame,a                   ; LD A,(32873)      ; Pick up Willy's animation frame from #R32873
       socb a,a                        ; OR A              ; Is it 0?
       jeq  _35996                     ; JR Z,35996        ; If so, jump to move Willy's sprite left across a cell
                                                           ; boundary
       sb   one,a                      ; DEC A             ; {Decrement Willy's animation frame at #R32873
       movb a,@frame                   ; LD (32873),A      ; }
       .ret                            ; RET               ; 
* Willy's sprite is moving left across a cell boundary. In the comments that
* follow, (x,y) refers to the coordinates of the top-left cell currently
* occupied by Willy's sprite.
_35996:
       mov  @location,hl               ; LD HL,(32876)     ; Collect Willy's attribute buffer coordinates from
                                                           ; #R32876
       dec  hl                         ; DEC HL            ; {Point #REGhl at the cell at (x-1,y+1)
       li   de,32                      ; LD DE,32          ; 
       a    de,hl                      ; ADD HL,DE         ; }
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
       cb   a,*hl                      ; CP (HL)           ; Is there a wall tile in the cell pointed to by #REGhl?
       jne  !                          ; RET Z             ; Return if so without moving Willy (his path is blocked)
       .ret                            ;                   
!
       movb @willy_y,a                 ; LD A,(32872)      ; Pick up Willy's y-coordinate from #R32872
       andi a,15*256                   ; AND 15            ; Does Willy's sprite currently occupy only two rows of
                                                           ; cells?
       jeq  _36025                     ; JR Z,36025        ; Jump if so
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
       a    de,hl                      ; ADD HL,DE         ; Point #REGhl at the cell at (x-1,y+2)
       cb   a,*hl                      ; CP (HL)           ; Is there a wall tile in the cell pointed to by #REGhl?
       jne  !                          ; RET Z             ; Return if so without moving Willy (his path is blocked)
       .ret                            ;                   
!
       socb a,a                        ; OR A              ; Clear the carry flag for subtraction
       s    de,hl                      ; SBC HL,DE         ; Point #REGhl at the cell at (x-1,y+1)
_36025:
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
       socb a,a                        ; OR A              ; Clear the carry flag for subtraction
       s    de,hl                      ; SBC HL,DE         ; Point #REGhl at the cell at (x-1,y)
       cb   a,*hl                      ; CP (HL)           ; Is there a wall tile in the cell pointed to by #REGhl?
       jne  !                          ; RET Z             ; Return if so without moving Willy (his path is blocked)
       .ret                            ;                   
!
       mov  hl,@location               ; LD (32876),HL     ; Save Willy's new attribute buffer coordinates (in
                                                           ; #REGhl) at #R32876
       movb @bytes+3,a                 ; LD A,3            ; {Change Willy's animation frame at #R32873 from 0 to 3
       movb a,@frame                   ; LD (32873),A      ; }
       .ret                            ; RET               ; 
* Willy is moving right.
_36042:
       movb @frame,a                   ; LD A,(32873)      ; Pick up Willy's animation frame from #R32873
       cb   a,@bytes+3                 ; CP 3              ; Is it 3?
       jeq  _36054                     ; JR Z,36054        ; If so, jump to move Willy's sprite right across a cell
                                                           ; boundary
       ab   one,a                      ; INC A             ; {Increment Willy's animation frame at #R32873
       movb a,@frame                   ; LD (32873),A      ; }
       .ret                            ; RET               ; 
* Willy's sprite is moving right across a cell boundary. In the comments that
* follow, (x,y) refers to the coordinates of the top-left cell currently
* occupied by Willy's sprite.
_36054:
       mov  @location,hl               ; LD HL,(32876)     ; Collect Willy's attribute buffer coordinates from
                                                           ; #R32876
       inc  hl                         ; INC HL            ; {Point #REGhl at the cell at (x+2,y)
       inc  hl                         ; INC HL            ; }
       li   de,32                      ; LD DE,32          ; Prepare #REGde for addition
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
       a    de,hl                      ; ADD HL,DE         ; Point #REGhl at the cell at (x+2,y+1)
       cb   a,*hl                      ; CP (HL)           ; Is there a wall tile in the cell pointed to by #REGhl?
       jne  !                          ; RET Z             ; Return if so without moving Willy (his path is blocked)
       .ret                            ;                   
!
       movb @willy_y,a                 ; LD A,(32872)      ; Pick up Willy's y-coordinate from #R32872
       andi a,15*256                   ; AND 15            ; Does Willy's sprite currently occupy only two rows of
                                                           ; cells?
       jeq  _36084                     ; JR Z,36084        ; Jump if so
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
       a    de,hl                      ; ADD HL,DE         ; Point #REGhl at the cell at (x+2,y+2)
       cb   a,*hl                      ; CP (HL)           ; Is there a wall tile in the cell pointed to by #REGhl?
       jne  !                          ; RET Z             ; Return if so without moving Willy (his path is blocked)
       .ret                            ;                   
!
       socb a,a                        ; OR A              ; Clear the carry flag for subtraction
       s    de,hl                      ; SBC HL,DE         ; Point #REGhl at the cell at (x+2,y+1)
_36084:
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
       socb a,a                        ; OR A              ; Clear the carry flag for subtraction
       s    de,hl                      ; SBC HL,DE         ; Point #REGhl at the cell at (x+2,y)
       cb   a,*hl                      ; CP (HL)           ; Is there a wall tile in the cell pointed to by #REGhl?
       jne  !                          ; RET Z             ; Return if so without moving Willy (his path is blocked)
       .ret                            ;                   
!
       dec  hl                         ; DEC HL            ; Point #REGhl at the cell at (x+1,y)
       mov  hl,@location               ; LD (32876),HL     ; Save Willy's new attribute buffer coordinates (in
                                                           ; #REGhl) at #R32876
       sb   a,a                        ; XOR A             ; {Change Willy's animation frame at #R32873 from 3 to 0
       movb a,@frame                   ; LD (32873),A      ; }
       .ret                            ; RET               ; 

* Kill Willy
* 
* Used by the routine at #R37471 when Willy hits a nasty.
killwilly:                             ; 36101
       .pop hl                         ; POP HL            ; Drop the return address from the stack
* This entry point is used by the routines at #R35805 (when Willy lands after
* falling from too great a height), #R36266 (when Willy collides with a
* horizontal guardian), #R36344 (when Willy collides with Eugene), #R36593
* (when Willy collides with a vertical guardian) and #R37173 (when Willy
* collides with the Kong Beast).
_36102:
       .pop hl                         ; POP HL            ; Drop the return address from the stack
* This entry point is used by the routine at #R36469 when a Skylab falls on
* Willy.
_36103:
       movb @b255,a                    ; LD A,255          ; {Set the airborne status indicator at #R32875 to #b255
       movb a,@airborne                ; LD (32875),A      ; (meaning Willy has had a fatal accident)}
       b    @_34722                    ; JP 34722          ; Jump back into the main loop

* Move the horizontal guardians in the current cavern
* 
* Used by the routine at #R34574.
movehg:                                ; 36111
       li   iy,hguards                 ; LD IY,32958       ; Point #REGiy at the first byte of the first horizontal
                                                           ; guardian definition at #R32958
       li   de,7                       ; LD DE,7           ; Prepare #REGde for addition (there are 7 bytes in a
                                                           ; guardian definition)
* The guardian-moving loop begins here.
_36118:
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the first byte of the guardian definition
       cb   a,@b255                    ; CP 255            ; Have we dealt with all the guardians yet?
       jne  !                          ; RET Z             ; Return if so
       .ret                            ;                   
!
       socb a,a                        ; OR A              ; Is this guardian definition blank?
       jeq  _36207                     ; JR Z,36207        ; If so, skip it and consider the next one
       movb @clock,a                   ; LD A,(32957)      ; Pick up the value of the game clock at #R32957
       andi a,4*256                    ; AND 4             ; {Move bit 2 (which is toggled on each pass through the
       srl  a,1                        ; RRCA              ; TODO: check code. main loop) to bit 7 and clear all the other bits
       srl  a,1                        ; RRCA              ; TODO: check code. 
       srl  a,1                        ; RRCA              ; TODO: check code. }
       ; AND (IY+0)                    ; AND (IY+0)        ; Combine this bit with bit 7 of the first byte of the
                                                           ; guardian definition, which specifies the guardian's
                                                           ; animation speed: 0=normal, 1=slow
       jne  _36207                     ; JR NZ,36207       ; Jump to consider the next guardian if this one is not
                                                           ; due to be moved on this pass
* The guardian will be moved on this pass.
       movb @4(iy),a                   ; LD A,(IY+4)       ; Pick up the current animation frame (0-7)
       cb   a,@bytes+3                 ; CP 3              ; Is it 3 (the terminal frame for a guardian moving
                                                           ; right)?
       jeq  _36163                     ; JR Z,36163        ; Jump if so to move the guardian right across a cell
                                                           ; boundary or turn it round
       cb   a,@bytes+4                 ; CP 4              ; Is the current animation frame 4 (the terminal frame for
                                                           ; a guardian moving left)?
       jeq  _36186                     ; JR Z,36186        ; Jump if so to move the guardian left across a cell
                                                           ; boundary or turn it round
       jnc  _36158                     ; JR NC,36158       ; TODO: check code. Jump if the animation frame is 5, 6 or 7
       ab   one,@4(iy)                 ; INC (IY+4)        ; Increment the animation frame (this guardian is moving
                                                           ; right)
       jmp  _36207                     ; JR 36207          ; Jump forward to consider the next guardian
_36158:
       sb   one,@4(iy)                 ; DEC (IY+4)        ; Decrement the animation frame (this guardian is moving
                                                           ; left)
       jmp  _36207                     ; JR 36207          ; Jump forward to consider the next guardian
_36163:
       movb @1(iy),a                   ; LD A,(IY+1)       ; Pick up the LSB of the address of the guardian's
                                                           ; location in the attribute buffer at #R23552
       cb   a,@6(iy)                   ; CP (IY+6)         ; Has the guardian reached the rightmost point in its
                                                           ; path?
       jne  _36177                     ; JR NZ,36177       ; Jump if not
       movb @bytes+7,@4(iy)            ; LD (IY+4),7       ; Set the animation frame to 7 (turning the guardian round
                                                           ; to face left)
       jmp  _36207                     ; JR 36207          ; Jump forward to consider the next guardian
_36177:
       sb   @4(iy),@4(iy)              ; LD (IY+4),0       ; Set the animation frame to 0 (the initial frame for a
                                                           ; guardian moving right)
       ab   one,@1(iy)                 ; INC (IY+1)        ; Increment the guardian's x-coordinate (moving it right
                                                           ; across a cell boundary)
       jmp  _36207                     ; JR 36207          ; Jump forward to consider the next guardian
_36186:
       movb @1(iy),a                   ; LD A,(IY+1)       ; Pick up the LSB of the address of the guardian's
                                                           ; location in the attribute buffer at #R23552
       cb   a,@5(iy)                   ; CP (IY+5)         ; Has the guardian reached the leftmost point in its path?
       jne  _36200                     ; JR NZ,36200       ; Jump if not
       sb   @4(iy),@4(iy)              ; LD (IY+4),0       ; Set the animation frame to 0 (turning the guardian round
                                                           ; to face right)
       jmp  _36207                     ; JR 36207          ; Jump forward to consider the next guardian
_36200:
       movb @bytes+7,@4(iy)            ; LD (IY+4),7       ; Set the animation frame to 7 (the initial frame for a
                                                           ; guardian moving left)
       sb   one,@1(iy)                 ; DEC (IY+1)        ; Decrement the guardian's x-coordinate (moving it left
                                                           ; across a cell boundary)
* The current guardian definition has been dealt with. Time for the next one.
_36207:
       a    de,iy                      ; ADD IY,DE         ; Point #REGiy at the first byte of the next horizontal
                                                           ; guardian definition
       jmp  _36118                     ; JR 36118          ; Jump back to deal with the next horizontal guardian

* Move and draw the light beam in Solar Power Generator
* 
* Used by the routine at #R34574.
lightbeam:                             ; 36211
       li   hl,attr_buffer_2+23        ; LD HL,23575       ; Point #REGhl at the cell at (0,23) in the attribute
                                                           ; buffer at #R23552 (the source of the light beam)
       li   de,32                      ; LD DE,32          ; Prepare #REGde for addition (the beam travels vertically
                                                           ; downwards to start with)
* The beam-drawing loop begins here.
_36217:
       movb @floor,a                   ; LD A,(32809)      ; Pick up the attribute byte of the floor tile for the
                                                           ; cavern from #R32809
       cb   a,*hl                      ; CP (HL)           ; Does #REGhl point at a floor tile?
       jne  !                          ; RET Z             ; Return if so (the light beam stops here)
       .ret                            ;                   
!
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; cavern from #R32827
       cb   a,*hl                      ; CP (HL)           ; Does #REGhl point at a wall tile?
       jne  !                          ; RET Z             ; Return if so (the light beam stops here)
       .ret                            ;                   
!
       movb @bytes+39,a                ; LD A,39           ; #REGa=#b39 (INK 7: PAPER 4)
       cb   a,*hl                      ; CP (HL)           ; Does #REGhl point at a tile with this attribute value?
       jne  _36248                     ; JR NZ,36248       ; Jump if not (the light beam is not touching Willy)
       .exx                            ; EXX               ; Switch to the shadow registers briefly (to preserve
                                                           ; #REGde and #REGhl)
       .call @decair                   ; CALL 35388        ; {Decrease the air supply by four units
       .call @decair                   ; CALL 35388        ; 
       .call @decair                   ; CALL 35388        ; 
       .call @decair                   ; CALL 35388        ; }
       .exx                            ; EXX               ; Switch back to the normal registers (restoring #REGde
                                                           ; and #REGhl)
       jmp  _36261                     ; JR 36261          ; Jump forward to draw the light beam over Willy
_36248:
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the cavern from #R32800
       cb   a,*hl                      ; CP (HL)           ; Does #REGhl point at a background tile?
       jeq  _36261                     ; JR Z,36261        ; Jump if so (the light beam will not be reflected at this
                                                           ; point)
       movb @e,a                       ; LD A,E            ; {Toggle the value in #REGde between 32 and -1 (and
       li   r0,223*256                 ; XOR 223           ; therefore the direction of the light beam between
       xor  r0,a                       ;                   
       movb a,@e                       ; LD E,A            ; vertically downwards and horizontally to the left): the
       movb d,a                        ; LD A,D            ; light beam has hit a guardian
       inv  a                          ; CPL               ; 
       movb a,d                        ; LD D,A            ; }
_36261:
       movb @bytes+119,*hl             ; LD (HL),119       ; Draw a portion of the light beam with attribute value
                                                           ; #b119 (INK 7: PAPER 6: BRIGHT 1)
       a    de,hl                      ; ADD HL,DE         ; Point #REGhl at the cell where the next portion of the
                                                           ; light beam will be drawn
       jmp  _36217                     ; JR 36217          ; Jump back to draw the next portion of the light beam

* Draw the horizontal guardians in the current cavern
* 
* Used by the routine at #R34574.
drawhg:                                ; 36266
       li   iy,hguards                 ; LD IY,32958       ; Point #REGiy at the first byte of the first horizontal
                                                           ; guardian definition at #R32958
* The guardian-drawing loop begins here.
_36270:
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the first byte of the guardian definition
       cb   a,@b255                    ; CP 255            ; Have we dealt with all the guardians yet?
       jne  !                          ; RET Z             ; Return if so
       .ret                            ;                   
!
       socb a,a                        ; OR A              ; Is this guardian definition blank?
       jeq  _36337                     ; JR Z,36337        ; If so, skip it and consider the next one
       li   de,31                      ; LD DE,31          ; Prepare #REGde for addition
       movb @1(iy),@l                  ; LD L,(IY+1)       ; {Point #REGhl at the address of the guardian's location
       movb @2(iy),h                   ; LD H,(IY+2)       ; in the attribute buffer at #R23552}
       andi a,127*256                  ; AND 127           ; Reset bit 7 (which specifies the animation speed) of the
                                                           ; attribute byte, ensuring no FLASH
       movb a,*hl                      ; LD (HL),A         ; {Set the attribute bytes for the guardian in the buffer
       inc  hl                         ; INC HL            ; at #R23552
       movb a,*hl                      ; LD (HL),A         ; 
       a    de,hl                      ; ADD HL,DE         ; 
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       movb a,*hl                      ; LD (HL),A         ; }
       movb one,@c                     ; LD C,1            ; Prepare #REGc for the call to the drawing routine at
                                                           ; #R36852 later on
       movb @4(iy),a                   ; LD A,(IY+4)       ; Pick up the animation frame (0-7)
       srl  a,1                        ; RRCA              ; TODO: check code. {Multiply it by 32
       srl  a,1                        ; RRCA              ; TODO: check code. 
       srl  a,1                        ; RRCA              ; TODO: check code. }
       movb a,@e                       ; LD E,A            ; Copy the result to #REGe
       movb @sheet,a                   ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   a,@bytes+7                 ; CP 7              ; Are we in one of the first seven caverns?
       jl   _36323                     ; JR C,36323        ; Jump if so
       cb   a,@bytes+9                 ; CP 9              ; Are we in #R54272(The Endorian Forest)?
       jeq  _36323                     ; JR Z,36323        ; Jump if so
       cb   a,@bytes+15                ; CP 15             ; Are we in #R60416(The Sixteenth Cavern)?
       jeq  _36323                     ; JR Z,36323        ; Jump if so
       socb @bits+7,@e                 ; SET 7,E           ; Add #b128 to #REGe (the horizontal guardians in this
                                                           ; cavern use frames 4-7 only)
_36323:
       movb @bytes+129,d               ; LD D,129          ; Point #REGde at the graphic data for the appropriate
                                                           ; guardian sprite (at #R33024+#REGe)
       movb @1(iy),@l                  ; LD L,(IY+1)       ; {Point #REGhl at the address of the guardian's location
       movb @3(iy),h                   ; LD H,(IY+3)       ; in the screen buffer at #R24576}
       .call @drwfix                   ; CALL 36852        ; Draw the guardian to the screen buffer at #R24576
       jeq  !                          ; JP NZ,36102       ; Kill Willy if the guardian collided with him
       b    @_36102                    ;                   
!
* The current guardian definition has been dealt with. Time for the next one.
_36337:
       equ  $
       li   de,7                       ; LD DE,7           ; {Point #REGiy at the first byte of the next horizontal
       a    de,iy                      ; ADD IY,DE         ; guardian definition}
       jmp  _36270                     ; JR 36270          ; Jump back to deal with the next horizontal guardian

* Move and draw Eugene in Eugene's Lair
* 
* Used by the routine at #R34574. First we move Eugene up or down, or change
* his direction.
eugene:                                ; 36344
       movb @itemattr,a                ; LD A,(32884)      ; Pick up the attribute of the last item drawn from
                                                           ; #R32884
       socb a,a                        ; OR A              ; Have all the items been collected?
       jeq  _36367                     ; JR Z,36367        ; Jump if so
       movb @eugdir,a                  ; LD A,(32987)      ; Pick up Eugene's direction from #R32987
       socb a,a                        ; OR A              ; Is Eugene moving downwards?
       jeq  _36367                     ; JR Z,36367        ; Jump if so
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up Eugene's pixel y-coordinate from #R32988
       sb   one,a                      ; DEC A             ; Decrement it (moving Eugene up)
       jeq  _36380                     ; JR Z,36380        ; Jump if Eugene has reached the top of the cavern
       movb a,@eughgt                  ; LD (32988),A      ; Update Eugene's pixel y-coordinate at #R32988
       jmp  _36388                     ; JR 36388          ; 
_36367:
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up Eugene's pixel y-coordinate from #R32988
       ab   one,a                      ; INC A             ; Increment it (moving Eugene down)
       cb   a,@bytes+88                ; CP 88             ; Has Eugene reached the portal yet?
       jeq  _36380                     ; JR Z,36380        ; Jump if so
       movb a,@eughgt                  ; LD (32988),A      ; Update Eugene's pixel y-coordinate at #R32988
       jmp  _36388                     ; JR 36388          ; 
_36380:
       movb @eugdir,a                  ; LD A,(32987)      ; {Toggle Eugene's direction at #R32987
       xor  one,a                      ; XOR 1             ; 
       movb a,@eugdir                  ; LD (32987),A      ; }
* Now that Eugene's movement has been dealt with, it's time to draw him.
_36388:
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up Eugene's pixel y-coordinate from #R32988
       andi a,127*256                  ; AND 127           ; {Point #REGde at the entry in the screen buffer address
       sla  a,1                        ; RLCA              ; TODO: check code. lookup table at #R33536 that corresponds to Eugene's
       movb a,@e                       ; LD E,A            ; y-coordinate
       movb @sbufaddrs_msb_byte,d      ; LD D,131          ; }
       movb *de,a                      ; LD A,(DE)         ; {Point #REGhl at the address of Eugene's location in the
       socb @bytes+15,a                ; OR 15             ; screen buffer at #R24576
       movb a,@l                       ; LD L,A            ; 
       inc  de                         ; INC DE            ; 
       movb *de,a                      ; LD A,(DE)         ; 
       movb a,h                        ; LD H,A            ; }
       li   de,vguards+3               ; LD DE,32992       ; {Draw Eugene to the screen buffer at #R24576
       movb one,@c                     ; LD C,1            ; 
       .call @drwfix                   ; CALL 36852        ; }
       jeq  !                          ; JP NZ,36102       ; Kill Willy if Eugene collided with him
       b    @_36102                    ;                   
!
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up Eugene's pixel y-coordinate from #R32988
       andi a,120*256                  ; AND 120           ; {Point #REGhl at the address of Eugene's location in the
       sla  a,1                        ; RLCA              ; TODO: check code. attribute buffer at #R23552
       socb @bytes+7,a                 ; OR 7              ; 
       ; SCF                           ; SCF               ; 
       sla  a,1                        ; RL A              ; TODO: check code. 
       movb a,@l                       ; LD L,A            ; 
       sb   a,a                        ; LD A,0            ; 
       ab   @bytes+92,a                ; ADC A,92          ; 
       movb a,h                        ; LD H,A            ; }
       movb @itemattr,a                ; LD A,(32884)      ; Pick up the attribute of the last item drawn from
                                                           ; #R32884
       socb a,a                        ; OR A              ; Set the zero flag if all the items have been collected
       movb @bytes+7,a                 ; LD A,7            ; Assume we will draw Eugene with white INK
       jne  _36447                     ; JR NZ,36447       ; Jump if there are items remaining to be collected
       movb @clock,a                   ; LD A,(32957)      ; Pick up the value of the game clock at #R32957
       srl  a,1                        ; RRCA              ; TODO: check code. {Move bits 2-4 into bits 0-2 and clear the other bits;
       srl  a,1                        ; RRCA              ; TODO: check code. this value (which decreases by one on each pass through
       andi a,7*256                    ; AND 7             ; the main loop) will be Eugene's INK colour}
* This entry point is used by the routines at #R36469 (to set the attributes
* for a Skylab), #R36593 (to set the attributes for a vertical guardian) and
* #R37173 (to set the attributes for the Kong Beast).
_36447:
       movb a,*hl                      ; LD (HL),A         ; Save the INK colour in the attribute buffer temporarily
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       andi a,248*256                  ; AND 248           ; {Combine its PAPER colour with the chosen INK colour
       socb *hl,a                      ; OR (HL)           ; }
       movb a,*hl                      ; LD (HL),A         ; Set the attribute byte for the top-left cell of the
                                                           ; sprite in the attribute buffer at #R23552
       li   de,31                      ; LD DE,31          ; Prepare #REGde for addition
       inc  hl                         ; INC HL            ; {Set the attribute byte for the top-right cell of the
       movb a,*hl                      ; LD (HL),A         ; sprite in the attribute buffer at #R23552}
       a    de,hl                      ; ADD HL,DE         ; {Set the attribute byte for the middle-left cell of the
       movb a,*hl                      ; LD (HL),A         ; sprite in the attribute buffer at #R23552}
       inc  hl                         ; INC HL            ; {Set the attribute byte for the middle-right cell of the
       movb a,*hl                      ; LD (HL),A         ; sprite in the attribute buffer at #R23552}
       a    de,hl                      ; ADD HL,DE         ; {Set the attribute byte for the bottom-left cell of the
       movb a,*hl                      ; LD (HL),A         ; sprite in the attribute buffer at #R23552}
       inc  hl                         ; INC HL            ; {Set the attribute byte for the bottom-right cell of the
       movb a,*hl                      ; LD (HL),A         ; sprite in the attribute buffer at #R23552}
       .ret                            ; RET               ; 

* Move and draw the Skylabs in Skylab Landing Bay
* 
* Used by the routine at #R34574.
skylabs:                               ; 36469
       li   iy,vguards                 ; LD IY,32989       ; Point #REGiy at the first byte of the first vertical
                                                           ; guardian definition at #R32989
* The Skylab-moving loop begins here.
_36473:
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the first byte of the guardian definition
       cb   a,@b255                    ; CP 255            ; Have we dealt with all the Skylabs yet?
       jne  !                          ; JP Z,34719        ; If so, re-enter the main loop
       b    @_34719                    ;                   
!
       movb @2(iy),a                   ; LD A,(IY+2)       ; Pick up the Skylab's pixel y-coordinate
       cb   a,@6(iy)                   ; CP (IY+6)         ; Has it reached its crash site yet?
       jhe  _36497                     ; JR NC,36497       ; Jump if so
       ab   @4(iy),a                   ; ADD A,(IY+4)      ; {Increment the Skylab's y-coordinate (moving it
       movb a,@2(iy)                   ; LD (IY+2),A       ; downwards)}
       jmp  _36527                     ; JR 36527          ; 
* The Skylab has reached its crash site. Start or continue its disintegration.
_36497:
       ab   one,@1(iy)                 ; INC (IY+1)        ; Increment the animation frame
       movb @1(iy),a                   ; LD A,(IY+1)       ; Pick up the animation frame
       cb   a,@bytes+8                 ; CP 8              ; Has the Skylab completely disintegrated yet?
       jne  _36527                     ; JR NZ,36527       ; Jump if not
       movb @5(iy),a                   ; LD A,(IY+5)       ; {Reset the Skylab's pixel y-coordinate
       movb a,@2(iy)                   ; LD (IY+2),A       ; }
       movb @3(iy),a                   ; LD A,(IY+3)       ; {Add 8 to the Skylab's x-coordinate (wrapping around at
       ab   @bytes+8,a                 ; ADD A,8           ; the right side of the screen)
       andi a,31*256                   ; AND 31            ; 
       movb a,@3(iy)                   ; LD (IY+3),A       ; }
       sb   @1(iy),@1(iy)              ; LD (IY+1),0       ; Reset the animation frame to 0
* Now that the Skylab's movement has been dealt with, time to draw it.
_36527:
       movb @2(iy),@e                  ; LD E,(IY+2)       ; Pick up the Skylab's pixel y-coordinate in #REGe
       ; RLC E                         ; RLC E             ; {Point #REGde at the entry in the screen buffer address
       movb @sbufaddrs_msb_byte,d      ; LD D,131          ; lookup table at #R33536 that corresponds to the Skylab's
                                                           ; pixel y-coordinate}
       movb *de,a                      ; LD A,(DE)         ; {Point #REGhl at the address of the Skylab's location in
       ab   @3(iy),a                   ; ADD A,(IY+3)      ; the screen buffer at #R24576
       movb a,@l                       ; LD L,A            ; 
       inc  de                         ; INC DE            ; 
       movb *de,a                      ; LD A,(DE)         ; 
       movb a,h                        ; LD H,A            ; }
       movb @1(iy),a                   ; LD A,(IY+1)       ; Pick up the animation frame (0-7)
       srl  a,1                        ; RRCA              ; TODO: check code. {Multiply it by 32
       srl  a,1                        ; RRCA              ; TODO: check code. 
       srl  a,1                        ; RRCA              ; TODO: check code. }
       movb a,@e                       ; LD E,A            ; {Point #REGde at the graphic data for the corresponding
       movb @bytes+129,d               ; LD D,129          ; Skylab sprite (at #R33024+#REGa)}
       movb one,@c                     ; LD C,1            ; {Draw the Skylab to the screen buffer at #R24576
       .call @drwfix                   ; CALL 36852        ; }
       jeq  !                          ; JP NZ,36103       ; Kill Willy if the Skylab collided with him
       b    @_36103                    ;                   
!
       movb @2(iy),a                   ; LD A,(IY+2)       ; {Point #REGhl at the address of the Skylab's location in
       andi a,64*256                   ; AND 64            ; the attribute buffer at #R23552
       sla  a,1                        ; RLCA              ; TODO: check code. 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       ab   @bytes+92,a                ; ADD A,92          ; 
       movb a,h                        ; LD H,A            ; 
       movb @2(iy),a                   ; LD A,(IY+2)       ; 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       andi a,224*256                  ; AND 224           ; 
       socb @3(iy),a                   ; OR (IY+3)         ; 
       movb a,@l                       ; LD L,A            ; }
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the Skylab's attribute byte
       .call @_36447                   ; CALL 36447        ; Set the attribute bytes for the Skylab
* The current guardian definition has been dealt with. Time for the next one.
       li   de,7                       ; LD DE,7           ; {Point #REGiy at the first byte of the next vertical
       a    de,iy                      ; ADD IY,DE         ; guardian definition}
       jmp  _36473                     ; JR 36473          ; Jump back to deal with the next Skylab

* Move and draw the vertical guardians in the current cavern
* 
* Used by the routine at #R34574.
vguardians:                            ; 36593
       li   iy,vguards                 ; LD IY,32989       ; Point #REGiy at the first byte of the first vertical
                                                           ; guardian definition at #R32989
* The guardian-moving loop begins here.
_36597:
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the first byte of the guardian definition
       cb   a,@b255                    ; CP 255            ; Have we dealt with all the guardians yet?
       jne  !                          ; RET Z             ; Return if so
       .ret                            ;                   
!
       ab   one,@1(iy)                 ; INC (IY+1)        ; Increment the guardian's animation frame
       szcb @bits+2,@1(iy)             ; RES 2,(IY+1)      ; Reset the animation frame to 0 if it overflowed to 4
       movb @2(iy),a                   ; LD A,(IY+2)       ; Pick up the guardian's pixel y-coordinate
       ab   @4(iy),a                   ; ADD A,(IY+4)      ; Add the current y-coordinate increment
       cb   a,@5(iy)                   ; CP (IY+5)         ; Has the guardian reached the highest point of its path
                                                           ; (minimum y-coordinate)?
       jl   _36631                     ; JR C,36631        ; If so, jump to change its direction of movement
       cb   a,@6(iy)                   ; CP (IY+6)         ; Has the guardian reached the lowest point of its path
                                                           ; (maximum y-coordinate)?
       jhe  _36631                     ; JR NC,36631       ; If so, jump to change its direction of movement
       movb a,@2(iy)                   ; LD (IY+2),A       ; Update the guardian's pixel y-coordinate
       jmp  _36639                     ; JR 36639          ; 
_36631:
       movb @4(iy),a                   ; LD A,(IY+4)       ; {Negate the y-coordinate increment; this changes the
       neg a                           ; NEG               ; guardian's direction of movement
       movb a,@4(iy)                   ; LD (IY+4),A       ; }
* Now that the guardian's movement has been dealt with, time to draw it.
_36639:
       movb @2(iy),a                   ; LD A,(IY+2)       ; Pick up the guardian's pixel y-coordinate
       andi a,127*256                  ; AND 127           ; {Point #REGde at the entry in the screen buffer address
       sla  a,1                        ; RLCA              ; TODO: check code. lookup table at #R33536 that corresponds to the
       movb a,@e                       ; LD E,A            ; guardian's pixel y-coordinate
       movb @sbufaddrs_msb_byte,d      ; LD D,131          ; }
       movb *de,a                      ; LD A,(DE)         ; {Point #REGhl at the address of the guardian's location
       socb @3(iy),a                   ; OR (IY+3)         ; in the screen buffer at #R24576
       movb a,@l                       ; LD L,A            ; 
       inc  de                         ; INC DE            ; 
       movb *de,a                      ; LD A,(DE)         ; 
       movb a,h                        ; LD H,A            ; }
       movb @1(iy),a                   ; LD A,(IY+1)       ; Pick up the guardian's animation frame (0-3)
       srl  a,1                        ; RRCA              ; TODO: check code. {Multiply it by 32
       srl  a,1                        ; RRCA              ; TODO: check code. 
       srl  a,1                        ; RRCA              ; TODO: check code. }
       movb a,@e                       ; LD E,A            ; {Point #REGde at the graphic data for the appropriate
       movb @bytes+129,d               ; LD D,129          ; guardian sprite (at #R33024+#REGa)}
       movb one,@c                     ; LD C,1            ; {Draw the guardian to the screen buffer at #R24576
       .call @drwfix                   ; CALL 36852        ; }
       jeq  !                          ; JP NZ,36102       ; Kill Willy if the guardian collided with him
       b    @_36102                    ;                   
!
       movb @2(iy),a                   ; LD A,(IY+2)       ; Pick up the guardian's pixel y-coordinate
       andi a,64*256                   ; AND 64            ; {Point #REGhl at the address of the guardian's location
       sla  a,1                        ; RLCA              ; TODO: check code. in the attribute buffer at #R23552
       sla  a,1                        ; RLCA              ; TODO: check code. 
       ab   @bytes+92,a                ; ADD A,92          ; 
       movb a,h                        ; LD H,A            ; 
       movb @2(iy),a                   ; LD A,(IY+2)       ; 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       andi a,224*256                  ; AND 224           ; 
       socb @3(iy),a                   ; OR (IY+3)         ; 
       movb a,@l                       ; LD L,A            ; }
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the guardian's attribute byte
       .call @_36447                   ; CALL 36447        ; Set the attribute bytes for the guardian
* The current guardian definition has been dealt with. Time for the next one.
       li   de,7                       ; LD DE,7           ; {Point #REGiy at the first byte of the next vertical
       a    de,iy                      ; ADD IY,DE         ; guardian definition}
       jmp  _36597                     ; JR 36597          ; Jump back to deal with the next vertical guardian

* Draw the items in the current cavern and collect any that Willy is touching
* 
* Used by the routine at #R34574.
drawitems:                             ; 36707
       sb   a,a                        ; XOR A             ; {Initialise the attribute of the last item drawn at
       movb a,@itemattr                ; LD (32884),A      ; #R32884 to #b0 (in case there are no items left to draw)
                                                           ; }
       li   iy,items                   ; LD IY,32885       ; Point #REGiy at the first byte of the first item
                                                           ; definition at #R32885
* The item-drawing loop begins here.
_36715:
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the first byte of the item definition
       cb   a,@b255                    ; CP 255            ; Have we dealt with all the items yet?
       jeq  _36794                     ; JR Z,36794        ; Jump if so
       socb a,a                        ; OR A              ; Has this item already been collected?
       jeq  _36782                     ; JR Z,36782        ; If so, skip it and consider the next one
       movb @1(iy),@e                  ; LD E,(IY+1)       ; {Point #REGde at the address of the item's location in
       movb @2(iy),d                   ; LD D,(IY+2)       ; the attribute buffer at #R23552}
       movb *de,a                      ; LD A,(DE)         ; Pick up the current attribute byte at the item's
                                                           ; location
       andi a,7*256                    ; AND 7             ; {Is the INK white (which happens if Willy is touching
       cb   a,@bytes+7                 ; CP 7              ; the item)?}
       jne  _36750                     ; JR NZ,36750       ; Jump if not
* Willy is touching this item, so add it to his collection.
       li   hl,scorbuf+3               ; LD HL,33836       ; {Add 100 to the score
       .call @_37118                   ; CALL 37118        ; }
       sb   *iy,*iy                    ; LD (IY+0),0       ; Set the item's attribute byte to #b0 so that it will be
                                                           ; skipped the next time
       jmp  _36782                     ; JR 36782          ; Jump forward to consider the next item
* This item has not been collected yet.
_36750:
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the item's current attribute byte
       andi a,248*256                  ; AND 248           ; {Keep the BRIGHT and PAPER bits, and set the INK to 3
       socb @bytes+3,a                 ; OR 3              ; (magenta)}
       movb a,b                        ; LD B,A            ; Store this value in #REGb
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the item's current attribute byte again
       andi a,3*256                    ; AND 3             ; {Keep only bits 0 and 1 and add the value in #REGb; this
       ab   b,a                        ; ADD A,B           ; maintains the BRIGHT and PAPER bits, and cycles the INK
                                                           ; colour through 3, 4, 5 and 6}
       movb a,*iy                      ; LD (IY+0),A       ; Store the new attribute byte
       movb a,*de                      ; LD (DE),A         ; Update the attribute byte at the item's location in the
                                                           ; buffer at #R23552
       movb a,@itemattr                ; LD (32884),A      ; Store the new attribute byte at #R32884 as well
       movb @3(iy),d                   ; LD D,(IY+3)       ; Point #REGde at the address of the item's location in
                                                           ; the screen buffer at #R24576
       li   hl,item                    ; LD HL,32948       ; Point #REGhl at the item graphic for the current cavern
                                                           ; (at #R32948)
       movb @bytes+8,b                 ; LD B,8            ; There are eight pixel rows to copy
       .call @_37589                   ; CALL 37589        ; Draw the item to the screen buffer at #R24576
* The current item definition has been dealt with. Time for the next one.
_36782:
       inc  iy                         ; INC IY            ; {Point #REGiy at the first byte of the next item
       inc  iy                         ; INC IY            ; definition
       inc  iy                         ; INC IY            ; 
       inc  iy                         ; INC IY            ; 
       inc  iy                         ; INC IY            ; }
       jmp  _36715                     ; JR 36715          ; Jump back to deal with the next item
* All the items have been dealt with. Check whether there were any left.
_36794:
       movb @itemattr,a                ; LD A,(32884)      ; Pick up the attribute of the last item drawn at #R32884
       socb a,a                        ; OR A              ; Were any items drawn?
       jeq  !                          ; RET NZ            ; Return if so (some remain to be collected)
       .ret                            ;                   
!
       li   hl,portal                  ; LD HL,32911       ; {Ensure that the portal is flashing by setting bit 7 of
       socb @bits+7,*hl                ; SET 7,(HL)        ; its attribute byte at #R32911}
       .ret                            ; RET               ; 

* Draw the portal, or move to the next cavern if Willy has entered it
* 
* Used by the routine at #R34574. First check whether Willy has entered the
* portal.
chkportal:                             ; 36805
       mov  @portalloc1,hl             ; LD HL,(32944)     ; Pick up the address of the portal's location in the
                                                           ; attribute buffer at #R23552 from #R32944
       movb @location,a                ; LD A,(32876)      ; Pick up the LSB of the address of Willy's location in
                                                           ; the attribute buffer at #R23552 from #R32876
       cb   a,@l                       ; CP L              ; Does it match that of the portal?
       jne  _36831                     ; JR NZ,36831       ; Jump if not
       movb @location+1,a              ; LD A,(32877)      ; Pick up the MSB of the address of Willy's location in
                                                           ; the attribute buffer at #R23552 from #R32876(#N32877)
       cb   a,h                        ; CP H              ; Does it match that of the portal?
       jne  _36831                     ; JR NZ,36831       ; Jump if not
       movb @portal,a                  ; LD A,(32911)      ; Pick up the portal's attribute byte from #R32911
       movb a,r0                       ; BIT 7,A           ; Is the portal flashing?
       andi r0,128*256                 ;                   
       jeq  _36831                     ; JR Z,36831        ; Jump if not
       .pop hl                         ; POP HL            ; Drop the return address from the stack
       b    @nxsheet                   ; JP 36904          ; Move Willy to the next cavern
* Willy has not entered the portal, or it's not flashing, so just draw it.
_36831:
       movb @portal,a                  ; LD A,(32911)      ; Pick up the portal's attribute byte from #R32911
       movb a,*hl                      ; LD (HL),A         ; {Set the attribute bytes for the portal in the buffer at
       inc  hl                         ; INC HL            ; #R23552
       movb a,*hl                      ; LD (HL),A         ; 
       li   de,31                      ; LD DE,31          ; 
       a    de,hl                      ; ADD HL,DE         ; 
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       movb a,*hl                      ; LD (HL),A         ; }
       li   de,portalg                 ; LD DE,32912       ; Point #REGde at the graphic data for the portal at
                                                           ; #R32912
       mov  @portalloc2,hl             ; LD HL,(32946)     ; Pick up the address of the portal's location in the
                                                           ; screen buffer at #R24576 from #R32946
       sb   @c,@c                      ; LD C,0            ; #REGc=0: overwrite mode
* This routine continues into the one at #R36852.

* Draw a sprite
* 
* Used by the routines at #R34252 (to draw Willy on the title screen), #R34574
* (to draw the remaining lives), #R35140 (to draw Willy, the boot and the
* plinth during the game over sequence), #R36266 (to draw horizontal
* guardians), #R36344 (to draw Eugene in #R49152(Eugene's Lair)), #R36469 (to
* draw the Skylabs in #R58368(Skylab Landing Bay)), #R36593 (to draw vertical
* guardians), #R36805 (to draw the portal in the current cavern), #R36904 (to
* draw Willy above ground and the swordfish graphic over the portal in
* #R64512(The Final Barrier)) and #R37173 (to draw the Kong Beast in
* #R52224(Miner Willy meets the Kong Beast) and #R56320(Return of the Alien
* Kong Beast)). If #REGc=1 on entry, this routine returns with the zero flag
* reset if any of the set bits in the sprite being drawn collides with a set
* bit in the background.
* 
* C Drawing mode: 0 (overwrite) or 1 (blend)
* DE Address of sprite graphic data
* HL Address to draw at
drwfix:                                ; 36852
       movb @bytes+16,b                ; LD B,16           ; There are 16 rows of pixels to draw
_36854:
       movb *de,a                      ; LD A,(DE)         ; Pick up a sprite graphic byte
       movb @c,r0                      ; BIT 0,C           ; Set the zero flag if we're in overwrite mode
;       andi r0,1*256                   ;
;       movb *de,a                      ; LD A,(DE)         ; Pick up a sprite graphic byte
       jeq  _36863                     ; JR Z,36863        ; Jump if we're in overwrite mode
       movb *hl,r0
       inv  r0
       szcb  r0,a                      ; AND (HL)          ; {Return with the zero flag reset if any of the set bits
       jeq  !                          ; RET NZ            ; in the sprite graphic byte collide with a set bit in the
       .ret                            ;                   
!
                                                           ; background (e.g. in Willy's sprite)}
       movb *de,a                      ; LD A,(DE)         ; Pick up the sprite graphic byte again
       socb *hl,a                      ; OR (HL)           ; Blend it with the background byte
_36863:
       movb a,*hl                      ; LD (HL),A         ; Copy the graphic byte to its destination cell
       ab   one,@l                     ; INC L             ; Move #REGhl along to the next cell on the right
       inc  de                         ; INC DE            ; Point #REGde at the next sprite graphic byte
       movb *de,a                      ; LD A,(DE)         ; Pick up a sprite graphic byte
       movb @c,r0                      ; BIT 0,C           ; Set the zero flag if we're in overwrite mode
;      andi r0,1*256                   ;
;       movb *de,a                      ; LD A,(DE)         ; Pick up a sprite graphic byte
       jeq  _36875                     ; JR Z,36875        ; Jump if we're in overwrite mode
       movb *hl,r0
       inv  r0
       szcb  r0,a                      ; AND (HL)          ; {Return with the zero flag reset if any of the set bits
       jeq  !                          ; RET NZ            ; in the sprite graphic byte collide with a set bit in the
       .ret                            ;                   
!
                                                           ; background (e.g. in Willy's sprite)}
       movb *de,a                      ; LD A,(DE)         ; Pick up the sprite graphic byte again
       socb *hl,a                      ; OR (HL)           ; Blend it with the background byte
_36875:
       movb a,*hl                      ; LD (HL),A         ; Copy the graphic byte to its destination cell
       sb   one,@l                     ; DEC L             ; {Move #REGhl to the next pixel row down in the cell on
       ab   one,h                      ; INC H             ; the left}
       inc  de                         ; INC DE            ; Point #REGde at the next sprite graphic byte
       movb h,a                        ; LD A,H            ; {Have we drawn the bottom pixel row in this pair of
       andi a,7*256                    ; AND 7             ; cells yet?}
       jne  _36900                     ; JR NZ,36900       ; Jump if not
       movb h,a                        ; LD A,H            ; {Otherwise move #REGhl to the top pixel row in the cell
       sb   @bytes+8,a                 ; SUB 8             ; below
       movb a,h                        ; LD H,A            ; 
       movb @l,a                       ; LD A,L            ; 
       ab   @bytes+32,a                ; ADD A,32          ; 
       movb a,@l                       ; LD L,A            ; }
       andi a,224*256                  ; AND 224           ; Was the last pair of cells at y-coordinate 7 or 15?
       jne  _36900                     ; JR NZ,36900       ; Jump if not
       movb h,a                        ; LD A,H            ; {Otherwise adjust #REGhl to account for the movement
       ab   @bytes+8,a                 ; ADD A,8           ; from the top or middle third of the screen to the next
       movb a,h                        ; LD H,A            ; one down}
_36900:
       sb   one,b                      ; DJNZ 36854        ; Jump back until all 16 rows of pixels have been drawn
       jne  _36854                     ;                   
       sb   a,a                        ; XOR A             ; Set the zero flag (to indicate no collision)
       .ret                            ; RET               ; 

* Move to the next cavern
* 
* Used by the routines at #R34574 and #R36805.
nxsheet:                               ; 36904
       movb @sheet,a                   ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       ab   one,a                      ; INC A             ; Increment the cavern number
       cb   a,@bytes+20                ; CP 20             ; Is the current cavern #R64512(The Final Barrier)?
       jne  _37009                     ; JR NZ,37009       ; Jump if not
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
       socb a,a                        ; OR A              ; Are we in demo mode?
       jeq  !                          ; JP NZ,37008       ; Jump if so
       b    @_37008                    ;                   
!
       movb @cheat,a                   ; LD A,(33885)      ; Pick up the 6031769 key counter from #R33885
       cb   a,@bytes+7                 ; CP 7              ; Is cheat mode activated?
       jeq  _37008                     ; JR Z,37008        ; Jump if so
* Willy has made it through #R64512(The Final Barrier) without cheating.
       sb   @c,@c                      ; LD C,0            ; {Draw Willy at (2,19) on the ground above the portal
       li   de,willyr3                 ; LD DE,33376       ; 
       li   hl,zx_screen+83            ; LD HL,16467       ; 
       .call @drwfix                   ; CALL 36852        ; }
       li   de,swordfish               ; LD DE,45792       ; {Draw the swordfish graphic (see #R45792) over the
       li   hl,zx_screen+179           ; LD HL,16563       ; portal
       .call @drwfix                   ; CALL 36852        ; }
       li   hl,zx_attrs+83             ; LD HL,22611       ; Point #REGhl at (2,19) in the attribute file
       li   de,31                      ; LD DE,31          ; Prepare #REGde for addition
       movb @bytes+47,*hl              ; LD (HL),47        ; {Set the attributes for the upper half of Willy's sprite
       inc  hl                         ; INC HL            ; at (2,19) and (2,20) to #b47 (INK 7: PAPER 5)
       movb @bytes+47,*hl              ; LD (HL),47        ; }
       a    de,hl                      ; ADD HL,DE         ; {Set the attributes for the lower half of Willy's sprite
       movb @bytes+39,*hl              ; LD (HL),39        ; at (3,19) and (3,20) to #b39 (INK 7: PAPER 4)
       inc  hl                         ; INC HL            ; 
       movb @bytes+39,*hl              ; LD (HL),39        ; }
       a    de,hl                      ; ADD HL,DE         ; {Point #REGhl at (5,19) in the attribute file
       inc  hl                         ; INC HL            ; 
       a    de,hl                      ; ADD HL,DE         ; }
       movb @bytes+69,*hl              ; LD (HL),69        ; {Set the attributes for the fish at (5,19) and (5,20) to
       inc  hl                         ; INC HL            ; #b69 (INK 5: PAPER 0: BRIGHT 1)
       movb @bytes+69,*hl              ; LD (HL),69        ; }
       a    de,hl                      ; ADD HL,DE         ; {Set the attribute for the handle of the sword at (6,19)
       movb @bytes+70,*hl              ; LD (HL),70        ; to #b70 (INK 6: PAPER 0: BRIGHT 1)}
       inc  hl                         ; INC HL            ; {Set the attribute for the blade of the sword at (6,20)
       movb @bytes+71,*hl              ; LD (HL),71        ; to #b71 (INK 7: PAPER 0: BRIGHT 1)}
       a    de,hl                      ; ADD HL,DE         ; {Set the attributes at (7,19) and (7,20) to #b0 (to hide
       sb   *hl,*hl                    ; LD (HL),0         ; Willy's feet just below where the portal was)
       inc  hl                         ; INC HL            ; 
       sb   *hl,*hl                    ; LD (HL),0         ; }
* Now play a celebratory sound effect.
* .
* #AUDIO4(escape.wav)(36983,37008)
       li   bc,0                       ; LD BC,0           ; {Prepare #REGc and #REGd for the celebratory sound
       movb @bytes+50,d                ; LD D,50           ; effect}
       sb   a,a                        ; XOR A             ; #REGa=0 (black border)
_36989:
       ; OUT (254),A                   ; OUT (254),A       ; {Produce the celebratory sound effect: Willy has escaped
       li   r0,24*256                  ; XOR 24            ; from the mine
       xor  r0,a                       ;                   
       movb a,@e                       ; LD E,A            ; 
       movb @c,a                       ; LD A,C            ; 
       ab   d,a                        ; ADD A,D           ; 
       ab   d,a                        ; ADD A,D           ; 
       ab   d,a                        ; ADD A,D           ; 
       movb a,b                        ; LD B,A            ; 
       movb @e,a                       ; LD A,E            ; 
_37000:
       sb   one,b                      ; DJNZ 37000        ; 
       jne  _37000                     ;                   
       sb   one,@c                     ; DEC C             ; 
       jne  _36989                     ; JR NZ,36989       ; 
       sb   one,d                      ; DEC D             ; 
       jne  _36989                     ; JR NZ,36989       ; }
_37008:
       sb   a,a                        ; XOR A             ; #REGa=#b0 (the next cavern will be #R45056(Central
                                                           ; Cavern))
_37009:
       movb a,@sheet                   ; LD (33799),A      ; Update the cavern number at #R33799
* The next section of code cycles the INK and PAPER colours of the current
* cavern.
       movb @bytes+63,a                ; LD A,63           ; Initialise #REGa to #b63 (INK 7: PAPER 7)
_37014:
       li   hl,zx_attrs                ; LD HL,22528       ; {Set the attributes for the top two-thirds of the screen
       li   de,zx_attrs+1              ; LD DE,22529       ; to the value in #REGa
       li   bc,511                     ; LD BC,511         ; 
       movb a,*hl                      ; LD (HL),A         ; 
       .ldir                           ; LDIR              ; }
       li   bc,4                       ; LD BC,4           ; {Pause for about 0.004s
_37029:
       sb   one,b                      ; DJNZ 37029        ; 
       jne  _37029                     ;                   
       sb   one,@c                     ; DEC C             ; 
       jne  _37029                     ; JR NZ,37029       ; }
       sb   one,a                      ; DEC A             ; Decrement the attribute value in #REGa
       jne  _37014                     ; JR NZ,37014       ; Jump back until we've gone through all attribute values
                                                           ; from #b63 down to #b1
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
       socb a,a                        ; OR A              ; Are we in demo mode?
       jeq  !                          ; JP NZ,34449       ; If so, demo the next cavern
       b    @newsht                    ;                   
!
* The following loop increases the score and decreases the air supply until it
* runs out, while playing a sound effect.
* .
* #PUSHS #POKES32956,63 #AUDIO4(air.wav)(37044,34449) #POPS
_37044:
       equ  $
       .call @decair                   ; CALL 35388        ; Decrease the air remaining in the current cavern
       jne  !                          ; JP Z,34449        ; Move to the next cavern if the air supply is now gone
       b    @newsht                    ;                   
!
       li   hl,scorbuf+5               ; LD HL,33838       ; {Add 1 to the score
       .call @_37118                   ; CALL 37118        ; }
       li   ix,scorbuf                 ; LD IX,33833       ; {Print the new score at (19,26)
       movb @bytes+6,@c                ; LD C,6            ; 
       li   de,zx_screen+4218          ; LD DE,20602       ; 
       .call @pmess                    ; CALL 37562        ; }
       movb @bytes+4,@c                ; LD C,4            ; This value determines the duration of the sound effect
       movb @air,a                     ; LD A,(32956)      ; Pick up the remaining air supply (S) from #R32956
       inv  a                          ; CPL               ; {#REGd=2*(63-S); this value determines the pitch of the
       andi a,63*256                   ; AND 63            ; sound effect (which decreases with the amount of air
       sla  a,1                        ; RLC A             ; TODO: check code. remaining)
       movb a,d                        ; LD D,A            ; }
_37079:
       sb   a,a                        ; LD A,0            ; {Produce a short note
       ; OUT (254),A                   ; OUT (254),A       ; 
       movb d,b                        ; LD B,D            ; 
_37084:
       sb   one,b                      ; DJNZ 37084        ; 
       jne  _37084                     ;                   
       movb @bytes+24,a                ; LD A,24           ; 
       ; OUT (254),A                   ; OUT (254),A       ; 
       movb d,b                        ; LD B,D            ; 
_37091:
       sb   one,b                      ; DJNZ 37091        ; 
       jne  _37091                     ;                   
       sb   one,@c                     ; DEC C             ; 
       jne  _37079                     ; JR NZ,37079       ; }
       jmp  _37044                     ; JR 37044          ; Jump back to decrease the air supply again

* Add to the score
* 
* The entry point to this routine is at #R37118.
incscore:                              ; 37098
       movb @bytes+48,*hl              ; LD (HL),48        ; Roll the digit over from '9' to '0'
       dec  hl                         ; DEC HL            ; Point #REGhl at the next digit to the left
       movb @l,a                       ; LD A,L            ; {Is this the 10000s digit?
       cb   a,@bytes+42                ; CP 42             ; }
       jne  _37118                     ; JR NZ,37118       ; Jump if not
* Willy has scored another 10000 points. Give him an extra life.
       movb @bytes+8,a                 ; LD A,8            ; {Set the screen flash counter at #R33880 to 8
       movb a,@flash                   ; LD (33880),A      ; }
       movb @nomen,a                   ; LD A,(33879)      ; {Increment the number of lives remaining at #R33879
       ab   one,a                      ; INC A             ; 
       movb a,@nomen                   ; LD (33879),A      ; }
* The entry point to this routine is here and is used by the routines at
* #R36707, #R36904 and #R37173 with #REGhl pointing at the digit of the score
* (see #R33833) to be incremented.
_37118:
       movb *hl,a                      ; LD A,(HL)         ; Pick up a digit of the score
       cb   a,@bytes+57                ; CP 57             ; Is it '9'?
       jeq  incscore                   ; JR Z,37098        ; Jump if so
       ab   one,*hl                    ; INC (HL)          ; Increment the digit
       .ret                            ; RET               ; 

* Move the conveyor in the current cavern
* 
* Used by the routine at #R34574.
mvconveyor:                            ; 37125
       mov  @convloc,hl                ; LD HL,(32880)     ; Pick up the address of the conveyor's location in the
                                                           ; screen buffer at #R28672 from #R32880
       movb @l,@e                      ; LD E,L            ; {Copy this address to #REGde
       movb h,d                        ; LD D,H            ; }
       movb @convlen,a                 ; LD A,(32882)      ; Pick up the length of the conveyor from #R32882
       movb a,b                        ; LD B,A            ; #REGb will count the conveyor tiles
       movb @convdir,a                 ; LD A,(32879)      ; Pick up the direction of the conveyor from #R32879
       socb a,a                        ; OR A              ; Is the conveyor moving right?
       jne  _37159                     ; JR NZ,37159       ; Jump if so
* The conveyor is moving left.
       movb *hl,a                      ; LD A,(HL)         ; Copy the first pixel row of the conveyor tile to #REGa
       sla  a,1                        ; RLC A             ; TODO: check code. {Rotate it left twice
       sla  a,1                        ; RLC A             ; TODO: check code. }
       ab   one,h                      ; INC H             ; {Point #REGhl at the third pixel row of the conveyor
       ab   one,h                      ; INC H             ; tile}
       movb *hl,@c                     ; LD C,(HL)         ; Copy this pixel row to #REGc
       ; RRC C                         ; RRC C             ; {Rotate it right twice
       ; RRC C                         ; RRC C             ; }
_37152:
       movb a,*de                      ; LD (DE),A         ; {Update the first and third pixel rows of every conveyor
       movb @c,*hl                     ; LD (HL),C         ; tile in the screen buffer at #R28672
       ab   one,@l                     ; INC L             ; 
       ab   one,@e                     ; INC E             ; 
       sb   one,b                      ; DJNZ 37152        ; }
       jne  _37152                     ;                   
       .ret                            ; RET               ; 
* The conveyor is moving right.
_37159:
       movb *hl,a                      ; LD A,(HL)         ; Copy the first pixel row of the conveyor tile to #REGa
       sra  a,1                        ; RRC A             ; TODO: check code. {Rotate it right twice
       sra  a,1                        ; RRC A             ; TODO: check code. }
       ab   one,h                      ; INC H             ; {Point #REGhl at the third pixel row of the conveyor
       ab   one,h                      ; INC H             ; tile}
       movb *hl,@c                     ; LD C,(HL)         ; Copy this pixel row to #REGc
       ; RLC C                         ; RLC C             ; {Rotate it left twice
       ; RLC C                         ; RLC C             ; }
       jmp  _37152                     ; JR 37152          ; Jump back to update the first and third pixel rows of
                                                           ; every conveyor tile

* Move and draw the Kong Beast in the current cavern
* 
* Used by the routine at #R34574.
kongbeast:                             ; 37173
       li   hl,attr_buffer_2+6         ; LD HL,23558       ; {Flip the left-hand switch at (0,6) if Willy is touching
       .call @chkswitch                ; CALL 37403        ; it}
       movb @eugdir,a                  ; LD A,(32987)      ; Pick up the Kong Beast's status from #R32987
       cb   a,@bytes+2                 ; CP 2              ; Is the Kong Beast already dead?
       jne  !                          ; RET Z             ; Return if so
       .ret                            ;                   
!
       movb @scrn_buffer_1+1286,a      ; LD A,(29958)      ; Pick up the sixth pixel row of the left-hand switch from
                                                           ; the screen buffer at #R28672
       cb   a,@bytes+16                ; CP 16             ; Has the switch been flipped?
       jne  !                          ; JP Z,37369        ; Jump if not
       b    @_37369                    ;                   
!
* The left-hand switch has been flipped. Deal with opening up the wall if that
* is still in progress.
       movb @attr_buffer_1+369,a       ; LD A,(24433)      ; Pick up the attribute byte of the tile at (11,17) in the
                                                           ; buffer at #R24064
       socb a,a                        ; OR A              ; Has the wall there been removed yet?
       jeq  _37238                     ; JR Z,37238        ; Jump if so
       li   hl,scrn_buffer_1+3953      ; LD HL,32625       ; Point #REGhl at the bottom row of pixels of the wall
                                                           ; tile at (11,17) in the screen buffer at #R28672
_37202:
       movb *hl,a                      ; LD A,(HL)         ; Pick up a pixel row
       socb a,a                        ; OR A              ; Is it blank yet?
       jne  _37228                     ; JR NZ,37228       ; Jump if not
       sb   one,h                      ; DEC H             ; Point #REGhl at the next pixel row up
       movb h,a                        ; LD A,H            ; {Have we checked all 8 pixel rows yet?
       cb   a,@bytes+119               ; CP 119            ; }
       jne  _37202                     ; JR NZ,37202       ; If not, jump back to check the next one
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       movb a,@attr_buffer_1+369       ; LD (24433),A      ; {Change the attributes at (11,17) and (12,17) in the
       movb a,@attr_buffer_1+401       ; LD (24465),A      ; buffer at #R24064 to match the background tile (the wall
                                                           ; there is now gone)}
       movb @bytes+114,a               ; LD A,114          ; {Update the seventh byte of the guardian definition at
       movb a,@hguard2+6               ; LD (32971),A      ; #R32965 so that the guardian moves through the opening
                                                           ; in the wall}
       jmp  _37238                     ; JR 37238          ; 
_37228:
       sb   *hl,*hl                    ; LD (HL),0         ; Clear a pixel row of the wall tile at (11,17) in the
                                                           ; screen buffer at #R28672
       movb @bytes+145,@l              ; LD L,145          ; {Point #REGhl at the opposite pixel row of the wall tile
       movb h,a                        ; LD A,H            ; one cell down at (12,17)
       li   r0,7*256                   ; XOR 7             ; 
       xor  r0,a                       ;                   
       movb a,h                        ; LD H,A            ; }
       sb   *hl,*hl                    ; LD (HL),0         ; Clear that pixel row as well
* Now check the right-hand switch.
_37238:
       li   hl,attr_buffer_2+18        ; LD HL,23570       ; {Flip the right-hand switch at (0,18) if Willy is
       .call @chkswitch                ; CALL 37403        ; touching it (and it hasn't already been flipped)}
       jne  _37277                     ; JR NZ,37277       ; Jump if the switch was not flipped
       sb   a,a                        ; XOR A             ; {Initialise the Kong Beast's pixel y-coordinate at
       movb a,@eughgt                  ; LD (32988),A      ; #R32988 to 0}
       ab   one,a                      ; INC A             ; {Update the Kong Beast's status at #R32987 to 1: he is
       movb a,@eugdir                  ; LD (32987),A      ; falling}
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       movb a,@attr_buffer_1+79        ; LD (24143),A      ; {Change the attributes of the floor beneath the Kong
       movb a,@attr_buffer_1+80        ; LD (24144),A      ; Beast in the buffer at #R24064 to match that of the
                                                           ; background tile}
       li   hl,scrn_buffer_1+79        ; LD HL,28751       ; Point #REGhl at (2,15) in the screen buffer at #R28672
       movb @bytes+8,b                 ; LD B,8            ; {Clear the cells at (2,15) and (2,16), removing the
_37268:
       sb   *hl,*hl                    ; LD (HL),0         ; floor beneath the Kong Beast
       ab   one,@l                     ; INC L             ; 
       sb   *hl,*hl                    ; LD (HL),0         ; 
       sb   one,@l                     ; DEC L             ; 
       ab   one,h                      ; INC H             ; 
       sb   one,b                      ; DJNZ 37268        ; }
       jne  _37268                     ;                   
_37277:
       movb @eugdir,a                  ; LD A,(32987)      ; Pick up the Kong Beast's status from #R32987
       socb a,a                        ; OR A              ; Is the Kong Beast still on the ledge?
       jeq  _37369                     ; JR Z,37369        ; Jump if so
* The Kong Beast is falling.
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the Kong Beast's pixel y-coordinate from #R32988
       cb   a,@bytes+100               ; CP 100            ; Has he fallen into the portal yet?
       jeq  _37363                     ; JR Z,37363        ; Jump if so
       ab   @bytes+4,a                 ; ADD A,4           ; {Add 4 to the Kong Beast's pixel y-coordinate at #R32988
       movb a,@eughgt                  ; LD (32988),A      ; (moving him downwards)}
       movb a,@c                       ; LD C,A            ; Copy the pixel y-coordinate to #REGc; this value
                                                           ; determines the pitch of the sound effect
       movb @bytes+16,d                ; LD D,16           ; This value determines the duration of the sound effect
       movb @border,a                  ; LD A,(32883)      ; Pick up the border colour for the current cavern from
                                                           ; #R32883
_37301:
       ; OUT (254),A                   ; OUT (254),A       ; {Make a falling sound effect
       li   r0,24*256                  ; XOR 24            ; 
       xor  r0,a                       ;                   
       movb @c,b                       ; LD B,C            ; 
_37306:
       sb   one,b                      ; DJNZ 37306        ; 
       jne  _37306                     ;                   
       sb   one,d                      ; DEC D             ; 
       jne  _37301                     ; JR NZ,37301       ; }
       movb @c,a                       ; LD A,C            ; Copy the Kong Beast's pixel y-coordinate back into #REGa
       sla  a,1                        ; RLCA              ; TODO: check code. {Point #REGde at the entry in the screen buffer address
       movb a,@e                       ; LD E,A            ; lookup table at #R33536 that corresponds to the Kong
       movb @sbufaddrs_msb_byte,d      ; LD D,131          ; Beast's pixel y-coordinate}
       movb *de,a                      ; LD A,(DE)         ; {Point #REGhl at the address of the Kong Beast's
       socb @bytes+15,a                ; OR 15             ; location in the screen buffer at #R24576
       movb a,@l                       ; LD L,A            ; 
       inc  de                         ; INC DE            ; 
       movb *de,a                      ; LD A,(DE)         ; 
       movb a,h                        ; LD H,A            ; }
       movb @bytes+129,d               ; LD D,129          ; {Use bit 5 of the value of the game clock at #R32957
       movb @clock,a                   ; LD A,(32957)      ; (which is toggled once every eight passes through the
       andi a,32*256                   ; AND 32            ; main loop) to point #REGde at the graphic data for the
       socb @bytes+64,a                ; OR 64             ; appropriate Kong Beast sprite
       movb a,@e                       ; LD E,A            ; }
       sb   @c,@c                      ; LD C,0            ; {Draw the Kong Beast to the screen buffer at #R24576
       .call @drwfix                   ; CALL 36852        ; }
       li   hl,scorbuf+3               ; LD HL,33836       ; {Add 100 to the score
       .call @_37118                   ; CALL 37118        ; }
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the Kong Beast's pixel y-coordinate from #R32988
       andi a,120*256                  ; AND 120           ; {Point #REGhl at the address of the Kong Beast's
       movb a,@l                       ; LD L,A            ; location in the attribute buffer at #R23552
       movb @bytes+23,h                ; LD H,23           ; 
       a    hl,hl                      ; ADD HL,HL         ; 
       a    hl,hl                      ; ADD HL,HL         ; 
       movb @l,a                       ; LD A,L            ; 
       socb @bytes+15,a                ; OR 15             ; 
       movb a,@l                       ; LD L,A            ; }
       movb @bytes+6,a                 ; LD A,6            ; The Kong Beast is drawn with yellow INK
       b    @_36447                    ; JP 36447          ; Set the attribute bytes for the Kong Beast
* The Kong Beast has fallen into the portal.
_37363:
       movb @bytes+2,a                 ; LD A,2            ; {Set the Kong Beast's status at #R32987 to 2: he is dead
       movb a,@eugdir                  ; LD (32987),A      ; }
       .ret                            ; RET               ; 
* The Kong Beast is still on the ledge.
_37369:
       movb @clock,a                   ; LD A,(32957)      ; Pick up the value of the game clock at #R32957
       andi a,32*256                   ; AND 32            ; {Use bit 5 of this value (which is toggled once every
       movb a,@e                       ; LD E,A            ; eight passes through the main loop) to point #REGde at
       movb @bytes+129,d               ; LD D,129          ; the graphic data for the appropriate Kong Beast sprite}
       li   hl,scrn_buffer_2+15        ; LD HL,24591       ; {Draw the Kong Beast at (0,15) in the screen buffer at
       movb one,@c                     ; LD C,1            ; #R24576
       .call @drwfix                   ; CALL 36852        ; }
       jeq  !                          ; JP NZ,36102       ; Kill Willy if he collided with the Kong Beast
       b    @_36102                    ;                   
!
       movb @bytes+68,a                ; LD A,68           ; #REGa=#b68 (INK 4: PAPER 0: BRIGHT 1)
       movb a,@attr_buffer_2+47        ; LD (23599),A      ; {Set the attribute bytes for the Kong Beast in the
       movb a,@attr_buffer_2+48        ; LD (23600),A      ; buffer at #R23552
       movb a,@attr_buffer_2+15        ; LD (23567),A      ; 
       movb a,@attr_buffer_2+16        ; LD (23568),A      ; }
       .ret                            ; RET               ; 

* Flip a switch in a Kong Beast cavern if Willy is touching it
* 
* Used by the routine at #R37173. Returns with the zero flag set if Willy flips
* the switch.
* 
* HL Address of the switch's location in the attribute buffer at #R23552
chkswitch:                             ; 37403
       movb @location,a                ; LD A,(32876)      ; Pick up the LSB of the address of Willy's location in
                                                           ; the attribute buffer at #R23552 from #R32876
       ab   one,a                      ; INC A             ; {Is it equal to or one less than the LSB of the address
       andi a,254*256                  ; AND 254           ; of the switch's location?
       cb   a,@l                       ; CP L              ; }
       jeq  !                          ; RET NZ            ; Return (with the zero flag reset) if not
       .ret                            ;                   
!
       movb @location+1,a              ; LD A,(32877)      ; Pick up the MSB of the address of Willy's location in
                                                           ; the attribute buffer at #R23552 from #R32876(#N32877)
       cb   a,h                        ; CP H              ; Does it match the MSB of the address of the switch's
                                                           ; location?
       jeq  !                          ; RET NZ            ; Return (with the zero flag reset) if not
       .ret                            ;                   
!
       movb @extra+6,a                 ; LD A,(32869)      ; Pick up the sixth byte of the graphic data for the
                                                           ; switch tile from #R32863(#N32869)
       movb @bytes+117,h               ; LD H,117          ; Point #REGhl at the sixth row of pixels of the switch
                                                           ; tile in the screen buffer at #R28672
       cb   a,*hl                      ; CP (HL)           ; Has the switch already been flipped?
       jeq  !                          ; RET NZ            ; Return (with the zero flag reset) if so
       .ret                            ;                   
!
* Willy is flipping the switch.
       movb @bytes+8,*hl               ; LD (HL),8         ; {Update the sixth, seventh and eighth rows of pixels of
       ab   one,h                      ; INC H             ; the switch tile in the screen buffer at #R28672 to make
       movb @bytes+6,*hl               ; LD (HL),6         ; it appear flipped
       ab   one,h                      ; INC H             ; 
       movb @bytes+6,*hl               ; LD (HL),6         ; }
       sb   a,a                        ; XOR A             ; Set the zero flag: Willy has flipped the switch
       socb a,a                        ; OR A              ; This instruction is redundant
       .ret                            ; RET               ; 

* Check and set the attribute bytes for Willy's sprite in the buffer at #N23552
* 
* Used by the routine at #R34574.
willyattrs:                            ; 37434
       mov  @location,hl               ; LD HL,(32876)     ; Pick up the address of Willy's location in the attribute
                                                           ; buffer at #R23552 from #R32876
       li   de,31                      ; LD DE,31          ; Prepare #REGde for addition
       movb @bytes+15,@c               ; LD C,15           ; Set #REGc=#b15 for the top two rows of cells (to make
                                                           ; the routine at #R37471 force white INK)
       .call @willyattr                ; CALL 37471        ; Check and set the attribute byte for the top-left cell
       inc  hl                         ; INC HL            ; Move #REGhl to the next cell to the right
       .call @willyattr                ; CALL 37471        ; Check and set the attribute byte for the top-right cell
       a    de,hl                      ; ADD HL,DE         ; Move #REGhl down a row and back one cell to the left
       .call @willyattr                ; CALL 37471        ; Check and set the attribute byte for the mid-left cell
       inc  hl                         ; INC HL            ; Move #REGhl to the next cell to the right
       .call @willyattr                ; CALL 37471        ; Check and set the attribute byte for the mid-right cell
       movb @willy_y,a                 ; LD A,(32872)      ; Pick up Willy's y-coordinate from #R32872
       movb a,@c                       ; LD C,A            ; Copy it to #REGc
       a    de,hl                      ; ADD HL,DE         ; Move #REGhl down a row and back one cell to the left
       .call @willyattr                ; CALL 37471        ; Check and set the attribute byte for the bottom-left
                                                           ; cell
       inc  hl                         ; INC HL            ; Move #REGhl to the next cell to the right
       .call @willyattr                ; CALL 37471        ; Check and set the attribute byte for the bottom-right
                                                           ; cell
       jmp  drawwilly                  ; JR 37503          ; Draw Willy to the screen buffer at #R24576

* Check and set the attribute byte for a cell occupied by Willy's sprite
* 
* Used by the routine at #R37434.
* 
* C #b15 or Willy's y-coordinate
* HL Address of the cell in the attribute buffer at #R23552
willyattr:                             ; 37471
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       cb   a,*hl                      ; CP (HL)           ; Does this cell contain a background tile?
       jne  _37488                     ; JR NZ,37488       ; Jump if not
       movb @c,a                       ; LD A,C            ; {Set the zero flag if we are going to retain the INK
       andi a,15*256                   ; AND 15            ; colour in this cell; this happens only if the cell is in
                                                           ; the bottom row and Willy's sprite is confined to the top
                                                           ; two rows}
       jeq  _37488                     ; JR Z,37488        ; Jump if we are going to retain the current INK colour in
                                                           ; this cell
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       socb @bytes+7,a                 ; OR 7              ; Set bits 0-2, making the INK white
       movb a,*hl                      ; LD (HL),A         ; Set the attribute byte for this cell in the buffer at
                                                           ; #R23552
_37488:
       movb @nasty1,a                  ; LD A,(32845)      ; Pick up the attribute byte of the first nasty tile for
                                                           ; the current cavern from #R32845
       cb   a,*hl                      ; CP (HL)           ; Has Willy hit a nasty of the first kind?
       jne  !                          ; JP Z,36101        ; Kill Willy if so
       b    @killwilly                 ;                   
!
       movb @nasty2,a                  ; LD A,(32854)      ; Pick up the attribute byte of the second nasty tile for
                                                           ; the current cavern from #R32854
       cb   a,*hl                      ; CP (HL)           ; Has Willy hit a nasty of the second kind?
       jne  !                          ; JP Z,36101        ; Kill Willy if so
       b    @killwilly                 ;                   
!
       .ret                            ; RET               ; 

* Draw Willy to the screen buffer at #N24576
* 
* Used by the routine at #R37434.
drawwilly:                             ; 37503
       movb @willy_y,a                 ; LD A,(32872)      ; Pick up Willy's y-coordinate from #R32872
       movb @sbufaddrs_msb_byte,ix     ; LD IXH,131        ; {Point #REGix at the entry in the screen buffer address
       movb a,@ixl                     ; LD IXL,A          ; lookup table at #R33536 that corresponds to Willy's
                                                           ; y-coordinate}
       movb @dmflags,a                 ; LD A,(32874)      ; Pick up Willy's direction and movement flags from
                                                           ; #R32874
       andi a,1*256                    ; AND 1             ; {Now #REGe=#b0 if Willy is facing right, or #b128 if
       srl  a,1                        ; RRCA              ; TODO: check code. he's facing left
       movb a,@e                       ; LD E,A            ; }
       movb @frame,a                   ; LD A,(32873)      ; Pick up Willy's animation frame (0-3) from #R32873
       andi a,3*256                    ; AND 3             ; {Point #REGde at the sprite graphic data for Willy's
       srl  a,1                        ; RRCA              ; TODO: check code. current animation frame (see #R33280)
       srl  a,1                        ; RRCA              ; TODO: check code. 
       srl  a,1                        ; RRCA              ; TODO: check code. 
       socb @e,a                       ; OR E              ; 
       movb a,@e                       ; LD E,A            ; 
       movb @bytes+130,d               ; LD D,130          ; }
       movb @bytes+16,b                ; LD B,16           ; There are 16 rows of pixels to copy
       movb @location,a                ; LD A,(32876)      ; {Pick up Willy's screen x-coordinate (0-31) from #R32876
       andi a,31*256                   ; AND 31            ; }
       movb a,@c                       ; LD C,A            ; Copy it to #REGc
_37538:
       movb *ix,a                      ; LD A,(IX+0)       ; {Set #REGhl to the address in the screen buffer at
       movb @1(ix),h                   ; LD H,(IX+1)       ; #R24576 that corresponds to where we are going to draw
       socb @c,a                       ; OR C              ; the next pixel row of the sprite graphic
       movb a,@l                       ; LD L,A            ; }
       movb *de,a                      ; LD A,(DE)         ; Pick up a sprite graphic byte
       socb *hl,a                      ; OR (HL)           ; Merge it with the background
       movb a,*hl                      ; LD (HL),A         ; Save the resultant byte to the screen buffer
       inc  hl                         ; INC HL            ; Move #REGhl along to the next cell to the right
       inc  de                         ; INC DE            ; Point #REGde at the next sprite graphic byte
       movb *de,a                      ; LD A,(DE)         ; Pick it up in #REGa
       socb *hl,a                      ; OR (HL)           ; Merge it with the background
       movb a,*hl                      ; LD (HL),A         ; Save the resultant byte to the screen buffer
       inc  ix                         ; INC IX            ; {Point #REGix at the next entry in the screen buffer
       inc  ix                         ; INC IX            ; address lookup table at #R33536}
       inc  de                         ; INC DE            ; Point #REGde at the next sprite graphic byte
       sb   one,b                      ; DJNZ 37538        ; Jump back until all 16 rows of pixels have been drawn
       jne  _37538                     ;                   
       .ret                            ; RET               ; 

* Print a message
* 
* Used by the routines at #R34252, #R34436, #R34574, #R35140 and #R36904.
* 
* IX Address of the message
* C Length of the message
* DE Display file address
pmess:                                 ; 37562
       movb *ix,a                      ; LD A,(IX+0)       ; Collect a character from the message
       .call @printchar                ; CALL 37579        ; Print it
       inc  ix                         ; INC IX            ; Point #REGix at the next character in the message
       ab   one,@e                     ; INC E             ; {Point #REGde at the next character cell (subtracting 8
       movb d,a                        ; LD A,D            ; from #REGd compensates for the operations performed by
       sb   @bytes+8,a                 ; SUB 8             ; the routine at #R37579)
       movb a,d                        ; LD D,A            ; }
       sb   one,@c                     ; DEC C             ; Have we printed the entire message yet?
       jne  pmess                      ; JR NZ,37562       ; If not, jump back to print the next character
       .ret                            ; RET               ; 

* Print a single character
* 
* Used by the routine at #R37562.
* 
* A ASCII code of the character
* DE Display file address
printchar:                             ; 37579
;       movb @bytes+7,h                 ; LD H,7            ; {Point #REGhl at the bitmap for the character (in the
;       movb a,@l                       ; LD L,A            ; ROM)
;       socb @bits+7,@l                 ; SET 7,L           ;
;       a    hl,hl                      ; ADD HL,HL         ;
;       a    hl,hl                      ; ADD HL,HL         ;
;       a    hl,hl                      ; ADD HL,HL         ; }
       sb   @bytes+32,a
       clr  hl
       movb a,h
       srl  hl,5
       ai   hl,font
       movb @bytes+8,b                 ; LD B,8            ; There are eight pixel rows in a character bitmap
* This entry point is used by the routine at #R36707 to draw an item in the
* current cavern.
_37589:
;       movb *hl,a                      ; LD A,(HL)         ; {Copy the character bitmap to the screen (or item
;       movb a,*de                      ; LD (DE),A         ; graphic to the screen buffer)
;       inc  hl                         ; INC HL            ;
       movb *hl+,*de
       ab   one,d                      ; INC D             ;
       sb   one,b                      ; DJNZ 37589        ; }
       jne  _37589                     ;                   
       .ret                            ; RET               ; 

* Play the theme tune (The Blue Danube)
* 
* Used by the routine at #R34252. Returns with the zero flag reset if ENTER or
* the fire button is pressed while the tune is being played.
* 
* IY #R33902 (tune data)
playtune:                              ; 37596
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the next byte of tune data from the table at
                                                           ; #R33902
       cb   a,@b255                    ; CP 255            ; Has the tune finished?
       jne  !                          ; RET Z             ; Return (with the zero flag set) if so
       .ret                            ;                   
!
       movb a,@c                       ; LD C,A            ; Copy the first byte of data for this note (which
                                                           ; determines the duration) to #REGc
       sb   b,b                        ; LD B,0            ; Initialise #REGb, which will be used as a delay counter
                                                           ; in the note-producing loop
       sb   a,a                        ; XOR A             ; Set #REGa=0 (for no apparent reasaon)
       movb @1(iy),d                   ; LD D,(IY+1)       ; Pick up the second byte of data for this note
       movb d,a                        ; LD A,D            ; Copy it to #REGa
       .call @pianokey                 ; CALL 37675        ; Calculate the attribute file address for the
                                                           ; corresponding piano key
       movb @bytes+80,*hl              ; LD (HL),80        ; Set the attribute byte for the piano key to #b80 (INK 0:
                                                           ; PAPER 2: BRIGHT 1)
       movb @2(iy),@e                  ; LD E,(IY+2)       ; Pick up the third byte of data for this note
       movb @e,a                       ; LD A,E            ; Copy it to #REGa
       .call @pianokey                 ; CALL 37675        ; Calculate the attribute file address for the
                                                           ; corresponding piano key
       movb @bytes+40,*hl              ; LD (HL),40        ; Set the attribute byte for the piano key to #b40 (INK 0:
                                                           ; PAPER 5: BRIGHT 0)
_37624:
       ; OUT (254),A                   ; OUT (254),A       ; {Produce a sound based on the frequency parameters in
       sb   one,d                      ; DEC D             ; the second and third bytes of data for this note (copied
       jne  _37634                     ; JR NZ,37634       ; into #REGd and #REGe)
       movb @1(iy),d                   ; LD D,(IY+1)       ; 
       li   r0,24*256                  ; XOR 24            ; 
       xor  r0,a                       ;                   
_37634:
       sb   one,@e                     ; DEC E             ; 
       jne  _37642                     ; JR NZ,37642       ; 
       movb @2(iy),@e                  ; LD E,(IY+2)       ; 
       li   r0,24*256                  ; XOR 24            ; 
       xor  r0,a                       ;                   
_37642:
       sb   one,b                      ; DJNZ 37624        ; 
       jne  _37624                     ;                   
       sb   one,@c                     ; DEC C             ; 
       jne  _37624                     ; JR NZ,37624       ; }
       .call @checkenter               ; CALL 37687        ; Check whether ENTER or the fire button is being pressed
       jeq  !                          ; RET NZ            ; Return (with the zero flag reset) if it is
       .ret                            ;                   
!
       movb @1(iy),a                   ; LD A,(IY+1)       ; Pick up the second byte of data for this note
       .call @pianokey                 ; CALL 37675        ; Calculate the attribute file address for the
                                                           ; corresponding piano key
       movb @bytes+56,*hl              ; LD (HL),56        ; Set the attribute byte for the piano key back to #b56
                                                           ; (INK 0: PAPER 7: BRIGHT 0)
       movb @2(iy),a                   ; LD A,(IY+2)       ; Pick up the third byte of data for this note
       .call @pianokey                 ; CALL 37675        ; Calculate the attribute file address for the
                                                           ; corresponding piano key
       movb @bytes+56,*hl              ; LD (HL),56        ; Set the attribute byte for the piano key back to #b56
                                                           ; (INK 0: PAPER 7: BRIGHT 0)
       inc  iy                         ; INC IY            ; {Move #REGiy along to the data for the next note in the
       inc  iy                         ; INC IY            ; tune
       inc  iy                         ; INC IY            ; }
       jmp  playtune                   ; JR 37596          ; Jump back to play the next note

* Calculate the attribute file address for a piano key
* 
* Used by the routine at #R37596. Returns with the attribute file address in
* #REGhl.
* 
* A Frequency parameter from the tune data table at #R33902
pianokey:                              ; 37675
       sb   @bytes+8,a                 ; SUB 8             ; {Compute the piano key index (K) based on the frequency
       srl  a,1                        ; RRCA              ; TODO: check code. parameter (F), and store it in bits 0-4 of #REGa:
       srl  a,1                        ; RRCA              ; TODO: check code. K=31-INT((F-8)/8)
       srl  a,1                        ; RRCA              ; TODO: check code. 
       inv  a                          ; CPL               ; }
       socb @bytes+224,a               ; OR 224            ; #REGa=#b224+K; this is the LSB
       movb a,@l                       ; LD L,A            ; {Set #REGhl to the attribute file address for the piano
       movb @bytes+89,h                ; LD H,89           ; key}
       .ret                            ; RET               ; 

* Check whether ENTER or the fire button is being pressed
* 
* Used by the routine at #R37596. Returns with the zero flag reset if ENTER or
* the fire button on the joystick is being pressed.
checkenter:                            ; 37687
       movb @kemp,a                    ; LD A,(33881)      ; Pick up the Kempston joystick indicator from #R33881
       socb a,a                        ; OR A              ; Is the joystick connected?
       jeq  _37698                     ; JR Z,37698        ; Jump if not
       ; IN A,(31)                     ; IN A,(31)         ; Collect input from the joystick
       movb a,r0                       ; BIT 4,A           ; Is the fire button being pressed?
       andi r0,16*256                  ;                   
       jeq  !                          ; RET NZ            ; Return (with the zero flag reset) if so
       .ret                            ;                   
!
_37698:
       equ  $
       li   bc,cavern3+1022            ; LD BC,49150       ; {Read keys H-J-K-L-ENTER
       ; IN A,(C)                      ; IN A,(C)          ; }
       andi a,1*256                    ; AND 1             ; Keep only bit 0 of the result (ENTER)
       cb   a,one                      ; CP 1              ; Reset the zero flag if ENTER is being pressed
       .ret                            ; RET               ; 

_40190:
       text >09,'A'                                                  ; }

* '...MANIC MINER . . #CHR(169) BUG-BYTE ltd. 1983...'
* 
* Used by the routine at #R34252.
messintro:                             ; 40192
       text '.  .  .  .  .  .  .  .  .  .  . MANIC MINER . . '
       text >7f,' BUG-BYTE LTD. 1983 . . BY MATTHEW SMITH . . . '
       text 'Q TO P = LEFT & RIGHT . . BOTTOM ROW = JUMP . . '
       text 'A TO G = PAUSE . . H TO L = TUNE ON/OFF . . . '
       text 'GUIDE MINER WILLY THROUGH 20 LETHAL CAVERNS'
       text ' .  .  .  .  .  .  .  .'

