* Manic Miner disassembly
* https://skoolkit.ca
*
* Copyright 1983 Bug-Byte Ltd (Manic Miner)
* Copyright 2010, 2012-2022 Richard Dymond (this disassembly)

;       b    @begin                     ; JP 33792

* Copyright 2010, 2012-2022 Richard Dymond (rjdymond@gmail.com)

* The game has just loaded
; begin:                               ; 33792
;      limi 0                          ; DI                ; Disable interrupts
;      li   sp,_40190                  ; LD SP,40190       ; Place the stack somewhere safe (near the end of the
                                                           ; source code remnants at #R37708)
;      b    @start                     ; JP 34252          ; Display the title screen and play the theme tune

* Display the title screen and play the theme tune
* 
* Used by the routines at #R33792, #R34574 and #R35140.
* .
* The first thing this routine does is initialise some game status buffer
* variables in preparation for the next game.
start:                                 ; 34252
       clr  af                         ; XOR A             ; #REGa=0
;      movb a,@cavern                  ; LD (33799),A      ; Initialise the current cavern number at #R33799
       movb @bytes+0,@cavern
       movb a,@kemp                    ; LD (33881),A      ; Initialise the Kempston joystick indicator at #R33881
       movb a,@demo                    ; LD (33882),A      ; Initialise the game mode indicator at #R33882
       movb a,@noteindex               ; LD (33883),A      ; Initialise the in-game music note index at #R33883
       movb a,@flash                   ; LD (33880),A      ; Initialise the screen flash counter at #R33880
       movb @bytes+2,a                 ; LD A,2            ; {Initialise the number of lives remaining at #R33879
       movb a,@lives                   ; LD (33879),A      ; }
       li   hl,musicflags              ; LD HL,33884       ; {Initialise the keypress flag in bit 0 at #R33884
       socb @bits+0,*hl                ; SET 0,(HL)        ; }
       bl   @reset_sprite_attr_table
* Next, prepare the screen.
;       li   hl,zx_screen               ; LD HL,16384       ; {Clear the entire display file
;       li   de,zx_screen+1             ; LD DE,16385       ;
;       li   bc,6143                    ; LD BC,6143        ;
;       sb   *hl,*hl                    ; LD (HL),0         ;
;       .ldir                          ; LDIR              ; }
       li   de,zx_screen
       li   bc,6144
       bl   @clear
       seto @title_screen_bank_select
       li   hl,titlescr1               ; LD HL,40960       ; {Copy the graphic data at #R40960 to the top two-thirds
       li   de,zx_screen               ; LD DE,16384       ; of the display file
       li   bc,4096                    ; LD BC,4096        ; 
       bl   @copy                      ; LDIR              ; }
       li   hl,zx_screen+2109          ; LD HL,18493       ; {Draw Willy at (9,29)
       li   de,willy_sprites_2         ; LD DE,33344       ;
       sb   @c,@c                      ; LD C,0            ;
       .call @draw_sprite              ; CALL 36852        ; }
       seto @caverns_14_19_bank_select
       li   hl,cavern19                ; LD HL,64512       ; {Copy the attribute bytes from #R64512 to the top third
       li   de,zx_attrs                ; LD DE,22528       ; of the attribute file
       li   bc,256                     ; LD BC,256         ;
       bl   @copy                      ; LDIR              ; }
       seto @title_screen_bank_select
       li   hl,lowerattrs              ; LD HL,40448       ; {Copy the attribute bytes from #R40448 to the bottom
       li   bc,512                     ; LD BC,512         ; two-thirds of the attribute file
       bl   @copy                      ; LDIR              ; }

       bl   @upload_zx_screen

* Now check whether there is a joystick connected.
;       li   bc,31                      ; LD BC,31          ; This is the joystick port
;       limi 0                          ; DI                ; Disable interrupts (which are already disabled)
;       sb   a,a                        ; XOR A             ; #REGa=0
;_34337:
;       ; IN E,(C)                      ; IN E,(C)          ; {Combine 256 readings of the joystick port in #REGa; if
;       socb @e,a                       ; OR E              ; no joystick is connected, some of these readings will
;       sb   one,b                      ; DJNZ 34337        ; have bit 5 set}
;       jne  _34337                     ;
;       andi a,32*256                   ; AND 32            ; Is a joystick connected (bit 5 reset)?
;       jne  _34351                     ; JR NZ,34351       ; Jump if not
;       movb one,a                      ; LD A,1            ; {Set the Kempston joystick indicator at #R33881 to 1
;       movb a,@kemp                    ; LD (33881),A      ; }

* And finally, play the theme tune and check for keypresses.
* .
* #AUDIO4(tune.wav)(34351,34358)
_34351:
       li   iy,themetune               ; LD IY,33902       ; Point #REGiy at the theme tune data at #R33902
       .call @playtune                 ; CALL 37596        ; Play the theme tune
       jeq  !                          ; JP NZ,34436       ; Start the game if ENTER or the fire button was pressed
       b    @start_game                ;
!
       sb   a,a                        ; XOR A             ; {Initialise the game status buffer variable at #R32988;
       movb a,@eughgt                  ; LD (32988),A      ; this will be used as an index for the message scrolled; across the screen}
scroller_loop:
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the message index from #R32988
       li   ix,messintro               ; LD IX,40192       ; {Point #REGix at the corresponding location in the
;      movb a,@ixl                     ; LD IXL,A          ; message at #R40192}
       mov  a,r0
       swpb r0
       a    r0,ix
       li   de,zx_screen+4192          ; LD DE,20576       ; {Print 32 characters of the message at (19,0)
       movb @bytes+32,@c               ; LD C,32           ; 
       .call @pmess                    ; CALL 37562        ; }
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the message index from #R32988
       andi a,6*256                    ; AND 6             ; {Keep only bits 1 and 2, and move them into bits 6 and
;      srl  a,1                        ; RRCA              ; 7, so that #REGa holds #b0, #b64, #b128 or #b192; this
;      srl  a,1                        ; RRCA              ; value determines the animation frame to use for Willy
       sla  a,5                        ; RRCA              ; }
       movb a,@e                       ; LD E,A            ; {Point #REGde at the graphic data for Willy's sprite
       movb @bytes+mandat_msb,d        ; LD D,130          ; (#R33280+#REGa)}
       li   hl,zx_screen+2109          ; LD HL,18493       ; {Draw Willy at (9,29)
       sb   @c,@c                      ; LD C,0            ; 
       .call @draw_sprite              ; CALL 36852        ; }

;       li   bc,100                    ; LD BC,100         ; {Pause for about 0.1s
;_34404:
;       sb   one,b                     ; DJNZ 34404        ;
;       jne  _34404                    ;
;       sb   one,@c                    ; DEC C             ;
;       jne  _34404                    ; JR NZ,34404       ; }

       bl   @upload_middle_part
       bl   @upload_bottom_part

;      li   bc,49150                   ; LD BC,49150       ; {Read keys H-J-K-L-ENTER
;      IN A,(C)                        ; IN A,(C)          ; }
;      andi a,1*256                    ; AND 1             ; Keep only bit 0 of the result (ENTER)
;      cb   a,one                      ; CP 1              ; Is ENTER being pressed?
;      jne  startgame                  ; JR NZ,34436       ; If so, start the game

       li   r0,KEY_EN
       bl   @ti_check_key
       jne  start_game
       li   r0,JOY_FI
       bl   @ti_check_key
       jne  start_game

       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the message index from #R32988
       ab   one,a                      ; INC A             ; Increment it
       movb a,@eughgt                  ; LD (32988),A      ; Store the new message index at #R32988
       cb   a,@bytes+224               ; CP 224            ; Set the zero flag if we've reached the end of the
                                                           ; message
       jne  scroller_loop                     ; JR NZ,34365       ; Jump back unless we've finished scrolling the message
                                                           ; across the screen
start_demo:
       movb @bytes+64,a                ; LD A,64           ; {Initialise the game mode indicator at #R33882 to #b64:
       movb a,@demo                    ; LD (33882),A      ; demo mode}
* This routine continues into the one at #R34436.

* Start the game (or demo mode)
* 
* Used by the routine at #R34252.
start_game:                            ; 34436
       li   hl,score                   ; LD HL,33829       ; {Initialise the score at #R33829
       li   de,score+1                 ; LD DE,33830       ; 
       li   bc,9                       ; LD BC,9           ; 
       movb @bytes+48,*hl              ; LD (HL),48        ; 
       .ldir                           ; LDIR              ; }
* This entry point is used by the routines at #R34574 (when teleporting into a
* cavern or reinitialising the current cavern after Willy has lost a life) and
* #R36904.
new_cavern:                            ; 34449
       bl   @ti_display_off
       bl   @mute_sound
       clr  af
       movb @cavern,a                   ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   a,@bytes+7
       jhe  !
       seto @caverns_0_6_bank_select
       jmp  !!!
!      cb   a,@bytes+14
       jhe  !
       sb   @bytes+7,a
       seto @caverns_7_13_bank_select
       jmp  !!
!      sb   @bytes+14,a
       seto @caverns_14_19_bank_select
!
;      sla  a,1                        ; SLA A             ; {Point #REGhl at the first byte of the cavern definition
       sla  a,2                        ; SLA A             ;
;      ab   @bytes+176,a               ; ADD A,176         ;
       movb a,h                        ; LD H,A            ;
       sb   @l,@l                      ; LD L,0            ; }
       ai   hl,cavern0
       li   de,attr_buffer_1           ; LD DE,24064       ; {Copy the cavern's attribute bytes into the buffer at
       li   bc,512                     ; LD BC,512         ; #R24064 attr_buffer_1
       bl   @copy                      ; LDIR              ; }
       li   de,cavernname              ; LD DE,32768       ; {Copy the rest of the cavern definition into the game
       li   bc,512                     ; LD BC,512         ; status buffer at #GBUF32768
       bl   @copy                      ; LDIR              ; }
       bl   @upload_sprite_patterns
       .call @draw_cavern              ; CALL 35445        ; Draw the current cavern to the screen buffer at #R28672 scrn_buffer_1
;      li   hl,zx_screen+4096          ; LD HL,20480       ; {Clear the bottom third of the display file
;      li   de,zx_screen+4097          ; LD DE,20481       ;
;      li   bc,2047                    ; LD BC,2047        ;
;      sb   *hl,*hl                    ; LD (HL),0         ;
;      .ldir                           ; LDIR              ; }
       li   de,zx_screen+4096
       li   bc,2048
       bl   @clear

       li   ix,cavernname              ; LD IX,32768       ; {Print the cavern name (see #R32768) at (16,0)
       movb @bytes+32,@c               ; LD C,32           ; 
       li   de,zx_screen+4096          ; LD DE,20480       ; 
       .call @pmess                    ; CALL 37562        ; }
       li   ix,messair                 ; LD IX,33816       ; {Print 'AIR' (see #R33816) at (17,0)
       movb @bytes+3,@c                ; LD C,3            ; 
       li   de,zx_screen+4128          ; LD DE,20512       ; 
       .call @pmess                    ; CALL 37562        ; }
       movb @bytes+zx_screen_msb+18,a  ; LD A,82           ; Initialise #REGa to #b82; this is the MSB of the display
                                                           ; file address at which to start drawing the bar that
                                                           ; represents the air supply
init_air_bar_loop:
       movb a,h                        ; LD H,A            ; {Prepare #REGhl and #REGde for drawing a row of pixels
       movb a,d                        ; LD D,A            ; in the air bar
       movb @bytes+36,@l               ; LD L,36           ;
       movb @bytes+37,@e               ; LD E,37           ; }
       movb a,b                        ; LD B,A            ; Save the display file address MSB in #REGb briefly
       movb @air,a                     ; LD A,(32956)      ; Pick up the value of the initial air supply from #R32956
       sb   @bytes+36,a                ; SUB 36            ; {Now #REGc determines the length of the air bar (in cell
       movb a,@c                       ; LD C,A            ; widths)}
       movb b,a                        ; LD A,B            ; Restore the display file address MSB to #REGa
       sb   b,b                        ; LD B,0            ; Now #REGbc determines the length of the air bar (in cell
                                                           ; widths)
       movb @b255,*hl                  ; LD (HL),255       ; {Draw a single row of pixels across #REGc cells
       .ldir                           ; LDIR              ; }
       ab   one,a                      ; INC A             ; Increment the display file address MSB in #REGa (moving
                                                           ; down to the next row of pixels)
       cb   a,@bytes+zx_screen_msb+22  ; CP 86             ; Have we drawn all four rows of pixels in the air bar
                                                           ; yet?
       jne  init_air_bar_loop                     ; JR NZ,34519       ; If not, jump back to draw the next one
       li   ix,messhssc                ; LD IX,33839       ; {Print 'High Score 000000#SPACE(3)Score 000000' (see
       li   de,zx_screen+4192          ; LD DE,20576       ; #R33839) at (19,0)
       movb @bytes+32,@c               ; LD C,32           ; 
       .call @pmess                    ; CALL 37562        ; }
       movb @border,a                  ; LD A,(32883)      ; Pick up the border colour for the current cavern from
       ; movb @b254,@c                 ; LD C,254          ; {Set the border colour
       ; OUT (C),A                     ; OUT (C),A         ; }
       bl   @ti_set_border_color
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
;      socb a,a                        ; OR A              ; Are we in demo mode?
       jeq  before_loop                ; JR Z,34574        ; If not, enter the main loop now
       movb @bytes+64,a                ; LD A,64           ; {Reset the game mode indicator at #R33882 to #b64 (we're
       movb a,@demo                    ; LD (33882),A      ; in demo mode)}
* This routine continues into the main loop at #R34574.

* Main loop
* 
* The routine at #R34436 continues here.
* .
* The first thing to do is check whether there are any remaining lives to draw
* at the bottom of the screen.
before_loop:
       seto @screen_update_flag
       bl   @init_tile_updates
       li   r0,light_beam_attr_addrs
       clr  *r0
loop:                                  ; 34574
       bl   @init_sprite_attr_table
       movb @lives,a                   ; LD A,(33879)      ; Pick up the number of lives remaining from #R33879
       li   hl,zx_screen+4256          ; LD HL,20640       ; Set #REGhl to the display file address at which to draw
                                                           ; the first Willy sprite
       socb a,a                        ; OR A              ; Are there any lives remaining?
       jeq  skip_draw_lives            ; JR Z,34608        ; Jump if not
       movb a,b                        ; LD B,A            ; Initialise #REGb to the number of lives remaining
* The following loop draws the remaining lives at the bottom of the screen.
draw_lives_loop:
       sb   @c,@c                      ; LD C,0            ; #REGc=0; this tells the sprite-drawing routine at
                                                           ; #R36852 to overwrite any existing graphics
       .push hl                        ; PUSH HL           ; {Save #REGhl and #REGbc briefly
       .push bc                        ; PUSH BC           ; }
       movb @noteindex,a               ; LD A,(33883)      ; Pick up the in-game music note index from #R33883; this
                                                           ; will determine the animation frame for the Willy sprites
;      sla  a,1                        ; RLCA              ; {Now #REGa=#b0 (frame 0), #b32 (frame 1), #b64 (frame 2)
;      sla  a,1                        ; RLCA              ; or #b96 (frame 3)
       sla  a,3                        ; RLCA              ; .
       andi a,96*256                   ; AND 96            ; }
       movb a,@e                       ; LD E,A            ; {Point #REGde at the corresponding Willy sprite (at
       movb @bytes+mandat_msb,d        ; LD D,130          ; #R33280+#REGa)}
       .call @draw_sprite              ; CALL 36852        ; Draw the Willy sprite on the screen
       .pop bc                         ; POP BC            ; {Restore #REGhl and #REGbc
       .pop hl                         ; POP HL            ; }
;      inc  hl                         ; INC HL            ; {Move #REGhl along to the location at which to draw the
       inct hl                         ; INC HL            ; next Willy sprite}
       sb   one,b                      ; DJNZ 34584        ; Jump back to draw any remaining sprites
       jne  draw_lives_loop                     ;
* Now draw a boot if cheat mode has been activated.
skip_draw_lives:
       movb @cheat,a                   ; LD A,(33885)      ; Pick up the 6031769 key counter from #R33885
       cb   a,@bytes+7                 ; CP 7              ; Has 6031769 been keyed in yet?
       jne  copy_buffer_1_to_2         ; JR NZ,34623       ; Jump if not
       seto @caverns_0_6_bank_select
       li   de,extra_sprite+(17*32)    ; LD DE,47840       ; Point #REGde at the graphic data for the boot (at
                                                           ; #R47840)
       sb   @c,@c                      ; LD C,0            ; #REGc=0 (overwrite mode)
       .call @draw_sprite              ; CALL 36852        ; Draw the boot at the bottom of the screen next to the
                                                           ; remaining lives
* Next, prepare the screen and attribute buffers for drawing to the screen.
copy_buffer_1_to_2:
       li   hl,attr_buffer_1           ; LD HL,24064       ; {Copy the contents of the attribute buffer at #R24064 attr_buffer_1
       li   de,attr_buffer_2           ; LD DE,23552       ; (the attributes for the empty cavern) into the attribute
       li   bc,512                     ; LD BC,512         ; buffer at #R23552 attr_buffer_2
       bl   @copy                      ; LDIR              ; }
       li   hl,scrn_buffer_1           ; LD HL,28672       ; {Copy the contents of the screen buffer at #R28672 scrn_buffer_1 (the
       li   de,scrn_buffer_2           ; LD DE,24576       ; tiles for the empty cavern) into the screen buffer at
       li   bc,4096                    ; LD BC,4096        ; #R24576 scrn_buffer_2
       bl   @copy                      ; LDIR              ; }

       .call @move_hguardians          ; CALL 36111        ; Move the horizontal guardians in the current cavern

       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
;      socb a,a                        ; OR A              ; Are we in demo mode?
       jne  !                          ; CALL Z,35515      ; If not, move Willy
       .call @move_willy               ;
!
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
;      socb a,a                        ; OR A              ; Are we in demo mode?
       jne  !                          ; CALL Z,37434      ; If not, check and set the attribute bytes for Willy's
       .call @willy_attrs              ;
!                                                          ; sprite in the buffer at #R23552 attr_buffer_2, and draw Willy to the
                                                           ; screen buffer at #R24576 scrn_buffer_2
       .call @draw_hguardians          ; CALL 36266        ; Draw the horizontal guardians in the current cavern
       .call @move_conveyor            ; CALL 37125        ; Move the conveyor in the current cavern
       .call @draw_items               ; CALL 36707        ; Draw the items in the current cavern and collect any
                                                           ; that Willy is touching
;      movb @cavern,a                  ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   @cavern,@bytes+4           ; CP 4              ; Are we in #R49152(Eugene's Lair)?
       jne  !                          ; CALL Z,36344      ; If so, move and draw Eugene
       .call @eugene                   ;
!
;      movb @cavern,a                  ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   @cavern,@bytes+13          ; CP 13             ; Are we in #R58368(Skylab Landing Bay)?
       jne  !                          ; JP Z,36469        ; If so, move and draw the Skylabs
       b    @skylabs                   ;
!
;      movb @cavern,a                  ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   @cavern,@bytes+8           ; CP 8              ; Are we in #R53248(Wacky Amoebatrons) or beyond?
       jl   !                          ; CALL NC,36593     ; If so, move and draw the vertical guardians
       .call @draw_vguardians          ;
!
;      movb @cavern,a                  ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   @cavern,@bytes+7           ; CP 7              ; Are we in #R52224(Miner Willy meets the Kong Beast)?
       jne  !                          ; CALL Z,37173      ; If so, move and draw the Kong Beast
       .call @kong_beast               ;
!
;      movb @cavern,a                  ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   @cavern,@bytes+11          ; CP 11             ; Are we in #R56320(Return of the Alien Kong Beast)?
       jne  !                          ; CALL Z,37173      ; If so, move and draw the Kong Beast
       .call @kong_beast               ;
!
;      movb @cavern,a                  ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   @cavern,@bytes+18          ; CP 18             ; Are we in #R63488(Solar Power Generator)?
       jne  !                          ; CALL Z,36211      ; If so, move and draw the light beam
       .call @lightbeam                ;
!
* This entry point is used by the routine at #R36469.
return_from_skylab:
      .call @draw_portal                ; CALL 36805      ; Draw the portal, or move to the next cavern if Willy has
* This entry point is used by the routine at #R36101.
return_from_kill_willy:
;      li   hl,scrn_buffer_2           ; LD HL,24576       ; {Copy the contents of the screen buffer at #R24576 scrn_buffer_2 to
;      li   de,zx_screen               ; LD DE,16384       ; the display file
;      li   bc,4096                    ; LD BC,4096        ;
;      bl   @copy                      ; LDIR              ; }
*      Flash after extra life
       movb @flash,a                   ; LD A,(33880)      ; Pick up the screen flash counter from #R33880
;      socb a,a                        ; OR A              ; Is it zero?
       jeq  no_flash                     ; JR Z,34760        ; Jump if so
       sb   one,a                      ; DEC A             ; {Decrement the screen flash counter at #R33880
       movb a,@flash                   ; LD (33880),A      ; }
;      sla  a,1                        ; RLCA              ; {Move bits 0-2 into bits 3-5 and clear all the other
;      sla  a,1                        ; RLCA              ; bits
       sla  a,3                        ; RLCA              ;
       andi a,56*256                   ; AND 56            ; }
;       li   hl,attr_buffer_2           ; LD HL,23552       ; {Set every attribute byte in the buffer at #R23552 attr_buffer_2 to
;       li   de,attr_buffer_2+1         ; LD DE,23553       ; this value
;       li   bc,511                     ; LD BC,511         ;
;       movb a,*hl                      ; LD (HL),A         ;
;       .ldir                           ; LDIR              ; }
       li   de,attr_buffer_2
       li   bc,512
       bl   @fill
       bl   @upload_top_middle_attributes
no_flash:
;      li   hl,attr_buffer_2           ; LD HL,23552       ; {Copy the contents of the attribute buffer at #R23552 attr_buffer_2 to
;      li   de,zx_attrs                ; LD DE,22528       ; the attribute file
;      li   bc,512                     ; LD BC,512         ;
;      bl   @copy                      ; LDIR              ; }
*      Print score
       li   ix,scorbuf                 ; LD IX,33833       ; {Print the score (see #R33833) at (19,26)
       li   de,zx_screen+4218          ; LD DE,20602       ; 
       movb @bytes+6,@c                ; LD C,6            ; 
       .call @pmess                    ; CALL 37562        ; }
       li   ix,hghscor                 ; LD IX,33823       ; {Print the high score (see #R33823) at (19,11)
       li   de,zx_screen+4203          ; LD DE,20587       ; 
       movb @bytes+6,@c                ; LD C,6            ; 
       .call @pmess                    ; CALL 37562        ; }

       .call @dec_air                  ; CALL 35388        ; Decrease the air remaining in the current cavern
       jne  !                          ; JP Z,35071        ; Jump if there's no air left
       b    @willy_dead                ;
!
*      Full or partial screen update
       mov  @screen_update_flag,r0
       jeq  !
       bl   @upload_zx_screen
       bl   @ti_display_on
       clr  @screen_update_flag
       jmp  after_screen_update
!
*      Upload the conveyor (TODO: we only have to upload 2 pixel lines - not the full patterns)
       movb @convloc,r1
       swpb r1
       movb @convloc+1,r1
       ai   r1,scrn_buffer_2-scrn_buffer_1
       movb @convlen,r2
       srl  r2,8
       bl   @upload_patterns
*      Upload misc tiles, e.g. crumbling
       li   r0,tiles_updates
       mov  r0,@tile_updates_ptr
update_tiles:
       mov  @tile_updates_ptr,r0
       ci   r0,tiles_updates+tile_updates_size
       jeq  upload_score
       mov  *r0+,r1                    ; Address
       jeq  update_tiles_2
       mov  *r0,r2                     ; Counter
       jeq  update_tiles_2
       dec  *r0                        ; Decrement counter
       jne  update_tiles_1
       dect r0                         ; Back to address
       clr  *r0                        ; Clear address
update_tiles_1:
       ai   r1,scrn_buffer_2-scrn_buffer_1
       bl   @upload_character
update_tiles_2:
       inct @tile_updates_ptr
       inct @tile_updates_ptr
       jmp  update_tiles
*      Upload score
upload_score:
       li   r1,zx_screen+4218
       li   r2,6
       bl   @upload_patterns
*      Upload portal
       movb @portal,r0
       andi r0,128*256                 ; Is it flashing?
       jeq  after_screen_update
       movb @portal_location_1,r1
       swpb r1
       movb @portal_location_1+1,r1
       li   r2,2
       bl   @upload_attributes
       movb @portal_location_1,r1
       swpb r1
       movb @portal_location_1+1,r1
       ai   r1,32
       li   r2,2
       bl   @upload_attributes
after_screen_update:

       bl   @ti_check_quit

* Now check whether SHIFT and SPACE are being pressed.
;       li   bc,65278                  ; LD BC,65278       ; {Read keys SHIFT-Z-X-C-V
;       IN A,(C)                       ; IN A,(C)          ; }
;       movb a,@e                      ; LD E,A            ; Save the result in #REGe
;       movb @bytes+127,b              ; LD B,127          ; {Read keys B-N-M-SS-SPACE
;       IN A,(C)                       ; IN A,(C)          ; }
;       socb @e,a                      ; OR E              ; Combine the results
;       andi a,1*256                   ; AND 1             ; Are SHIFT and SPACE being pressed?
;       jne  !                         ; JP Z,34252        ; If so, quit the game
;       b    @start                    ;
;!
* Now read the keys A, S, D, F and G (which pause the game).
;       movb @bytes+253,b              ; LD B,253          ; {Read keys A-S-D-F-G
;       ; IN A,(C)                     ; IN A,(C)          ; }
;       andi a,31*256                  ; AND 31            ; {Are any of these keys being pressed?
;       cb   a,@bytes+31               ; CP 31             ; }
       li   r0,KEY_P
       bl   @ti_check_key
       jeq  check_dead                     ; JR Z,34837        ; Jump if
_34827:
       li   r0,KEY_P                   ; Wait for release
       bl   @ti_check_key
       jne  _34827                     ; JR Z,34827       ; Jump back if not (the game is still paused)
;      movb @bytes+2,b                 ; LD B,2           ; {Read every half-row of keys except A-S-D-F-G
;      IN A,(C)                        ; IN A,(C)         ; }
;      andi a,31*256                   ; AND 31           ; {Are any of these keys being pressed?
;      cb   a,@bytes+31                ; CP 31            ; }
       li   r0,KEY_P
       bl   @ti_check_key
       jeq  _34827                     ; JR Z,34827        ; Jump back if not (the game is still paused)

* Here we check whether Willy has had a fatal accident.
check_dead:
       movb @vdpsta,r0                 ; Check hardware sprite coincidence flag
       andi r0,>2000
       .ifeq can_die,1
       jne  !
       .else
       jmp  !!
       .endif
       movb @airborne,a                ; LD A,(32875)      ; Pick up the airborne status indicator from #R32875
       cb   a,@b255                    ; CP 255            ; Has Willy landed after falling from too great a height,
                                                           ; or collided with a nasty or a guardian?
       jne  !!                         ; JP Z,35071        ; Jump if so
!      b    @willy_dead                ;
!

* Now read the keys H, J, K, L and ENTER (which toggle the in-game music).
;       movb @bytes+191,b              ; LD B,191          ; Prepare #REGb for reading keys H-J-K-L-ENTER
       li   hl,musicflags              ; LD HL,33884       ; Point #REGhl at the music flags at #R33884
;      IN A,(C)                        ; IN A,(C)          ; Read keys H-J-K-L-ENTER
;      andi a,31*256                   ; AND 31            ; {Are any of these keys being pressed?
;      cb   a,@bytes+31                ; CP 31             ; }
       li   r0,KEY_M
       bl   @ti_check_key
       jeq  _34868                     ; JR Z,34868        ; Jump if not
       bl   @mute_sound
       movb *hl,r0                     ; BIT 0,(HL)        ; Were any of these keys being pressed the last time we
       andi r0,1*256                   ;
                                                            ; checked?
       jne  _34870                     ; JR NZ,34870       ; Jump if so
       movb *hl,a                      ; LD A,(HL)         ; {Set bit 0 (the keypress flag) and flip bit 1 (the
       li   r0,3*256                   ; XOR 3             ; in-game music flag) at #R33884
       xor  r0,a                       ;
       movb a,*hl                      ; LD (HL),A         ; }
       jmp  _34870                     ; JR 34870          ;
_34868:
       szcb @bits+0,*hl                ; RES 0,(HL)        ; Reset bit 0 (the keypress flag) at #R33884
_34870:
       movb *hl,r0                     ; BIT 1,(HL)        ; Has the in-game music been switched off?
       andi r0,2*256                   ;
       jne  nonote4                    ; JR NZ,34911       ; Jump if so
* The next section of code plays a note of the in-game music.
       movb @noteindex,a               ; LD A,(33883)      ; {Increment the in-game music note index at #R33883
       ab   one,a                      ; INC A             ;
       movb a,@noteindex               ; LD (33883),A      ; }
       andi a,126*256                  ; AND 126           ; {Point #REGhl at the appropriate entry in the tune data
       srl  a,1                        ; RRCA              ; table at #R34188
       movb a,@e                       ; LD E,A            ;
       sb   d,d                        ; LD D,0            ;
       li   hl,gametune                ; LD HL,34188       ;
       a    de,hl                      ; ADD HL,DE         ; }

       movb *hl,r1
       bl   @play_note_ch_1

;       movb @border,a                  ; LD A,(32883)      ; Pick up the border colour for the current cavern from
;                                                           ; #R32883
;       movb *hl,@e                     ; LD E,(HL)         ; Initialise the pitch delay counter in #REGe
;       li   bc,3                       ; LD BC,3           ; Initialise the duration delay counters in #REGb (0) and
;                                                           ; #REGc (3)
;tm51:                                  ; 34898
;       OUT (254),A                     ; OUT (254),A       ; {Produce a note of the in-game music
;see37708:                              ; 34900
;       sb   one,@e                     ; DEC E             ;
;       jne  noflp6                     ; JR NZ,34906       ;
;       movb *hl,@e                     ; LD E,(HL)         ;
;       li   r0,24*256                  ; XOR 24            ;
;       xor  r0,a                       ;
;noflp6:                                ; 34906
;       sb   one,b                      ; DJNZ 34898        ;
;       jne  tm51                       ;
;       sb   one,@c                     ; DEC C             ;
;       jne  tm51                       ; JR NZ,34898       ; }

* If we're in demo mode, check the keyboard and joystick and return to the
* title screen if there's any input.
nonote4:                               ; 34911
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
;      socb a,a                        ; OR A              ; Are we in demo mode?
       jeq  nodem1                     ; JR Z,34948        ; Jump if not
       sb   one,a                      ; DEC A             ; We're in demo mode; is it time to show the next cavern?
       jne  !                          ; JP Z,35071        ; Jump if so
       b    @willy_dead                   ;
!
       movb a,@demo                    ; LD (33882),A      ; Update the game mode indicator at #R33882

;      li   bc,254                     ; LD BC,254         ; {Read every row of keys on the keyboard
;      IN A,(C)                        ; IN A,(C)          ; }
;      andi a,31*256                   ; AND 31            ; {Are any keys being pressed?
;      cb   a,@bytes+31                ; CP 31             ; }
;      jeq  !                          ; JP NZ,34252       ; If so, return to the title screen
;      b    @start                     ;
;!
;      movb @kemp,a                    ; LD A,(33881)      ; Pick up the Kempston joystick indicator from #R33881
;      socb a,a                        ; OR A              ; Is there a joystick connected?
;      jeq  nodem1                     ; JR Z,34948        ; Jump if not
;      ; IN A,(31)                     ; IN A,(31)         ; Collect input from the joystick
;      socb a,a                        ; OR A              ; Is the joystick being moved or the fire button being
;                                                          ; pressed?
       li   r0,KEY_EN
       bl   @ti_check_key
       jne  !
       li   r0,JOY_FI
       bl   @ti_check_key
       jeq  !!                         ; JP NZ,34252       ; If so, return to the title screen
!      b    @start                     ;
!

;* Here we check the teleport keys.
nodem1:                                 ; 34948
;       li   bc,61438                   ; LD BC,61438       ; {Read keys 6-7-8-9-0
;       ; IN A,(C)                      ; IN A,(C)          ; }
;       movb a,r0                       ; BIT 4,A           ; Is '6' (the activator key) being pressed?
;       andi r0,16*256                  ;
;       jeq  !                          ; JP NZ,34984       ; Jump if not
;       b    @ckcheat                   ;
;!
       movb @cheat,a                   ; LD A,(33885)      ; Pick up the 6031769 key counter from #R33885
       cb   a,@bytes+7                 ; CP 7              ; Has 6031769 been keyed in yet?
       jne  !!                         ; JP NZ,34984       ; Jump if not
       li   r0,KEY_X
       bl   @ti_check_key
       jeq  !
       movb @cavern,a
       cb   @bytes+19,a
       jeq  !
       ab   one,a
       movb a,@cavern
       b    @new_cavern
!      li   r0,KEY_Z
       bl   @ti_check_key
       jeq  !
       movb @cavern,a
       jeq  !
       sb   one,a
       movb a,@cavern
       b    @new_cavern
!
;       movb @bytes+247,b               ; LD B,247          ; {Read keys 1-2-3-4-5
;       ; IN A,(C)                      ; IN A,(C)          ; }
;       inv  a                          ; CPL               ; {Keep only bits 0-4 and flip them
;       andi a,31*256                   ; AND 31            ; }
;       cb   a,@bytes+20                ; CP 20             ; Is the result #b20 or greater?
;       jl   !                          ; JP NC,34984       ; Jump if so (this is not a cavern number)
;       b    @ckcheat                   ;
;!
;       movb a,@sheet                   ; LD (33799),A      ; Store the cavern number at #R33799
;       b    @newsht                    ; JP 34449          ; Teleport into the cavern
;* Now check the 6031769 keys.
;ckcheat:                               ; 34984
;       movb @cheat,a                   ; LD A,(33885)      ; Pick up the 6031769 key counter from #R33885
;       cb   a,@bytes+7                 ; CP 7              ; Has 6031769 been keyed in yet?
;       jne  !                          ; JP Z,34574        ; If so, jump back to the start of the main loop
;       b    @loop                      ;
;!
;       sla  a,1                        ; RLCA              ; {Point #REGix at the corresponding entry in the 6031769
;       movb a,@e                       ; LD E,A            ; table at #R33888
;       sb   d,d                        ; LD D,0            ;
;       li   ix,cheatdt                 ; LD IX,33888       ;
;       a    de,ix                      ; ADD IX,DE         ; }
;       li   bc,63486                   ; LD BC,63486       ; {Read keys 1-2-3-4-5
;       ; IN A,(C)                      ; IN A,(C)          ; }
;       andi a,31*256                   ; AND 31            ; Keep only bits 0-4
;       cb   a,*ix                      ; CP (IX+0)         ; Does this match the first byte of the entry in the
;                                                           ; 6031769 table?
;       jeq  cknxcht                    ; JR Z,35032        ; Jump if so
;       cb   a,@bytes+31                ; CP 31             ; Are any of the keys 1-2-3-4-5 being pressed?
;       jne  !                          ; JP Z,34574        ; If not, jump back to the start of the main loop
;       b    @loop                      ;
;!
;       cb   a,@-2(ix)                  ; CP (IX-2)         ; Does the keyboard reading match the first byte of the
;                                                           ; previous entry in the 6031769 table?
;       jne  !                          ; JP Z,34574        ; If so, jump back to the start of the main loop
;       b    @loop                      ;
;!
;       sb   a,a                        ; XOR A             ; {Reset the 6031769 key counter at #R33885 to 0 (an
;       movb a,@cheat                   ; LD (33885),A      ; incorrect key is being pressed)}
;       b    @loop                      ; JP 34574          ; Jump back to the start of the main loop
;cknxcht:                               ; 35032
;       movb @bytes+239,b               ; LD B,239          ; {Read keys 6-7-8-9-0
;       ; IN A,(C)                      ; IN A,(C)          ; }
;       andi a,31*256                   ; AND 31            ; Keep only bits 0-4
;       cb   a,@1(ix)                   ; CP (IX+1)         ; Does this match the second byte of the entry in the
;                                                           ; 6031769 table?
;       jeq  inccht                     ; JR Z,35061        ; If so, jump to increment the 6031769 key counter
;       cb   a,@bytes+31                ; CP 31             ; Are any of the keys 6-7-8-9-0 being pressed?
;       jne  !                          ; JP Z,34574        ; If not, jump back to the start of the main loop
;       b    @loop                      ;
;!
;       cb   a,@-1(ix)                  ; CP (IX-1)         ; Does the keyboard reading match the second byte of the
;                                                           ; previous entry in the 6031769 table?
;       jne  !                          ; JP Z,34574        ; If so, jump back to the start of the main loop
;       b    @loop                      ;
;!
;       sb   a,a                        ; XOR A             ; {Reset the 6031769 key counter at #R33885 to 0 (an
;       movb a,@cheat                   ; LD (33885),A      ; incorrect key is being pressed)}
;       b    @loop                      ; JP 34574          ; Jump back to the start of the main loop
;inccht:                                ; 35061
;       movb @cheat,a                   ; LD A,(33885)      ; {Increment the 6031769 key counter at #R33885 (the next
;       ab   one,a                      ; INC A             ; key in the sequence is being pressed)
;       movb a,@cheat                   ; LD (33885),A      ; }

       li   r0,KEY_C
       bl   @ti_check_key
       jeq  !
       li   r0,KEY_CT
       bl   @ti_check_key
       jeq  !
       movb @bytes+7,@cheat

!      bl   @close_sprite_attr_table

       b    @loop                      ; JP 34574          ; Jump back to the start of the main loop

* The air in the cavern has run out, or Willy has had a fatal accident, or it's
* demo mode and it's time to show the next cavern.
willy_dead:                            ; 35071
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
;      socb a,a                        ; OR A              ; Is it demo mode?
       jeq  !                          ; JP NZ,36904       ; If so, move to the next cavern
       b    @next_cavern               ;
!
       bl   @reset_sprite_attr_table
* The following loop fills the top two thirds of the attribute file with a
* single value (#b71, #b70, #b69, #b68, #b67, #b66, #b65 or #b64) and makes a
* sound effect.
*
       sb   a,a
       bl   @ti_set_border_color
       movb @bytes+71,a                ; LD A,71           ; #REGa=#b71 (INK 7: PAPER 0: BRIGHT 1)
dead_loop:                             ; 35080
;      li   hl,zx_attrs                ; LD HL,22528       ; {Fill the top two thirds of the attribute file with the
;      li   de,zx_attrs+1              ; LD DE,22529       ; value in #REGa
;      li   bc,511                     ; LD BC,511         ;
;      movb a,*hl                      ; LD (HL),A         ;
;      .ldir                           ; LDIR              ; }
       li   de,zx_attrs
       li   bc,512
       bl   @fill

       bl   @upload_top_middle_attributes

       movb a,@e                       ; LD E,A            ; Save the attribute byte (#b64-#b71) in #REGe for later
                                                           ; retrieval

       inv  a                          ; CPL               ; {#REGd=63-8*(#REGe #S/AND/ 7); this value determines the
       andi a,7*256                    ; AND 7             ; pitch of the short note that will be played
       sla  a,1                        ; RLCA              ;
       sla  a,1                        ; RLCA              ;
       sla  a,1                        ; RLCA              ;
       socb @bytes+7,a                 ; OR 7              ;
       movb a,r1
       bl   @play_note_ch_2
;      movb a,d                        ; LD D,A            ; }
;      movb @e,@c                      ; LD C,E            ; {#REGc=8+32*(#REGe #S/AND/ 7); this value determines the
;      ; RRC C                         ; RRC C             ; duration of the short note that will be played
;      ; RRC C                         ; RRC C             ;
;      ; RRC C                         ; RRC C             ; }
;      socb @bytes+16,a                ; OR 16             ; Set bit 4 of #REGa (for no apparent reason)
;      sb   a,a                        ; XOR A             ; Set #REGa=0 (this will make the border black)
;tm21:                                 ; 35112
;      ; OUT (254),A                   ; OUT (254),A       ; {Produce a short note whose pitch is determined by #REGd
;      li   r0,24*256                  ; XOR 24            ; and whose duration is determined by #REGc
;      xor  r0,a                       ;
;      movb d,b                        ; LD B,D            ;
;tm22:                                 ; 35117
;      sb   one,b                      ; DJNZ 35117        ;
;      jne  tm22                       ;
;      sb   one,@c                     ; DEC C             ;
;      jne  tm21                       ; JR NZ,35112       ; }

       movb @e,a                       ; LD A,E            ; Restore the attribute byte (originally #b71) to #REGa
       sb   one,a                      ; DEC A             ; Decrement it (effectively decrementing the INK colour)
       cb   a,@bytes+63                ; CP 63             ; Have we used attribute value #b64 (INK 0) yet?
       jne  dead_loop                  ; JR NZ,35080       ; If not, jump back to update the INK colour in the top
                                                           ; two thirds of the screen and make another sound effect
       bl   @mute_sound

* Finally, check whether any lives remain.
       li   hl,lives                   ; LD HL,33879       ; {Pick up the number of lives remaining from #R33879
       movb *hl,a                      ; LD A,(HL)         ; }
;      socb a,a                        ; OR A              ; Are there any lives remaining?
       jne  !                          ; JP Z,35140        ; If not, display the game over sequence
       b    @game_over                    ;
!
       sb   one,*hl                    ; DEC (HL)          ; Decrease the number of lives remaining by one
       b    @new_cavern                    ; JP 34449      ; Jump back to reinitialise the current cavern

* Display the game over sequence
* 
* Used by the routine at #R34574. First check whether we have a new high score.
game_over:                             ; 35140
       li   hl,hghscor                 ; LD HL,33823       ; Point #REGhl at the high score at #R33823
       li   de,scorbuf                 ; LD DE,33833       ; Point #REGde at the current score at #R33833
       movb @bytes+6,b                 ; LD B,6            ; There are 6 digits to compare
check_highscore_loop:                  ; 35148
       movb *de,a                      ; LD A,(DE)         ; Pick up a digit of the current score
       cb   a,*hl                      ; CP (HL)           ; Compare it with the corresponding digit of the high
                                                           ; score
       jhe  !                          ; JP C,35171        ; Jump if it's less than the corresponding digit of the
       b    @boot_sequence             ;
!
                                                           ; high score
       jeq  !                          ; JP NZ,35160       ; Jump if it's greater than the corresponding digit of the
       b    @new_highscore             ;
!
                                                           ; high score
       inc  hl                         ; INC HL            ; Point #REGhl at the next digit of the high score
       inc  de                         ; INC DE            ; Point #REGde at the next digit of the current score
       sb   one,b                      ; DJNZ 35148        ; Jump back to compare the next pair of digits
       jne  check_highscore_loop       ;
new_highscore:                         ; 35160
       li   hl,scorbuf                 ; LD HL,33833       ; {Replace the high score with the current score
       li   de,hghscor                 ; LD DE,33823       ; 
       li   bc,6                       ; LD BC,6           ; 
       .ldir                           ; LDIR              ; }
* Now prepare the screen for the game over sequence.
boot_sequence:                         ; 35171
;      li   hl,zx_screen               ; LD HL,16384       ; {Clear the top two-thirds of the display file
;      li   de,zx_screen+1             ; LD DE,16385       ;
;      li   bc,4095                    ; LD BC,4095        ;
;      sb   *hl,*hl                    ; LD (HL),0         ;
;      .ldir                           ; LDIR              ; }
       li   de,zx_screen
       li   bc,4096
       bl   @clear

       sb   a,a                        ; XOR A             ; {Initialise the game status buffer variable at #R32988;
       movb a,@eughgt                  ; LD (32988),A      ; this variable will determine the distance of the boot
                                                           ; from the top of the screen}
       li   de,willy_sprites_2         ; LD DE,33344       ; {Draw Willy at (12,15)
       li   hl,zx_screen+2191          ; LD HL,18575       ; 
       sb   @c,@c                      ; LD C,0            ; 
       .call @draw_sprite              ; CALL 36852        ; }
       li   de,plinth                  ; LD DE,46816       ; {Draw the plinth (see #R46816) underneath Willy at
       li   hl,zx_screen+2255          ; LD HL,18639       ; (14,15)
       sb   @c,@c                      ; LD C,0            ; 
       .call @draw_sprite              ; CALL 36852        ; }

       sb   a,a
       bl   @ti_set_border_color
       bl   @upload_zx_screen

* The following loop draws the boot's descent onto the plinth that supports
* Willy while producing a sound effect.
boot_loop:                             ; 35210
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the distance variable from #R32988
       movb a,@c                       ; LD C,A            ; {Point #REGbc at the corresponding entry in the screen
       movb @sbufaddrs_msb_byte,b      ; LD B,131          ; buffer address lookup table at #R33536}
       movb *bc,a                      ; LD A,(BC)         ; {Point #REGhl at the corresponding location in the
       socb @bytes+15,a                ; OR 15             ; display file
       movb a,@l                       ; LD L,A            ; 
       inc  bc                         ; INC BC            ; 
       movb *bc,a                      ; LD A,(BC)         ;
       sb   @bytes+offset_s2_s,a       ; SUB 32            ;
       movb a,h                        ; LD H,A            ; }
       .push hl
       seto @caverns_0_6_bank_select
       li   de,boot                    ; LD DE,47840       ; {Draw the boot (see #R47840) at this location, without
       sb   @c,@c                      ; LD C,0            ; erasing the boot at the previous location; this leaves
       .call @draw_sprite              ; CALL 36852        ; the portion of the boot sprite that's above the ankle in
                                                           ; place, and makes the boot appear as if it's at the end
                                                           ; of a long, extending trouser leg}
       .pop r1
       andi r1,>f8ff
       .push r1
       li   r2,2
       bl   @upload_characters
       .pop r1
       bl   @next_row
       .push r1
       li   r2,2
       bl   @upload_characters
       .pop r1
       bl   @next_row
       li   r2,2
       bl   @upload_characters

       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the distance variable from #R32988
       inv  a                          ; CPL               ; #REGa=#b255-#REGa
       movb  a,r1
       bl   @play_note_ch_2
;      movb a,@e                       ; LD E,A            ; Store this value (#b63-#b255) in #REGe; it determines
;                                                          ; the (rising) pitch of the sound effect that will be made
;      sb   a,a                        ; XOR A             ; #REGa=0 (black border)
;      li   bc,64                      ; LD BC,64          ; #REGc=#b64; this value determines the duration of the
;                                                          ; sound effect
;tm111:                                ; 35242
;      OUT (254),A                     ; OUT (254),A       ; {Produce a short note whose pitch is determined by #REGe
;      li   r0,24*256                  ; XOR 24            ;
;      xor  r0,a                       ;
;      movb @e,b                       ; LD B,E            ;
;tm112:                                 ; 35247
;      sb   one,b                      ; DJNZ 35247        ;
;      jne  tm112                      ;
;      sb   one,@c                     ; DEC C             ;
;      jne  tm111                      ; JR NZ,35242       ; }

;      li   hl,zx_attrs                ; LD HL,22528       ; {Prepare #REGbc, #REGde and #REGhl for setting the
;      li   de,zx_attrs+1              ; LD DE,22529       ; attribute bytes in the top two-thirds of the screen
;      li   bc,511                     ; LD BC,511         ; }
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the distance variable from #R32988
       andi a,12*256                   ; AND 12            ; Keep only bits 2 and 3
       sla  a,1                        ; RLCA              ; Shift bits 2 and 3 into bits 3 and 4; these bits
                                                           ; determine the PAPER colour: 0, 1, 2 or 3
       socb @bytes+71,a                ; OR 71             ; Set bits 0-2 (INK 7) and 6 (BRIGHT 1)
;      movb a,*hl                      ; LD (HL),A         ; {Copy this attribute value into the top two-thirds of
;      .ldir                           ; LDIR              ; the screen}
       li   de,zx_attrs
       li   bc,512
       bl   @fill
       bl   @upload_top_middle_attributes

       movb @eughgt,a                  ; LD A,(32988)      ; {Add 4 to the distance variable at #R32988; this will
       ab   @bytes+4,a                 ; ADD A,4           ; move the boot sprite down two pixel rows
       movb a,@eughgt                  ; LD (32988),A      ; }
       cb   a,@bytes+196               ; CP 196            ; Has the boot met the plinth yet?
       jne  boot_loop                  ; JR NZ,35210       ; Jump back if not

       bl   @mute_sound

* Now print the "Game Over" message, just to drive the point home.
       li   ix,messg                   ; LD IX,33871       ; {Print "Game" (see #R33871) at (6,10)
       movb @bytes+4,@c                ; LD C,4            ; 
       li   de,zx_screen+202           ; LD DE,16586       ; 
       .call @pmess                    ; CALL 37562        ; }
       li   ix,messo                   ; LD IX,33875       ; {Print "Over" (see #R33875) at (6,18)
       movb @bytes+4,@c                ; LD C,4            ; 
       li   de,zx_screen+210           ; LD DE,16594       ; 
       .call @pmess                    ; CALL 37562        ; }
       bl   @upload_top_part
       li   bc,0                       ; LD BC,0           ; {Prepare the delay counters for the following loop; the
       movb @bytes+3,d                 ; LD D,6            ; counter in #REGc will also determine the INK colours to
                                                           ; use for the "Game Over" message}
* The following loop makes the "Game Over" message glisten for about 1.57s.
flash_game_over_loop:                  ; 35313
       sb   one,b                      ; DJNZ 35313        ; Delay for about a millisecond
       jne  flash_game_over_loop       ;
       movb @c,a                       ; LD A,C            ; {Change the INK colour of the "G" in "Game" at (6,10)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+202            ; LD (22730),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "a" in "Game" at (6,11)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+203            ; LD (22731),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "m" in "Game" at (6,12)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+204            ; LD (22732),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "e" in "Game" at (6,13)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+205            ; LD (22733),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "O" in "Over" at (6,18)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+210            ; LD (22738),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "v" in "Over" at (6,19)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+211            ; LD (22739),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "e" in "Over" at (6,20)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+212            ; LD (22740),A      ; }
       ab   one,a                      ; INC A             ; {Change the INK colour of the "r" in "Over" at (6,21)
       andi a,7*256                    ; AND 7             ; 
       socb @bytes+64,a                ; OR 64             ; 
       movb a,@zx_attrs+213            ; LD (22741),A      ; }

       li   r1,zx_attrs+202
       li   r2,12
       bl   @upload_attributes

       sb   one,@c                     ; DEC C             ; Decrement the counter in #REGc
       jne  flash_game_over_loop       ; JR NZ,35313       ; Jump back unless it's zero
       sb   one,d                      ; DEC D             ; Decrement the counter in #REGd (initially 6)
       jne  flash_game_over_loop       ; JR NZ,35313       ; Jump back unless it's zero

       b    @start                     ; JP 34252          ; Display the title screen and play the theme tune

* Decrease the air remaining in the current cavern
* 
* Used by the routines at #R34574, #R36211 and #R36904. Returns with the zero
* flag set if there is no air remaining.
dec_air:                                ; 35388
       movb @clock,a                   ; LD A,(32957)      ; {Update the game clock at #R32957
       sb   @bytes+4,a                 ; SUB 4             ; 
       movb a,@clock                   ; LD (32957),A      ; }
       cb   a,@bytes+252               ; CP 252            ; Was it just decreased from zero?
       jne  _35413                     ; JR NZ,35413       ; Jump if not
       movb @air,a                     ; LD A,(32956)      ; Pick up the value of the remaining air supply from
                                                           ; #R32956
       cb   a,@bytes+36                ; CP 36             ; Has the air supply run out?
       jne  !                          ; RET Z             ; Return (with the zero flag set) if so
       .ret_eq                         ;
!
       sb   one,a                      ; DEC A             ; {Decrement the air supply at #R32956
       movb a,@air                     ; LD (32956),A      ; }
       movb @clock,a                   ; LD A,(32957)      ; Pick up the value of the game clock at #R32957
_35413:
       andi a,224*256                  ; AND 224           ; {#REGa=INT(#REGa/32); this value specifies how many
;      sla  a,1                        ; RLCA              ; pixels to draw from left to right in the cell at the
;      sla  a,1                        ; RLCA              ; right end of the air bar
;      sla  a,1                        ; RLCA              ; }
       srl  a,5
       sb   @e,@e                      ; LD E,0            ; Initialise #REGe to 0 (all bits reset)
       socb a,a                        ; OR A              ; Do we need to draw any pixels in the cell at the right
                                                           ; end of the air bar?
       jeq  _35430                     ; JR Z,35430        ; Jump if not
       movb a,b                        ; LD B,A            ; Copy the number of pixels to draw (1-7) to #REGb
_35424:
       srl  de,1                       ; RRC E             ; {Set this many bits in #REGe (from bit 7 towards bit 0)
       socb @bits+7,@e                 ; SET 7,E           ; 
       sb   one,b                      ; DJNZ 35424        ; }
       jne  _35424                     ;                   
_35430:
       movb @air,a                     ; LD A,(32956)      ; Pick up the value of the remaining air supply from
                                                           ; #R32956
       movb a,@l                       ; LD L,A            ; {Set #REGhl to the display file address at which to draw
       movb @bytes+zx_screen_msb+18,h  ; LD H,82           ; the top row of pixels in the cell at the right end of
                                                           ; the air bar}
       movb @bytes+4,b                 ; LD B,4            ; There are four rows of pixels to draw
_35438:
       movb @e,*hl                     ; LD (HL),E         ; {Draw the four rows of pixels at the right end of the
       ab   one,h                      ; INC H             ; air bar
       sb   one,b                      ; DJNZ 35438        ; }
       jne  _35438                     ;

       mov  hl,r1
       andi r1,>f8ff
       bl   @upload_pattern

;      sb   a,a                        ; XOR A             ; {Reset the zero flag to indicate that there is still
;      ab   one,a                      ; INC A             ; some air remaining; these instructions are redundant,
                                                           ; since the zero flag is already reset at this point}
       .ret                            ; RET               ;

* Draw the current cavern to the screen buffer at #N28672
* 
* Used by the routine at #R34436.
draw_cavern:                           ; 35445
       li   ix,attr_buffer_1           ; LD IX,24064       ; Point #REGix at the first byte of the attribute buffer
                                                           ; at #R24064 attr_buffer_1
;       movb @bytes+112,a               ; LD A,112         ; {Set the operand of the '#S/LD D/,n' instruction at
;       movb a,@sbmsb+1                 ; LD (35484),A     ; #R35483 (below) to #n112}
       li   r0,bytes+scrn_buffer_1_msb
       mov  r0,@sbmsb+2
       .call @_35466                   ; CALL 35466        ; Draw the tiles for the top half of the cavern to the
                                                           ; screen buffer at #R28672 scrn_buffer_1
       li   ix,attr_buffer_1+256       ; LD IX,24320       ; Point #REGix at the 256th byte of the attribute buffer
                                                           ; at #R24064 attr_buffer_1 in preparation for drawing the bottom half of
                                                           ; the cavern; this instruction is redundant, since #REGix
                                                           ; already holds #N24320
;       movb @bytes+120,a               ; LD A,120         ; {Set the operand of the '#S/LD D/,n' instruction at
;       movb a,@sbmsb+1                 ; LD (35484),A     ; #R35483 (below) to #n120}
       li   r0,bytes+scrn_buffer_1_msb+8
       mov  r0,@sbmsb+2
_35466:
       sb   @c,@c                      ; LD C,0            ; #REGc will count 256 tiles
* The following loop draws 256 tiles (for either the top half or the bottom
* half of the cavern) to the screen buffer at #R28672 scrn_buffer_1.
_35468:
       movb @c,@e                      ; LD E,C            ; #REGe holds the LSB of the screen buffer address
       movb *ix,a                      ; LD A,(IX+0)       ; Pick up an attribute byte from the buffer at #R24064 attr_buffer_1;
                                                           ; this identifies the type of tile to draw
       li   hl,background              ; LD HL,32800       ; {Move #REGhl through the attribute bytes and graphic
       li   bc,8                       ; LD BC,72          ; data of the background, floor, crumbling floor, wall,
!      cb   a,*hl+                     ; CPIR              ; conveyor and nasty tiles starting at #R32800 until we
       jeq  !                                              ; find a byte that matches the attribute byte of the tile
       ai   hl,8                       ; We're actually only interested in checking every 9th byte, although the original checks them all.
       dec  bc                                             ; to be drawn}
       jne  -!
!
       movb @e,@c                      ; LD C,E            ; Restore the value of the tile counter in #REGc
       movb @bytes+8,b                 ; LD B,8            ; There are eight bytes in the tile
sbmsb:                                 ; 35483
       movb @bytes+0,d                 ; LD D,0            ; This instruction is set to either '#S/LD D/,#n112' or
                                                           ; '#S/LD D/,#n120' above; now #REGde holds the appropriate
                                                           ; address in the screen buffer at #R28672 scrn_buffer_1
_35485:
       movb *hl,a                      ; LD A,(HL)         ; {Copy the tile graphic data to the screen buffer at
       movb a,*de                      ; LD (DE),A         ; #R28672 scrn_buffer_1
       inc  hl                         ; INC HL            ; 
       ab   one,d                      ; INC D             ; 
       sb   one,b                      ; DJNZ 35485        ; }
       jne  _35485                     ;                   
       inc  ix                         ; INC IX            ; Move #REGix along to the next byte in the attribute
                                                           ; buffer
       ab   one,@c                     ; INC C             ; Have we drawn 256 tiles yet?
       jeq  !                          ; JP NZ,35468       ; If not, jump back to draw the next one
       b    @_35468                    ;                   
!
* The empty cavern has been drawn to the screen buffer at #R28672 scrn_buffer_1. If we're in
* #R64512(The Final Barrier), however, there is further work to do.
       movb @cavern,a                   ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   a,@bytes+19                ; CP 19             ; Is it #R64512(The Final Barrier)?
       jeq  !                          ; RET NZ            ; Return if not
       .ret                            ;                   
!
       seto @title_screen_bank_select
       li   hl,titlescr1               ; LD HL,40960       ; {Copy the graphic data from #R40960 to the top half of
       li   de,scrn_buffer_1           ; LD DE,28672       ; the screen buffer at #R28672 scrn_buffer_1
       li   bc,2048                    ; LD BC,2048        ;
;       .ldir                           ; LDIR              ; }
       bl   @copy
       .ret                            ; RET               ;

* Move Willy (1)
* 
* Used by the routine at #R34574. This routine deals with Willy if he's jumping
* or falling.
move_willy:                            ; 35515
       movb @airborne,a                ; LD A,(32875)      ; Pick up the airborne status indicator from #R32875
       cb   a,one                      ; CP 1              ; Is Willy jumping?
       jne  _35600                     ; JR NZ,35600       ; Jump if not
* Willy is currently jumping.
       movb @jumping,a                 ; LD A,(32878)      ; Pick up the jumping animation counter (0-17) from
                                                           ; #R32878
       szcb @bits+0,a                  ; RES 0,A           ; {Now -8<=#REGa<=8 (and #REGa is even)
       sb   @bytes+8,a                 ; SUB 8             ; }
       li   hl,willy_y                 ; LD HL,32872       ; {Adjust Willy's y-coordinate at #R32872 depending on
       ab   *hl,a                      ; ADD A,(HL)        ; where Willy is in the jump
       movb a,*hl                      ; LD (HL),A         ; }
       .call @calculate_location       ; CALL 35714        ; Adjust Willy's attribute buffer location at #R32876
                                                           ; depending on his y-coordinate
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
       cb   a,*hl                      ; CP (HL)           ; Is the top-left cell of Willy's sprite overlapping a
                                                           ; wall tile?
       jne  !                          ; JP Z,35746        ; Jump if so
       b    @_35746                    ;                   
!
       inc  hl                         ; INC HL            ; Point #REGhl at the top-right cell occupied by Willy's
                                                           ; sprite
       cb   a,*hl                      ; CP (HL)           ; Is the top-right cell of Willy's sprite overlapping a
                                                           ; wall tile?
       jne  !                          ; JP Z,35746        ; Jump if so
       b    @_35746                    ;                   
!
       movb @jumping,a                 ; LD A,(32878)      ; {Increment the jumping animation counter at #R32878
       ab   one,a                      ; INC A             ;
       movb a,@jumping                 ; LD (32878),A      ; }

       sb   @bytes+8,a                 ; SUB 8             ; #REGa=J-8, where J (1-18) is the new value of the
;                                                          ; jumping animation counter
;      jgt  _35563                     ; JP P,35563        ; Jump if J>=8
;      jeq  _35563
;      neg a                           ; NEG               ; #REGa=8-J (1<=J<=7, 1<=#REGa<=7)
;_35563:
       abs  a
       ab   one,a                      ; INC A             ; #REGa=1+ABS(J-8)
;      sla  a,1                        ; RLCA              ; {#REGd=8*(1+ABS(J-8)); this value determines the pitch
;      sla  a,1                        ; RLCA              ; of the jumping sound effect (rising as Willy rises,
;      sla  a,1                        ; RLCA              ; falling as Willy falls)
       sla  a,3
;      movb a,d                        ; LD D,A            ; }
;      movb @bytes+32,@c               ; LD C,32           ; This value determines the duration of the jumping sound
;                                                          ; effect
;      movb @border,a                  ; LD A,(32883)      ; Pick up the border colour for the current cavern from
;                                                          ; #R32883
       mov  a,r1
       bl   @play_note_ch_2
;_35573:
;      OUT (254),A                   ; OUT (254),A         ; {Make a jumping sound effect
;      li   r0,24*256                  ; XOR 24            ;
;      xor  r0,a                       ;
;      movb d,b                        ; LD B,D            ;
;_35578:
;      sb   one,b                      ; DJNZ 35578        ;
;      jne  _35578                     ;
;      sb   one,@c                     ; DEC C             ;
;      jne  _35573                     ; JR NZ,35573       ; }

       movb @jumping,a                 ; LD A,(32878)      ; Pick up the jumping animation counter (1-18) from
                                                           ; #R32878
       cb   a,@bytes+18                ; CP 18             ; Has Willy reached the end of the jump?
       jne  !                          ; JP Z,35734        ; Jump if so
       bl   @mute_sound
       b    @_35734                    ;                   
!
       cb   a,@bytes+16                ; CP 16             ; Is the jumping animation counter now 16?
       jeq  _35600                     ; JR Z,35600        ; Jump if so
       cb   a,@bytes+13                ; CP 13             ; Is the jumping animation counter now 13?
       jeq  !                          ; JP NZ,35971       ; Jump if not
       b    @_35971                    ;                   
!
* If we get here, then Willy is standing on the floor, or he's falling, or his
* jumping animation counter is 13 (at which point Willy is on his way down and
* is exactly two cell-heights above where he started the jump) or 16 (at which
* point Willy is on his way down and is exactly one cell-height above where he
* started the jump).
_35600:
       movb @willy_y,a                 ; LD A,(32872)      ; Pick up Willy's y-coordinate from #R32872
       andi a,15*256                   ; AND 15            ; Does Willy's sprite occupy six cells at the moment?
       jne  _35665                     ; JR NZ,35665       ; Jump if so
       movb @location+1,h              ; LD HL,(32876)     ; Pick up Willy's attribute buffer coordinates from
       movb @location,@l                                   ; #R32876
       li   de,64                      ; LD DE,64          ; {Point #REGhl at the left-hand cell below Willy's sprite
       a    de,hl                      ; ADD HL,DE         ; }
       movb @crumbling,a               ; LD A,(32818)      ; Pick up the attribute byte of the crumbling floor tile
                                                           ; for the current cavern from #R32818
       cb   a,*hl                      ; CP (HL)           ; Does the left-hand cell below Willy's sprite contain a
                                                           ; crumbling floor tile?
       jne  !                          ; CALL Z,35770      ; If so, make it crumble
       .call @crumble                  ;
       bl   @add_tile_update
!
       movb @nasty1,a                  ; LD A,(32845)      ; Pick up the attribute byte of the first nasty tile for
                                                           ; the current cavern from #R32845
       cb   a,*hl                      ; CP (HL)           ; Does the left-hand cell below Willy's sprite contain a
                                                           ; nasty tile?
       jeq  _35665                     ; JR Z,35665        ; Jump if so
       movb @nasty2,a                  ; LD A,(32854)      ; Pick up the attribute byte of the second nasty tile for
                                                           ; the current cavern from #R32854
       cb   a,*hl                      ; CP (HL)           ; Does the left-hand cell below Willy's sprite contain a
                                                           ; nasty tile?
       jeq  _35665                     ; JR Z,35665        ; Jump if so
       inc  hl                         ; INC HL            ; Point #REGhl at the right-hand cell below Willy's sprite
       movb @crumbling,a               ; LD A,(32818)      ; Pick up the attribute byte of the crumbling floor tile
                                                           ; for the current cavern from #R32818
       cb   a,*hl                      ; CP (HL)           ; Does the right-hand cell below Willy's sprite contain a
                                                           ; crumbling floor tile?
       jne  !                          ; CALL Z,35770      ; If so, make it crumble
       .call @crumble                  ;                   
       bl   @add_tile_update
!
       movb @nasty1,a                  ; LD A,(32845)      ; Pick up the attribute byte of the first nasty tile for
                                                           ; the current cavern from #R32845
       cb   a,*hl                      ; CP (HL)           ; Does the right-hand cell below Willy's sprite contain a
                                                           ; nasty tile?
       jeq  _35665                     ; JR Z,35665        ; Jump if so
       movb @nasty2,a                  ; LD A,(32854)      ; Pick up the attribute byte of the second nasty tile for
                                                           ; the current cavern from #R32854
       cb   a,*hl                      ; CP (HL)           ; Does the right-hand cell below Willy's sprite contain a
                                                           ; nasty tile?
       jeq  _35665                     ; JR Z,35665        ; Jump if so
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       movb *hl,r0
;      cb   a,*hl                      ; CP (HL)           ; Set the zero flag if the right-hand cell below Willy's
                                                           ; sprite is empty
       dec  hl                         ; DEC HL            ; Point #REGhl at the left-hand cell below Willy's sprite
       cb   a,r0
       jeq  !                          ; JP NZ,35805       ; Jump if the right-hand cell below Willy's sprite is not
       b    @move_willy_2              ;
!
                                                           ; empty
       cb   a,*hl                      ; CP (HL)           ; Is the left-hand cell below Willy's sprite empty?
       jeq  !                          ; JP NZ,35805       ; Jump if not
       b    @move_willy_2              ;
!
_35665:
       movb @airborne,a                ; LD A,(32875)      ; Pick up the airborne status indicator from #R32875
       cb   a,one                      ; CP 1              ; Is Willy jumping?
       jne  !                          ; JP Z,35971        ; Jump if so
       b    @_35971                    ;                   
!
* If we get here, then Willy is either in the process of falling or just about
* to start falling.
       li   hl,dmflags                 ; LD HL,32874       ; {Reset bit 1 at #R32874: Willy is not moving left or
       szcb @bits+1,*hl                ; RES 1,(HL)        ; right}
       socb a,a                        ; OR A              ; Is Willy already falling?
       jne  !                          ; JP Z,35740        ; Jump if not
       b    @_35740                    ;                   
!
       ab   one,a                      ; INC A             ; {Increment the airborne status indicator at #R32875
       movb a,@airborne                ; LD (32875),A      ; }

;      sla  a,1                        ; RLCA              ; {The value of #REGd determines the pitch of the falling
;      sla  a,1                        ; RLCA              ; sound effect
;      sla  a,1                        ; RLCA              ;
;      sla  a,1                        ; RLCA              ;
       sla  a,4
       movb a,r1
       bl   @play_note_ch_2
;       movb a,d                        ; LD D,A            ; }
;       movb @bytes+32,@c               ; LD C,32           ; This value determines the duration of the falling sound
;                                                           ; effect
;       movb @border,a                  ; LD A,(32883)      ; Pick up the border colour for the current cavern from
;                                                           ; #R32883
;_35696:
;       ; OUT (254),A                   ; OUT (254),A       ; {Make a falling sound effect
;       li   r0,24*256                  ; XOR 24            ;
;       xor  r0,a                       ;
;       movb d,b                        ; LD B,D            ;
;_35701:
;       sb   one,b                      ; DJNZ 35701        ;
;       jne  _35701                     ;
;       sb   one,@c                     ; DEC C             ;
;       jne  _35696                     ; JR NZ,35696       ; }

       movb @willy_y,a                 ; LD A,(32872)      ; {Add 8 to Willy's y-coordinate at #R32872; this moves
       ab   @bytes+8,a                 ; ADD A,8           ; Willy downwards by 4 pixels
       movb a,@willy_y                 ; LD (32872),A      ; }

calculate_location:
       andi a,240*256                  ; AND 240           ; {#REGl=16*Y, where Y is Willy's screen y-coordinate
       movb a,@l                       ; LD L,A            ; (0-14)}
       sb   a,a                        ; XOR A             ; Clear #REGa and the carry flag
       clr  r0
       movb @l,r0
       sla  r0,1                       ; RL L              ; Now #REGl=32*(Y-8*INT(Y/8)), and the carry flag is set
       jnc  !                                              ; if Willy is in the lower half of the cavern (Y>=8)
       ab   one,a
!      ab   @bytes+attr_buffer_2_msb,a ; ADC A,92       ; {#REGh=#b92 or #b93 (MSB of the address of Willy's
       movb r0,@l
       movb a,h                        ; LD H,A            ; location in the attribute buffer)}
       movb @location,a                ; LD A,(32876)      ; {Pick up Willy's screen x-coordinate (1-29) from bits
       andi a,31*256                   ; AND 31            ; 0-4 at #R32876}
       socb @l,a                       ; OR L              ; {Now #REGl holds the LSB of Willy's attribute buffer
       movb a,@l                       ; LD L,A            ; address}
       movb h,@location+1              ; LD (32876),HL     ; Store Willy's updated attribute buffer location at
       movb @l,@location                                   ; #R32876
       .ret                            ; RET               ; 
* Willy has just finished a jump.
_35734:
       movb @bytes+6,a                 ; LD A,6            ; {Set the airborne status indicator at #R32875 to #b6:
       movb a,@airborne                ; LD (32875),A      ; Willy will continue to fall unless he's landed on a wall
                                                           ; or floor block}
       .ret                            ; RET               ; 
* Willy has just started falling.
_35740:
       movb @bytes+2,a                 ; LD A,2            ; {Set the airborne status indicator at #R32875 to #b2
       movb a,@airborne                ; LD (32875),A      ; }
       .ret                            ; RET               ; 
* The top-left or top-right cell of Willy's sprite is overlapping a wall tile.
_35746:
       movb @willy_y,a                 ; LD A,(32872)      ; {Adjust Willy's y-coordinate at #R32872 so that the top
       ab   @bytes+16,a                ; ADD A,16          ; row of cells of his sprite is just below the wall tile
       andi a,240*256                  ; AND 240           ; 
       movb a,@willy_y                 ; LD (32872),A      ; }
       .call @calculate_location       ; CALL 35714        ; Adjust Willy's attribute buffer location at #R32876 to
                                                           ; account for this new y-coordinate
       movb @bytes+2,a                 ; LD A,2            ; {Set the airborne status indicator at #R32875 to #b2:
       movb a,@airborne                ; LD (32875),A      ; Willy has started falling}
       li   hl,dmflags                 ; LD HL,32874       ; {Reset bit 1 at #R32874: Willy is not moving left or
       szcb @bits+1,*hl                ; RES 1,(HL)        ; right}
       .ret                            ; RET               ; 

* Animate a crumbling floor tile in the current cavern
* 
* Used by the routine at #R35515.
* 
* HL Address of the crumbling floor tile's location in the attribute buffer at
* .  #R23552 attr_buffer_2
*
* attr_buffer_2 5C00
* scrn_buffer_1 7000
*  top bottom
*  5C00  5D00
* +1B00 +1B00
*  7700  7800
* |0700 |0700
*  7700  7F00 = bottom row
*
crumble:                               ; 35770
       movb @l,@c                      ; LD C,L            ; {Point #REGbc at the bottom row of pixels of the
       movb h,a                        ; LD A,H            ; crumbling floor tile in the screen buffer at #R28672 scrn_buffer_1
       ab   @bytes+offset_s1_a2+7,a    ; ADD A,27
       socb @bytes+7,a                 ; OR 7              ;
       movb a,b                        ; LD B,A            ; }
_35777:
       sb   one,b                      ; DEC B             ; {Collect the pixels from the row above in #REGa
       movb *bc,a                      ; LD A,(BC)         ; }
       ab   one,b                      ; INC B             ; {Copy these pixels into the row below it
       movb a,*bc                      ; LD (BC),A         ; }
       sb   one,b                      ; DEC B             ; Point #REGbc at the next row of pixels up
       movb b,a                        ; LD A,B            ; {Have we dealt with the bottom seven pixel rows of the
       andi a,7*256                    ; AND 7             ; crumbling floor tile yet?}
       jne  _35777                     ; JR NZ,35777       ; If not, jump back to deal with the next one up
       mov  bc,r1
       bl   @add_tile_update
       sb   a,a                        ; XOR A             ; {Clear the top row of pixels in the crumbling floor tile
       movb a,*bc                      ; LD (BC),A         ; }
       movb b,a                        ; LD A,B            ; {Point #REGbc at the bottom row of pixels in the
       ab   @bytes+7,a                 ; ADD A,7           ; crumbling floor tile
       movb a,b                        ; LD B,A            ; }
       movb *bc,a                      ; LD A,(BC)         ; Pick up the bottom row of pixels in #REGa
;      socb a,a                        ; OR A              ; Is the bottom row clear?
       jeq  !                          ; RET NZ            ; Return if not
       .ret                            ;                   
!
* The bottom row of pixels in the crumbling floor tile is clear. Time to put a
* background tile in its place.
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
;      ab   one,h                      ; INC H             ; {Set #REGhl to the address of the crumbling floor tile's
;      ab   one,h                      ; INC H             ; location in the attribute buffer at #R24064 attr_buffer_1}
       ai   hl,attr_buffer_1-attr_buffer_2
       movb a,*hl                      ; LD (HL),A         ; Set the attribute at this location to that of the
                                                           ; background tile
;      sb   one,h                      ; DEC H             ; {Set #REGhl back to the address of the crumbling floor
;      sb   one,h                      ; DEC H             ; tile's location in the attribute buffer at #R23552 attr_buffer_2}
       ai   hl,attr_buffer_2-attr_buffer_1
       .ret                            ; RET               ;

* Move Willy (2)
* 
* Used by the routine at #R35515. This routine checks the keyboard and
* joystick, and moves Willy left or right if necessary.
* 
* HL Attribute buffer address of the left-hand cell below Willy's sprite
move_willy_2:                          ; 35805
       movb @airborne,a                ; LD A,(32875)      ; Pick up the airborne status indicator from #R32875
       jeq  !
       bl   @mute_sound
       cb   a,@bytes+12                ; CP 12             ; Has Willy just landed after falling from too great a
                                                           ; height?
       jl   !                          ; JP NC,36102       ; If so, kill him
       .ifeq can_die,1
       b    @kill_willy_2              ;
       .else
       nop
       .endif
!
       movb @b255,@e                   ; LD E,255          ; Initialise #REGe to #b255 (all bits set); it will be
                                                           ; used to hold keyboard and joystick readings
       sb   a,a                        ; XOR A             ; {Reset the airborne status indicator at #R32875 (Willy
       movb a,@airborne                ; LD (32875),A      ; has landed safely)}
       movb @conveyor,a                ; LD A,(32836)      ; Pick up the attribute byte of the conveyor tile for the
                                                           ; current cavern from #R32836
       cb   a,*hl                      ; CP (HL)           ; Does the attribute byte of the left-hand cell below
                                                           ; Willy's sprite match that of the conveyor tile?
       jeq  _35829                     ; JR Z,35829        ; Jump if so
       inc  hl                         ; INC HL            ; Point #REGhl at the right-hand cell below Willy's sprite
       cb   a,*hl                      ; CP (HL)           ; Does the attribute byte of the right-hand cell below
                                                           ; Willy's sprite match that of the conveyor tile?
       jne  _35835                     ; JR NZ,35835       ; Jump if not
_35829:
       movb @convdir,a                 ; LD A,(32879)      ; Pick up the direction byte of the conveyor definition
                                                           ; from #R32879 (0=left, 1=right)
       sb   @bytes+3,a                 ; SUB 3             ; {Now #REGe=#b253 (bit 1 reset) if the conveyor is moving
       movb a,@e                       ; LD E,A            ; left, or #b254 (bit 0 reset) if it's moving right}
_35835:

;       li   bc,57432                   ; LD BC,57342       ; {Read keys P-O-I-U-Y (right, left, right, left, right)
;       ; IN A,(C)                      ; IN A,(C)          ; into bits 0-4 of #REGa}
;       andi a,31*256                   ; AND 31            ; {Set bit 5 and reset bits 6 and 7
;       socb @bytes+32,a                ; OR 32             ; }
;       ; AND E                         ; AND E             ; Reset bit 0 if the conveyor is moving right, or bit 1 if
;                                                           ; it's moving left
;       movb a,@e                       ; LD E,A            ; Save the result in #REGe
;       li   bc,64510                   ; LD BC,64510       ; {Read keys Q-W-E-R-T (left, right, left, right, left)
;       ; IN A,(C)                      ; IN A,(C)          ; into bits 0-4 of #REGa}
;       andi a,31*256                   ; AND 31            ; {Keep only bits 0-4, shift them into bits 1-5, and set
;       sla  a,1                        ; RLC A             ; bit 0
;       socb one,a                      ; OR 1              ; }
;       ; AND E                         ; AND E             ; {Merge this keyboard reading into bits 1-5 of #REGe
;       movb a,@e                       ; LD E,A            ; }
;       movb @bytes+247,b               ; LD B,247          ; {Read keys 1-2-3-4-5 ('5' is left) into bits 0-4 of
;       ; IN A,(C)                      ; IN A,(C)          ; #REGa}
;       srl  a,1                        ; RRCA              ; {Rotate the result right and set bits 0-2 and 4-7; this
;       socb @bytes+247,a               ; OR 247            ; ignores every key except '5' (left)}
;       ; AND E                         ; AND E             ; {Merge this reading of the '5' key into bit 3 of #REGe
;       movb a,@e                       ; LD E,A            ; }
;       movb @bytes+239,b               ; LD B,239          ; {Read keys 0-9-8-7-6 ('8' is right) into bits 0-4 of
;       ; IN A,(C)                      ; IN A,(C)          ; #REGa}
;       socb @bytes+251,a               ; OR 251            ; Set bits 0, 1 and 3-7; this ignores every key except '8'
;                                                           ; (right)
;       ; AND E                         ; AND E             ; {Merge this reading of the '8' key into bit 2 of #REGe
;       movb a,@e                       ; LD E,A            ; }
;       movb @kemp,a                    ; LD A,(33881)      ; Collect the Kempston joystick indicator from #R33881
;;      socb a,a                        ; OR A              ; Is the joystick connected?
;       jeq  _35892                     ; JR Z,35892        ; Jump if not
;       li   bc,31                      ; LD BC,31          ; {Collect input from the joystick
;       ; IN A,(C)                      ; IN A,(C)          ; }
;       andi a,3*256                    ; AND 3             ; {Keep only bits 0 (right) and 1 (left) and flip them
;       inv  a                          ; CPL               ; }
;       ; AND E                         ; AND E             ; {Merge this reading of the joystick right and left
;       movb a,@e                       ; LD E,A            ; buttons into bits 0 and 1 of #REGe}

       li   r0,JOY_LT
       bl   @ti_check_key
       jne  !
       li   r0,KEY_S
       bl   @ti_check_key
       jeq  !!
!      li   a,>2a00
       szcb a,@e
!      li   r0,JOY_RT
       bl   @ti_check_key
       jne  !
       li   r0,KEY_D
       bl   @ti_check_key
       jeq  !!
!      li   a,>1500
       szcb a,@e
!

* At this point, bits 0-5 in #REGe indicate the direction in which Willy is
* being moved or trying to move. If bit 0, 2 or 4 is reset, Willy is being
* moved or trying to move right; if bit 1, 3 or 5 is reset, Willy is being
* moved or trying to move left.
_35892:
       sb   @c,@c                      ; LD C,0            ; Initialise #REGc to 0 (no movement)
       movb @e,a                       ; LD A,E            ; Copy the movement bits into #REGa
       andi a,42*256                   ; AND 42            ; Keep only bits 1, 3 and 5 (the 'left' bits)
       cb   a,@bytes+42                ; CP 42             ; Are any of these bits reset?
       jeq  _35903                     ; JR Z,35903        ; Jump if not
       movb @bytes+4,@c                ; LD C,4            ; Set bit 2 of #REGc: Willy is moving left
_35903:
       movb @e,a                       ; LD A,E            ; Copy the movement bits into #REGa
       andi a,21*256                   ; AND 21            ; Keep only bits 0, 2 and 4 (the 'right' bits)
       cb   a,@bytes+21                ; CP 21             ; Are any of these bits reset?
       jeq  _35912                     ; JR Z,35912        ; Jump if not
       socb @bits+3,@c                 ; SET 3,C           ; Set bit 3 of #REGc: Willy is moving right
_35912:
;      movb @dmflags,a                 ; LD A,(32874)      ; Pick up Willy's direction and movement flags from
;                                                          ; #R32874
;      ab   @c,a                       ; ADD A,C           ; {Point #REGhl at the entry in the left-right movement
;      movb a,@c                       ; LD C,A            ; table at #R33800 that corresponds to the direction Willy
       ab   @dmflags,@c
       sb   b,b                        ; LD B,0            ; is facing, and the direction in which he is being moved
;      andi bc,15
       li   hl,lrmovement              ; LD HL,33800       ; or trying to move
       a    bc,hl                      ; ADD HL,BC         ; }
       movb *hl,a                      ; LD A,(HL)         ; {Update Willy's direction and movement flags at #R32874
       movb a,@dmflags                 ; LD (32874),A      ; with the entry from the left-right movement table}
* That is left-right movement taken care of. Now check the jump keys.

;       li   bc,32510                   ; LD BC,32510       ; {Read keys SHIFT-Z-X-C-V and B-N-M-SS-SPACE
;       ; IN A,(C)                      ; IN A,(C)          ; }
;       andi a,31*256                   ; AND 31            ; {Are any of these keys being pressed?
;       cb   a,@bytes+31                ; CP 31             ; }
;       jne  _35963                     ; JR NZ,35963       ; Jump if so
;       movb @bytes+239,b               ; LD B,239          ; {Read keys 0-9-8-7-6 into bits 0-4 of #REGa
;       ; IN A,(C)                      ; IN A,(C)          ; }
;       andi a,9*256                    ; AND 9             ; Keep only bits 0 (the '0' key) and 3 (the '7' key)
;       cb   a,@bytes+9                 ; CP 9              ; Is '0' or '7' being pressed?
;       jne  _35963                     ; JR NZ,35963       ; Jump if so
;       movb @kemp,a                    ; LD A,(33881)      ; Collect the Kempston joystick indicator from #R33881
;;      socb a,a                        ; OR A              ; Is the joystick connected?
;       jeq  _35971                     ; JR Z,35971        ; Jump if not
;       li   bc,31                      ; LD BC,31          ; {Collect input from the joystick
;       ; IN A,(C)                      ; IN A,(C)          ; }
;       movb a,r0                       ; BIT 4,A           ; Is the fire button being pressed?
;       andi r0,16*256                  ;
;       jeq  _35971                     ; JR Z,35971        ; Jump if not

       li   r0,JOY_FI
       bl   @ti_check_key
       jne  _35963
       li   r0,KEY_EN
       bl   @ti_check_key
       jeq  _35971

* A jump key or the fire button is being pressed. Time to make Willy jump.
_35963:
       sb   a,a                        ; XOR A             ; {Initialise the jumping animation counter at #R32878
       movb a,@jumping                 ; LD (32878),A      ; }
       ab   one,a                      ; INC A             ; {Set the airborne status indicator at #R32875 to 1:
       movb a,@airborne                ; LD (32875),A      ; Willy is jumping}
* This entry point is used by the routine at #R35515.
_35971:
       movb @dmflags,a                 ; LD A,(32874)      ; Pick up Willy's direction and movement flags from
                                                           ; #R32874
       andi a,2*256                    ; AND 2             ; Is Willy moving?
       jne  !                          ; RET Z             ; Return if not
       .ret                            ;                   
!
       movb @dmflags,a                 ; LD A,(32874)      ; Pick up Willy's direction and movement flags from
                                                           ; #R32874
       andi a,1*256                    ; AND 1             ; Is Willy facing right?
       jne  !                          ; JP Z,36042        ; Jump if so
       b    @_36042                    ;                   
!
**
* Willy is moving left.
       movb @frame,a                   ; LD A,(32873)      ; Pick up Willy's animation frame from #R32873
;      socb a,a                        ; OR A              ; Is it 0?
       jeq  _35996                     ; JR Z,35996        ; If so, jump to move Willy's sprite left across a cell
                                                           ; boundary
       sb   one,a                      ; DEC A             ; {Decrement Willy's animation frame at #R32873
       movb a,@frame                   ; LD (32873),A      ; }
       .ret                            ; RET               ; 
* Willy's sprite is moving left across a cell boundary. In the comments that
* follow, (x,y) refers to the coordinates of the top-left cell currently
* occupied by Willy's sprite.
_35996:
       movb @location+1,h              ; LD HL,(32876)     ; Collect Willy's attribute buffer coordinates from
       movb @location,@l                                   ; #R32876
       dec  hl                         ; DEC HL            ; {Point #REGhl at the cell at (x-1,y+1)
       li   de,32                      ; LD DE,32          ; 
       a    de,hl                      ; ADD HL,DE         ; }
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
       cb   a,*hl                      ; CP (HL)           ; Is there a wall tile in the cell pointed to by #REGhl?
       jne  !                          ; RET Z             ; Return if so without moving Willy (his path is blocked)
       .ret                            ;                   
!
       movb @willy_y,a                 ; LD A,(32872)      ; Pick up Willy's y-coordinate from #R32872
       andi a,15*256                   ; AND 15            ; Does Willy's sprite currently occupy only two rows of
                                                           ; cells?
       jeq  _36025                     ; JR Z,36025        ; Jump if so
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
       a    de,hl                      ; ADD HL,DE         ; Point #REGhl at the cell at (x-1,y+2)
       cb   a,*hl                      ; CP (HL)           ; Is there a wall tile in the cell pointed to by #REGhl?
       jne  !                          ; RET Z             ; Return if so without moving Willy (his path is blocked)
       .ret                            ;                   
!
;      socb a,a                        ; OR A              ; Clear the carry flag for subtraction
       s    de,hl                      ; SBC HL,DE         ; Point #REGhl at the cell at (x-1,y+1)
_36025:
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
;      socb a,a                        ; OR A              ; Clear the carry flag for subtraction
       s    de,hl                      ; SBC HL,DE         ; Point #REGhl at the cell at (x-1,y)
       cb   a,*hl                      ; CP (HL)           ; Is there a wall tile in the cell pointed to by #REGhl?
       jne  !                          ; RET Z             ; Return if so without moving Willy (his path is blocked)
       .ret                            ;                   
!
       movb h,@location+1              ; LD (32876),HL     ; Save Willy's new attribute buffer coordinates (in
       movb @l,@location                                   ; #REGhl) at #R32876
       movb @bytes+3,a                 ; LD A,3            ; {Change Willy's animation frame at #R32873 from 0 to 3
       movb a,@frame                   ; LD (32873),A      ; }
       .ret                            ; RET               ; 
**
* Willy is moving right.
_36042:
       movb @frame,a                   ; LD A,(32873)      ; Pick up Willy's animation frame from #R32873
       cb   a,@bytes+3                 ; CP 3              ; Is it 3?
       jeq  _36054                     ; JR Z,36054        ; If so, jump to move Willy's sprite right across a cell
                                                           ; boundary
       ab   one,a                      ; INC A             ; {Increment Willy's animation frame at #R32873
       movb a,@frame                   ; LD (32873),A      ; }
       .ret                            ; RET               ; 
* Willy's sprite is moving right across a cell boundary. In the comments that
* follow, (x,y) refers to the coordinates of the top-left cell currently
* occupied by Willy's sprite.
_36054:
       movb @location+1,h              ; LD HL,(32876)     ; Collect Willy's attribute buffer coordinates from
       movb @location,@l                                   ; #R32876
       inc  hl                         ; INC HL            ; {Point #REGhl at the cell at (x+2,y)
       inc  hl                         ; INC HL            ; }
       li   de,32                      ; LD DE,32          ; Prepare #REGde for addition
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
       a    de,hl                      ; ADD HL,DE         ; Point #REGhl at the cell at (x+2,y+1)
       cb   a,*hl                      ; CP (HL)           ; Is there a wall tile in the cell pointed to by #REGhl?
       jne  !                          ; RET Z             ; Return if so without moving Willy (his path is blocked)
       .ret                            ;                   
!
       movb @willy_y,a                 ; LD A,(32872)      ; Pick up Willy's y-coordinate from #R32872
       andi a,15*256                   ; AND 15            ; Does Willy's sprite currently occupy only two rows of
                                                           ; cells?
       jeq  _36084                     ; JR Z,36084        ; Jump if so
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
       a    de,hl                      ; ADD HL,DE         ; Point #REGhl at the cell at (x+2,y+2)
       cb   a,*hl                      ; CP (HL)           ; Is there a wall tile in the cell pointed to by #REGhl?
       jne  !                          ; RET Z             ; Return if so without moving Willy (his path is blocked)
       .ret                            ;                   
!
;      socb a,a                        ; OR A              ; Clear the carry flag for subtraction
       s    de,hl                      ; SBC HL,DE         ; Point #REGhl at the cell at (x+2,y+1)
_36084:
       movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; current cavern from #R32827
;      socb a,a                        ; OR A              ; Clear the carry flag for subtraction
       s    de,hl                      ; SBC HL,DE         ; Point #REGhl at the cell at (x+2,y)
       cb   a,*hl                      ; CP (HL)           ; Is there a wall tile in the cell pointed to by #REGhl?
       jne  !                          ; RET Z             ; Return if so without moving Willy (his path is blocked)
       .ret                            ;                   
!
       dec  hl                         ; DEC HL            ; Point #REGhl at the cell at (x+1,y)
       movb h,@location+1              ; LD (32876),HL     ; Save Willy's new attribute buffer coordinates (in
       movb @l,@location                                   ; #REGhl) at #R32876
       sb   a,a                        ; XOR A             ; {Change Willy's animation frame at #R32873 from 3 to 0
       movb a,@frame                   ; LD (32873),A      ; }
       .ret                            ; RET               ; 

* Kill Willy
* 
* Used by the routine at #R37471 when Willy hits a nasty.
kill_willy_1:                          ; 36101
       .pop hl                         ; POP HL            ; Drop the return address from the stack
* This entry point is used by the routines at #R35805 (when Willy lands after
* falling from too great a height), #R36266 (when Willy collides with a
* horizontal guardian), #R36344 (when Willy collides with Eugene), #R36593
* (when Willy collides with a vertical guardian) and #R37173 (when Willy
* collides with the Kong Beast).
kill_willy_2:
       .pop hl                         ; POP HL            ; Drop the return address from the stack
* This entry point is used by the routine at #R36469 when a Skylab falls on
* Willy.
kill_willy_3:
       movb @b255,a                    ; LD A,255          ; {Set the airborne status indicator at #R32875 to #b255
       movb a,@airborne                ; LD (32875),A      ; (meaning Willy has had a fatal accident)}
       b    @return_from_kill_willy    ; JP 34722          ; Jump back into the main loop

* Move the horizontal guardians in the current cavern
* 
* Used by the routine at #R34574.
move_hguardians:                       ; 36111
       li   iy,hguards                 ; LD IY,32958       ; Point #REGiy at the first byte of the first horizontal
                                                           ; guardian definition at #R32958
       li   de,7                       ; LD DE,7           ; Prepare #REGde for addition (there are 7 bytes in a
                                                           ; guardian definition)
* The guardian-moving loop begins here.
_36118:
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the first byte of the guardian definition
       cb   a,@b255                    ; CP 255            ; Have we dealt with all the guardians yet?
       jne  !                          ; RET Z             ; Return if so
       .ret                            ;                   
!
       socb a,a                        ; OR A              ; Is this guardian definition blank?
       jeq  _36207                     ; JR Z,36207        ; If so, skip it and consider the next one
       movb @clock,a                   ; LD A,(32957)      ; Pick up the value of the game clock at #R32957
       andi a,4*256                    ; AND 4             ; {Move bit 2 (which is toggled on each pass through the
;      srl  a,1                        ; RRCA              ; main loop) to bit 7 and clear all the other bits
;      srl  a,1                        ; RRCA              ;
;      srl  a,1                        ; RRCA              ; }
       sla  a,5
       movb *iy,r0                     ; AND (IY+0)        ; Combine this bit with bit 7 of the first byte of the
       inv  r0                                             ; guardian definition, which specifies the guardian's
       szcb r0,a                                           ; animation speed: 0=normal, 1=slow
       jne  _36207                     ; JR NZ,36207       ; Jump to consider the next guardian if this one is not
                                                           ; due to be moved on this pass
* The guardian will be moved on this pass.
       movb @4(iy),a                   ; LD A,(IY+4)       ; Pick up the current animation frame (0-7)
       cb   a,@bytes+3                 ; CP 3              ; Is it 3 (the terminal frame for a guardian moving
                                                           ; right)?
       jeq  _36163                     ; JR Z,36163        ; Jump if so to move the guardian right across a cell
                                                           ; boundary or turn it round
       cb   a,@bytes+4                 ; CP 4              ; Is the current animation frame 4 (the terminal frame for
                                                           ; a guardian moving left)?
       jeq  _36186                     ; JR Z,36186        ; Jump if so to move the guardian left across a cell
                                                           ; boundary or turn it round
       jhe  _36158                     ; JR NC,36158       ; Jump if the animation frame is 5, 6 or 7
       ab   one,@4(iy)                 ; INC (IY+4)        ; Increment the animation frame (this guardian is moving
                                                           ; right)
       jmp  _36207                     ; JR 36207          ; Jump forward to consider the next guardian
_36158:
       sb   one,@4(iy)                 ; DEC (IY+4)        ; Decrement the animation frame (this guardian is moving
                                                           ; left)
       jmp  _36207                     ; JR 36207          ; Jump forward to consider the next guardian
_36163:
       movb @1(iy),a                   ; LD A,(IY+1)       ; Pick up the LSB of the address of the guardian's
                                                           ; location in the attribute buffer at #R23552 attr_buffer_2
       cb   a,@6(iy)                   ; CP (IY+6)         ; Has the guardian reached the rightmost point in its
                                                           ; path?
       jne  _36177                     ; JR NZ,36177       ; Jump if not
       movb @bytes+7,@4(iy)            ; LD (IY+4),7       ; Set the animation frame to 7 (turning the guardian round
                                                           ; to face left)
       jmp  _36207                     ; JR 36207          ; Jump forward to consider the next guardian
_36177:
       sb   @4(iy),@4(iy)              ; LD (IY+4),0       ; Set the animation frame to 0 (the initial frame for a
                                                           ; guardian moving right)
       ab   one,@1(iy)                 ; INC (IY+1)        ; Increment the guardian's x-coordinate (moving it right
                                                           ; across a cell boundary)
       jmp  _36207                     ; JR 36207          ; Jump forward to consider the next guardian
_36186:
       movb @1(iy),a                   ; LD A,(IY+1)       ; Pick up the LSB of the address of the guardian's
                                                           ; location in the attribute buffer at #R23552 attr_buffer_2
       cb   a,@5(iy)                   ; CP (IY+5)         ; Has the guardian reached the leftmost point in its path?
       jne  _36200                     ; JR NZ,36200       ; Jump if not
       sb   @4(iy),@4(iy)              ; LD (IY+4),0       ; Set the animation frame to 0 (turning the guardian round
                                                           ; to face right)
       jmp  _36207                     ; JR 36207          ; Jump forward to consider the next guardian
_36200:
       movb @bytes+7,@4(iy)            ; LD (IY+4),7       ; Set the animation frame to 7 (the initial frame for a
                                                           ; guardian moving left)
       sb   one,@1(iy)                 ; DEC (IY+1)        ; Decrement the guardian's x-coordinate (moving it left
                                                           ; across a cell boundary)
* The current guardian definition has been dealt with. Time for the next one.
_36207:
       a    de,iy                      ; ADD IY,DE         ; Point #REGiy at the first byte of the next horizontal
                                                           ; guardian definition
       jmp  _36118                     ; JR 36118          ; Jump back to deal with the next horizontal guardian

* Move and draw the light beam in Solar Power Generator
* 
* Used by the routine at #R34574.
lightbeam:                             ; 36211
*      Undraw the old light beam
       li   r0,light_beam_attr_addrs
       mov  r0,@light_beam_attr_addrs_ptr
lightbeam_1:
       mov  *r0+,r1
       jeq  lightbeam_2
       bl   @upload_attribute
       jmp  lightbeam_1
*      Draw the new beam
lightbeam_2:
       li   hl,attr_buffer_2+23        ; LD HL,23575       ; Point #REGhl at the cell at (0,23) in the attribute
                                                           ; buffer at #R23552 attr_buffer_2 (the source of the light beam)
       li   de,32                      ; LD DE,32          ; Prepare #REGde for addition (the beam travels vertically
                                                           ; downwards to start with)
* The beam-drawing loop begins here.
lightbean_loop:
;      movb @floor,a                   ; LD A,(32809)      ; Pick up the attribute byte of the floor tile for the
                                                           ; cavern from #R32809
       cb   @floor,*hl                 ; CP (HL)           ; Does #REGhl point at a floor tile?
       jeq  lightbeam_3                ; RET Z             ; Return if so (the light beam stops here)
;      movb @wall,a                    ; LD A,(32827)      ; Pick up the attribute byte of the wall tile for the
                                                           ; cavern from #R32827
       cb   @wall,*hl                  ; CP (HL)           ; Does #REGhl point at a wall tile?
       jeq  lightbeam_3                ; RET Z             ; Return if so (the light beam stops here)
;      movb @bytes+39,a                ; LD A,39           ; #REGa=#b39 (INK 7: PAPER 4)
       cb   @bytes+39,*hl              ; CP (HL)           ; Does #REGhl point at a tile with this attribute value?
       jne  _36248                     ; JR NZ,36248       ; Jump if not (the light beam is not touching Willy)
       .exx                            ; EXX               ; Switch to the shadow registers briefly (to preserve
                                                           ; #REGde and #REGhl)
       .call @dec_air                   ; CALL 35388        ; {Decrease the air supply by four units
       .call @dec_air                   ; CALL 35388        ;
       .call @dec_air                   ; CALL 35388        ;
       .call @dec_air                   ; CALL 35388        ; }
       .exx                            ; EXX               ; Switch back to the normal registers (restoring #REGde
                                                           ; and #REGhl)
       jmp  _36261                     ; JR 36261          ; Jump forward to draw the light beam over Willy
_36248:
;      movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the cavern from #R32800
       cb   @background,*hl            ; CP (HL)           ; Does #REGhl point at a background tile?
       jeq  _36261                     ; JR Z,36261        ; Jump if so (the light beam will not be reflected at this
                                                           ; point)
       movb @e,a                       ; LD A,E            ; {Toggle the value in #REGde between 32 and -1 (and
       li   r0,223*256                 ; XOR 223           ; therefore the direction of the light beam between
       xor  r0,a                       ;                   
       movb a,@e                       ; LD E,A            ; vertically downwards and horizontally to the left): the
       movb d,a                        ; LD A,D            ; light beam has hit a guardian
       inv  a                          ; CPL               ; 
       movb a,d                        ; LD D,A            ; }
_36261:
       movb @bytes+119,*hl             ; LD (HL),119       ; Draw a portion of the light beam with attribute value
                                                           ; #b119 (INK 7: PAPER 6: BRIGHT 1)
*      Draw attribute to TI and record it for later undrawing
       mov  hl,r1
       bl   @upload_attribute
       mov  @light_beam_attr_addrs_ptr,r0
       mov  hl,*r0+
       mov  r0,@light_beam_attr_addrs_ptr

       a    de,hl                      ; ADD HL,DE         ; Point #REGhl at the cell where the next portion of the
                                                           ; light beam will be drawn
       jmp  lightbean_loop             ; JR 36217          ; Jump back to draw the next portion of the light beam
lightbeam_3:
       mov  @light_beam_attr_addrs_ptr,r0
       clr  *r0
       .ret

* Draw the horizontal guardians in the current cavern
* 
* Used by the routine at #R34574.
draw_hguardians:                       ; 36266
       li   iy,hguards                 ; LD IY,32958       ; Point #REGiy at the first byte of the first horizontal
                                                           ; guardian definition at #R32958
* The guardian-drawing loop begins here.
hguardians_loop:
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the first byte of the guardian definition
       cb   a,@b255                    ; CP 255            ; Have we dealt with all the guardians yet?
       jne  !                          ; RET Z             ; Return if so
       .ret                            ;                   
!
       socb a,a                        ; OR A              ; Is this guardian definition blank?
       jeq  _36337                     ; JR Z,36337        ; If so, skip it and consider the next one
;      li   de,31                      ; LD DE,31          ; Prepare #REGde for addition
       movb @1(iy),@l                  ; LD L,(IY+1)       ; {Point #REGhl at the address of the guardian's location
       movb @2(iy),h                   ; LD H,(IY+2)       ; in the attribute buffer at #R23552 attr_buffer_2}
       andi a,127*256                  ; AND 127           ; Reset bit 7 (which specifies the animation speed) of the
                                                           ; attribute byte, ensuring no FLASH
       movb a,*hl+                     ; LD (HL),A         ; {Set the attribute bytes for the guardian in the buffer
;      inc  hl                         ; INC HL            ; at #R23552 attr_buffer_2
       movb a,*hl                      ; LD (HL),A         ; 
       ai   hl,31                      ; ADD HL,DE         ;
       movb a,*hl+                     ; LD (HL),A         ;
;      inc  hl                         ; INC HL            ;
       movb a,*hl                      ; LD (HL),A         ; }
       movb one,@c                     ; LD C,1            ; Prepare #REGc for the call to the drawing routine at
                                                           ; #R36852 later on
       movb @4(iy),a                   ; LD A,(IY+4)       ; Pick up the animation frame (0-7)
;      srl  a,1                        ; RRCA              ; {Multiply it by 32
;      srl  a,1                        ; RRCA              ;
;      srl  a,1                        ; RRCA              ; }
       sla  a,5
       movb a,@e                       ; LD E,A            ; Copy the result to #REGe
       movb @cavern,a                  ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       cb   a,@bytes+7                 ; CP 7              ; Are we in one of the first seven caverns?
       jl   _36323                     ; JR C,36323        ; Jump if so
       cb   a,@bytes+9                 ; CP 9              ; Are we in #R54272(The Endorian Forest)?
       jeq  _36323                     ; JR Z,36323        ; Jump if so
       cb   a,@bytes+15                ; CP 15             ; Are we in #R60416(The Sixteenth Cavern)?
       jeq  _36323                     ; JR Z,36323        ; Jump if so
       socb @bits+7,@e                 ; SET 7,E           ; Add #b128 to #REGe (the horizontal guardians in this
                                                           ; cavern use frames 4-7 only)
_36323:
       movb @bytes+ggdata_msb,d        ; LD D,129          ; Point #REGde at the graphic data for the appropriate
                                                           ; guardian sprite (at #R33024+#REGe)
       movb @1(iy),@l                  ; LD L,(IY+1)       ; {Point #REGhl at the address of the guardian's location
       movb @3(iy),h                   ; LD H,(IY+3)       ; in the screen buffer at #R24576 scrn_buffer_2}
       .call @draw_sprite              ; CALL 36852        ; Draw the guardian to the screen buffer at #R24576 scrn_buffer_2
       jeq  !                          ; JP NZ,36102       ; Kill Willy if the guardian collided with him
       .ifeq can_die,1
       b    @kill_willy_2              ;
       .else
       nop
       .endif
!
* The current guardian definition has been dealt with. Time for the next one.
_36337:
;      li   de,7                       ; LD DE,7           ; {Point #REGiy at the first byte of the next horizontal
       ai    iy,7                      ; ADD IY,DE         ; guardian definition}
       jmp  hguardians_loop                     ; JR 36270          ; Jump back to deal with the next horizontal guardian

* Move and draw Eugene in Eugene's Lair
* 
* Used by the routine at #R34574. First we move Eugene up or down, or change
* his direction.
eugene:                                ; 36344
       movb @itemattr,a                ; LD A,(32884)      ; Pick up the attribute of the last item drawn from
                                                           ; #R32884
;      socb a,a                        ; OR A              ; Have all the items been collected?
       jeq  _36367                     ; JR Z,36367        ; Jump if so
       movb @eugdir,a                  ; LD A,(32987)      ; Pick up Eugene's direction from #R32987
;      socb a,a                        ; OR A              ; Is Eugene moving downwards?
       jeq  _36367                     ; JR Z,36367        ; Jump if so
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up Eugene's pixel y-coordinate from #R32988
       sb   one,a                      ; DEC A             ; Decrement it (moving Eugene up)
       jeq  _36380                     ; JR Z,36380        ; Jump if Eugene has reached the top of the cavern
       movb a,@eughgt                  ; LD (32988),A      ; Update Eugene's pixel y-coordinate at #R32988
       jmp  _36388                     ; JR 36388          ; 
_36367:
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up Eugene's pixel y-coordinate from #R32988
       ab   one,a                      ; INC A             ; Increment it (moving Eugene down)
       cb   a,@bytes+88                ; CP 88             ; Has Eugene reached the portal yet?
       jeq  _36380                     ; JR Z,36380        ; Jump if so
       movb a,@eughgt                  ; LD (32988),A      ; Update Eugene's pixel y-coordinate at #R32988
       jmp  _36388                     ; JR 36388          ; 
_36380:
       movb @eugdir,a                  ; LD A,(32987)      ; {Toggle Eugene's direction at #R32987
       xor  one,a                      ; XOR 1             ; 
       movb a,@eugdir                  ; LD (32987),A      ; }
* Now that Eugene's movement has been dealt with, it's time to draw him.
_36388:
*      RM: Swapping order of attributes and sprites
*      to make the attributes available to the hardware sprite drawing routine
*      Attributes
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up Eugene's pixel y-coordinate from #R32988
       andi a,120*256                  ; AND 120           ; {Point #REGhl at the address of Eugene's location in the
       sla  a,1                        ; RLCA              ; attribute buffer at #R23552 attr_buffer_2
       socb @bytes+7,a                 ; OR 7              ; 
       ; SCF                           ; SCF               ; Set carry flag, which will be rolled into bit 0
       clr  r0
       sla  a,1                        ; RL A              ;
       jnc  !
       mov  one,r0
!      socb one,a                      ; Carry from SCF
       movb a,@l                       ; LD L,A            ; 
       sb   a,a                        ; LD A,0            ; 
       ab   @bytes+attr_buffer_2_msb,a ; ADC A,92          ;
       ab   r0,a                       ; Carry from RL A
       movb a,h                        ; LD H,A            ; }
       movb @itemattr,r0               ; LD A,(32884)      ; Pick up the attribute of the last item drawn from
                                                           ; #R32884
;      socb a,a                        ; OR A              ; Set the zero flag if all the items have been collected
       movb @bytes+7,a                 ; LD A,7            ; Assume we will draw Eugene with white INK
       movb r0,r0
       jne  !                          ; JR NZ,36447       ; Jump if there are items remaining to be collected
       movb @clock,a                   ; LD A,(32957)      ; Pick up the value of the game clock at #R32957
;      srl  a,1                        ; RRCA              ; {Move bits 2-4 into bits 0-2 and clear the other bits;
       srl  a,2                        ; RRCA              ; this value (which decreases by one on each pass through
       andi a,7*256                    ; AND 7             ; the main loop) will be Eugene's INK colour}
!       .call @draw_sprite_attributes
*      Sprite
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up Eugene's pixel y-coordinate from #R32988
       andi a,127*256                  ; AND 127           ; {Point #REGde at the entry in the screen buffer address
       sla  a,1                        ; RLCA              ; lookup table at #R33536 that corresponds to Eugene's
       movb a,@e                       ; LD E,A            ; y-coordinate
       movb @sbufaddrs_msb_byte,d      ; LD D,131          ; }
       movb *de+,a                     ; LD A,(DE)         ; {Point #REGhl at the address of Eugene's location in the
       socb @bytes+15,a                ; OR 15             ; screen buffer at #R24576 scrn_buffer_2
       movb a,@l                       ; LD L,A            ;
;      inc  de                         ; INC DE            ;
       movb *de,a                      ; LD A,(DE)         ;
       movb a,h                        ; LD H,A            ; }
       li   de,extra_sprite            ; LD DE,32992       ; {Draw Eugene to the screen buffer at #R24576 scrn_buffer_2
       movb one,@c                     ; LD C,1            ;
       .call @draw_sprite              ; CALL 36852        ; }
       jeq  !                          ; JP NZ,36102       ; Kill Willy if Eugene collided with him
       .ifeq can_die,1
       b    @kill_willy_2              ;
       .else
       nop
       .endif
!      .ret

* This entry point is used by the routines at #R36469 (to set the attributes
* for a Skylab), #R36593 (to set the attributes for a vertical guardian) and
* #R37173 (to set the attributes for the Kong Beast).
draw_sprite_attributes:
       movb a,*hl                      ; LD (HL),A         ; Save the INK colour in the attribute buffer temporarily
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       andi a,248*256                  ; AND 248           ; {Combine its PAPER colour with the chosen INK colour
       socb *hl,a                      ; OR (HL)           ; }
       movb a,*hl+                     ; LD (HL),A         ; Set the attribute byte for the top-left cell of the
                                                           ; sprite in the attribute buffer at #R23552 attr_buffer_2
       li   de,31                      ; LD DE,31          ; Prepare #REGde for addition
;      inc  hl                         ; INC HL            ; {Set the attribute byte for the top-right cell of the
       movb a,*hl                      ; LD (HL),A         ; sprite in the attribute buffer at #R23552 attr_buffer_2}
       a    de,hl                      ; ADD HL,DE         ; {Set the attribute byte for the middle-left cell of the
       movb a,*hl+                     ; LD (HL),A         ; sprite in the attribute buffer at #R23552 attr_buffer_2}
;      inc  hl                         ; INC HL            ; {Set the attribute byte for the middle-right cell of the
       movb a,*hl                      ; LD (HL),A         ; sprite in the attribute buffer at #R23552 attr_buffer_2}
       a    de,hl                      ; ADD HL,DE         ; {Set the attribute byte for the bottom-left cell of the
       movb a,*hl+                     ; LD (HL),A         ; sprite in the attribute buffer at #R23552 attr_buffer_2}
;      inc  hl                         ; INC HL            ; {Set the attribute byte for the bottom-right cell of the
       movb a,*hl                      ; LD (HL),A         ; sprite in the attribute buffer at #R23552 attr_buffer_2}
       .ret                            ; RET               ; 

* Move and draw the Skylabs in Skylab Landing Bay
* 
* Used by the routine at #R34574.
skylabs:                               ; 36469
       li   iy,vguards                 ; LD IY,32989       ; Point #REGiy at the first byte of the first vertical
                                                           ; guardian definition at #R32989
* The Skylab-moving loop begins here.
skylab_loop:
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the first byte of the guardian definition
       cb   a,@b255                    ; CP 255            ; Have we dealt with all the Skylabs yet?
       jne  !                          ; JP Z,34719        ; If so, re-enter the main loop
       b    @return_from_skylab                    ;
!
       movb @2(iy),a                   ; LD A,(IY+2)       ; Pick up the Skylab's pixel y-coordinate
       cb   a,@6(iy)                   ; CP (IY+6)         ; Has it reached its crash site yet?
       jhe  _36497                     ; JR NC,36497       ; Jump if so
       ab   @4(iy),a                   ; ADD A,(IY+4)      ; {Increment the Skylab's y-coordinate (moving it
       movb a,@2(iy)                   ; LD (IY+2),A       ; downwards)}
       jmp  _36527                     ; JR 36527          ; 
* The Skylab has reached its crash site. Start or continue its disintegration.
_36497:
       ab   one,@1(iy)                 ; INC (IY+1)        ; Increment the animation frame
       movb @1(iy),a                   ; LD A,(IY+1)       ; Pick up the animation frame
       cb   a,@bytes+8                 ; CP 8              ; Has the Skylab completely disintegrated yet?
       jne  _36527                     ; JR NZ,36527       ; Jump if not
       movb @5(iy),a                   ; LD A,(IY+5)       ; {Reset the Skylab's pixel y-coordinate
       movb a,@2(iy)                   ; LD (IY+2),A       ; }
       movb @3(iy),a                   ; LD A,(IY+3)       ; {Add 8 to the Skylab's x-coordinate (wrapping around at
       ab   @bytes+8,a                 ; ADD A,8           ; the right side of the screen)
       andi a,31*256                   ; AND 31            ; 
       movb a,@3(iy)                   ; LD (IY+3),A       ; }
       sb   @1(iy),@1(iy)              ; LD (IY+1),0       ; Reset the animation frame to 0
* Now that the Skylab's movement has been dealt with, time to draw it.
_36527:
*      RM: Swapping order of attributes and sprites
*      to make the attributes available to the hardware sprite drawing routine
*      Attributes
       movb @2(iy),a                   ; LD A,(IY+2)       ; {Point #REGhl at the address of the Skylab's location in
       andi a,64*256                   ; AND 64            ; the attribute buffer at #R23552 attr_buffer_2
;      sla  a,1                        ; RLCA              ;
       srl  a,6                        ; RLCA              ;
       ab   @bytes+attr_buffer_2_msb,a                  ; ADD A,92          ;
       movb a,h                        ; LD H,A            ;
       movb @2(iy),a                   ; LD A,(IY+2)       ;
;      sla  a,1                        ; RLCA              ;
       sla  a,2                        ; RLCA              ;
       andi a,224*256                  ; AND 224           ;
       socb @3(iy),a                   ; OR (IY+3)         ;
       movb a,@l                       ; LD L,A            ; }
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the Skylab's attribute byte
       .call @draw_sprite_attributes   ; CALL 36447        ; Set the attribute bytes for the Skylab
*      Sprite
       movb @2(iy),a                   ; LD E,(IY+2)       ; Pick up the Skylab's pixel y-coordinate in #REGe
       sla  a,1                        ; RLC E             ; {Point #REGde at the entry in the screen buffer address
       movb a,@e
       movb @sbufaddrs_msb_byte,d      ; LD D,131          ; lookup table at #R33536 that corresponds to the Skylab's
                                                           ; pixel y-coordinate}
       movb *de,a                      ; LD A,(DE)         ; {Point #REGhl at the address of the Skylab's location in
       ab   @3(iy),a                   ; ADD A,(IY+3)      ; the screen buffer at #R24576 scrn_buffer_2
       movb a,@l                       ; LD L,A            ; 
       inc  de                         ; INC DE            ; 
       movb *de,a                      ; LD A,(DE)         ; 
       movb a,h                        ; LD H,A            ; }
       movb @1(iy),a                   ; LD A,(IY+1)       ; Pick up the animation frame (0-7)
;      srl  a,1                        ; RRCA              ; {Multiply it by 32
;      srl  a,1                        ; RRCA              ;
       sla  a,5                        ; RRCA              ; }
       movb a,@e                       ; LD E,A            ; {Point #REGde at the graphic data for the corresponding
       movb @bytes+ggdata_msb,d        ; LD D,129          ; Skylab sprite (at #R33024+#REGa)}
       movb one,@c                     ; LD C,1            ; {Draw the Skylab to the screen buffer at #R24576 scrn_buffer_2
       .call @draw_sprite              ; CALL 36852        ; }
       jeq  !                          ; JP NZ,36103       ; Kill Willy if the Skylab collided with him
       .ifeq can_die,1
       b    @kill_willy_3              ;
       .else
       nop
       .endif
!
* The current guardian definition has been dealt with. Time for the next one.
       li   de,7                       ; LD DE,7           ; {Point #REGiy at the first byte of the next vertical
       a    de,iy                      ; ADD IY,DE         ; guardian definition}
       jmp  skylab_loop                     ; JR 36473          ; Jump back to deal with the next Skylab

* Move and draw the vertical guardians in the current cavern
* 
* Used by the routine at #R34574.
draw_vguardians:                       ; 36593
       li   iy,vguards                 ; LD IY,32989       ; Point #REGiy at the first byte of the first vertical
                                                           ; guardian definition at #R32989
* The guardian-moving loop begins here.
vguardians_loop:
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the first byte of the guardian definition
       cb   a,@b255                    ; CP 255            ; Have we dealt with all the guardians yet?
       jne  !                          ; RET Z             ; Return if so
       .ret                            ;                   
!
       ab   one,@1(iy)                 ; INC (IY+1)        ; Increment the guardian's animation frame
       szcb @bits+2,@1(iy)             ; RES 2,(IY+1)      ; Reset the animation frame to 0 if it overflowed to 4
       movb @2(iy),a                   ; LD A,(IY+2)       ; Pick up the guardian's pixel y-coordinate
       ab   @4(iy),a                   ; ADD A,(IY+4)      ; Add the current y-coordinate increment
       cb   a,@5(iy)                   ; CP (IY+5)         ; Has the guardian reached the highest point of its path
                                                           ; (minimum y-coordinate)?
       jl   _36631                     ; JR C,36631        ; If so, jump to change its direction of movement
       cb   a,@6(iy)                   ; CP (IY+6)         ; Has the guardian reached the lowest point of its path
                                                           ; (maximum y-coordinate)?
       jhe  _36631                     ; JR NC,36631       ; If so, jump to change its direction of movement
       movb a,@2(iy)                   ; LD (IY+2),A       ; Update the guardian's pixel y-coordinate
       jmp  _36639                     ; JR 36639          ; 
_36631:
       movb @4(iy),a                   ; LD A,(IY+4)       ; {Negate the y-coordinate increment; this changes the
       neg a                           ; NEG               ; guardian's direction of movement
       movb a,@4(iy)                   ; LD (IY+4),A       ; }
* Now that the guardian's movement has been dealt with, time to draw it.
_36639:
*      RM: Swapping order of attributes and sprites
*      to make the attributes available to the hardware sprite drawing routine
*      Attributes
       movb @2(iy),a                   ; LD A,(IY+2)       ; Pick up the guardian's pixel y-coordinate
       andi a,64*256                   ; AND 64            ; {Point #REGhl at the address of the guardian's location
;      sla  a,1                        ; RLCA              ; in the attribute buffer at #R23552 attr_buffer_2
       srl  a,6                        ; RLCA              ;
       ab   @bytes+attr_buffer_2_msb,a                     ; ADD A,92       ;
       movb a,h                        ; LD H,A            ;
       movb @2(iy),a                   ; LD A,(IY+2)       ;
;      sla  a,1                        ; RLCA              ;
       sla  a,2                        ; RLCA              ;
       andi a,224*256                  ; AND 224           ;
       socb @3(iy),a                   ; OR (IY+3)         ;
       movb a,@l                       ; LD L,A            ; }
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the guardian's attribute byte
       .call @draw_sprite_attributes   ; CALL 36447        ; Set the attribute bytes for the guardian
*      Sprite
       movb @2(iy),a                   ; LD A,(IY+2)       ; Pick up the guardian's pixel y-coordinate
       andi a,127*256                  ; AND 127           ; {Point #REGde at the entry in the screen buffer address
       sla  a,1                        ; RLCA              ; lookup table at #R33536 that corresponds to the
       movb a,@e                       ; LD E,A            ; guardian's pixel y-coordinate
       movb @sbufaddrs_msb_byte,d      ; LD D,131          ; }
       movb *de,a                      ; LD A,(DE)         ; {Point #REGhl at the address of the guardian's location
       socb @3(iy),a                   ; OR (IY+3)         ; in the screen buffer at #R24576 scrn_buffer_2
       movb a,@l                       ; LD L,A            ; 
       inc  de                         ; INC DE            ; 
       movb *de,a                      ; LD A,(DE)         ; 
       movb a,h                        ; LD H,A            ; }
       movb @1(iy),a                   ; LD A,(IY+1)       ; Pick up the guardian's animation frame (0-3)
;      srl  a,1                        ; RRCA              ; {Multiply it by 32
;      srl  a,1                        ; RRCA              ;
;      srl  a,1                        ; RRCA              ; }
       sla  a,5
       movb a,@e                       ; LD E,A            ; {Point #REGde at the graphic data for the appropriate
       movb @bytes+ggdata_msb,d        ; LD D,129          ; guardian sprite (at #R33024+#REGa)}
       movb one,@c                     ; LD C,1            ; {Draw the guardian to the screen buffer at #R24576 scrn_buffer_2
       .call @draw_sprite              ; CALL 36852        ; }
       jeq  !                          ; JP NZ,36102       ; Kill Willy if the guardian collided with him
       .ifeq can_die,1
       b    @kill_willy_2              ;
       .else
       nop
       .endif
!
* The current guardian definition has been dealt with. Time for the next one.
;      li   de,7                       ; LD DE,7           ; {Point #REGiy at the first byte of the next vertical
       ai   iy,7                       ; ADD IY,DE         ; guardian definition}
       jmp  vguardians_loop                     ; JR 36597          ; Jump back to deal with the next vertical guardian
*
* Draw the items in the current cavern and collect any that Willy is touching
* 
* Used by the routine at #R34574.
draw_items:                             ; 36707
       sb   a,a                        ; XOR A             ; {Initialise the attribute of the last item drawn at
       movb a,@itemattr                ; LD (32884),A      ; #R32884 to #b0 (in case there are no items left to draw)
                                                           ; }
       li   iy,items                   ; LD IY,32885       ; Point #REGiy at the first byte of the first item
                                                           ; definition at #R32885
* The item-drawing loop begins here.
_36715:
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the first byte of the item definition
       cb   a,@b255                    ; CP 255            ; Have we dealt with all the items yet?
       jeq  _36794                     ; JR Z,36794        ; Jump if so
       socb a,a                        ; OR A              ; Has this item already been collected?
       jeq  _36782                     ; JR Z,36782        ; If so, skip it and consider the next one
       movb @1(iy),@e                  ; LD E,(IY+1)       ; {Point #REGde at the address of the item's location in
       movb @2(iy),d                   ; LD D,(IY+2)       ; the attribute buffer at #R23552 attr_buffer_2}
       movb *de,a                      ; LD A,(DE)         ; Pick up the current attribute byte at the item's
                                                           ; location
       andi a,7*256                    ; AND 7             ; {Is the INK white (which happens if Willy is touching
       cb   a,@bytes+7                 ; CP 7              ; the item)?}
       jne  _36750                     ; JR NZ,36750       ; Jump if not
* Willy is touching this item, so add it to his collection.
       mov  de,r1
       movb @3(iy),r1
       bl   @upload_character
       li   hl,scorbuf+3               ; LD HL,33836       ; {Add 100 to the score
       .call @incscore_1               ; CALL 37118        ; }
       sb   *iy,*iy                    ; LD (IY+0),0       ; Set the item's attribute byte to #b0 so that it will be
       jmp  _36782                     ; JR 36782          ; Jump forward to consider the next item
* This item has not been collected yet.
_36750:
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the item's current attribute byte
       andi a,248*256                  ; AND 248           ; {Keep the BRIGHT and PAPER bits, and set the INK to 3
       socb @bytes+3,a                 ; OR 3              ; (magenta)}
       movb a,b                        ; LD B,A            ; Store this value in #REGb
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the item's current attribute byte again
       andi a,3*256                    ; AND 3             ; {Keep only bits 0 and 1 and add the value in #REGb; this
       ab   b,a                        ; ADD A,B           ; maintains the BRIGHT and PAPER bits, and cycles the INK
                                                           ; colour through 3, 4, 5 and 6}
       movb a,*iy                      ; LD (IY+0),A       ; Store the new attribute byte
       movb a,*de                      ; LD (DE),A         ; Update the attribute byte at the item's location in the
                                                           ; buffer at #R23552 attr_buffer_2
       movb a,@itemattr                ; LD (32884),A      ; Store the new attribute byte at #R32884 as well
       movb @3(iy),d                   ; LD D,(IY+3)       ; Point #REGde at the address of the item's location in
                                                           ; the screen buffer at #R24576 scrn_buffer_2
       li   hl,item                    ; LD HL,32948       ; Point #REGhl at the item graphic for the current cavern
                                                           ; (at #R32948)
       movb @bytes+8,b                 ; LD B,8            ; There are eight pixel rows to copy
       .push de
       .call @print_char_1             ; CALL 37589        ; Draw the item to the screen buffer at #R24576 scrn_buffer_2
       .pop  r1
       bl   @upload_character
* The current item definition has been dealt with. Time for the next one.
_36782:
;      inc  iy                         ; INC IY            ; {Point #REGiy at the first byte of the next item
;      inc  iy                         ; INC IY            ; definition
;      inc  iy                         ; INC IY            ;
;      inc  iy                         ; INC IY            ;
;      inc  iy                         ; INC IY            ; }
       ai   iy,5
       jmp  _36715                     ; JR 36715          ; Jump back to deal with the next item
* All the items have been dealt with. Check whether there were any left.
_36794:
       movb @itemattr,a                ; LD A,(32884)      ; Pick up the attribute of the last item drawn at #R32884
;      socb a,a                        ; OR A              ; Were any items drawn?
       jeq  !                          ; RET NZ            ; Return if so (some remain to be collected)
       .ret                            ;                   
!
       li   hl,portal                  ; LD HL,32911       ; {Ensure that the portal is flashing by setting bit 7 of
       socb @bits+7,*hl                ; SET 7,(HL)        ; its attribute byte at #R32911}
       .ret                            ; RET               ; 

* Draw the portal, or move to the next cavern if Willy has entered it
* 
* Used by the routine at #R34574. First check whether Willy has entered the
* portal.
draw_portal:                           ; 36805
       movb @portal_location_1+1,h     ; LD HL,(32944)     ; Pick up the address of the portal's location in the
       movb @portal_location_1,@l                          ; attribute buffer at #R23552 attr_buffer_2 from #R32944
       movb @location,a                ; LD A,(32876)      ; Pick up the LSB of the address of Willy's location in
                                                           ; the attribute buffer at #R23552 attr_buffer_2 from #R32876
       cb   a,@l                       ; CP L              ; Does it match that of the portal?
       jne  _36831                     ; JR NZ,36831       ; Jump if not
       movb @location+1,a              ; LD A,(32877)      ; Pick up the MSB of the address of Willy's location in
                                                           ; the attribute buffer at #R23552 attr_buffer_2 from #R32876(#N32877)
       cb   a,h                        ; CP H              ; Does it match that of the portal?
       jne  _36831                     ; JR NZ,36831       ; Jump if not
       movb @portal,a                  ; LD A,(32911)      ; Pick up the portal's attribute byte from #R32911
       movb a,r0                       ; BIT 7,A           ; Is the portal flashing?
       andi r0,128*256                 ;                   
       jeq  _36831                     ; JR Z,36831        ; Jump if not
       .pop hl                         ; POP HL            ; Drop the return address from the stack
       b    @next_cavern               ; JP 36904          ; Move Willy to the next cavern
* Willy has not entered the portal, or it's not flashing, so just draw it.
_36831:
       movb @portal,a                  ; LD A,(32911)      ; Pick up the portal's attribute byte from #R32911
       movb a,r0
       andi r0,128*256                 ; Is it flashing?
       jeq  !
       movb @clock,r0
       andi r0,>1f00
       jne  !
       movb a,r0                       ; Exchange ink and paper (software flash)
       movb a,r1
       andi a,>c000
       srl  r0,3
       andi r0,>0700
       sla  r1,3
       andi r1,>3800
       socb r0,a
       socb r1,a
       movb a,@portal
!      movb a,*hl+                     ; LD (HL),A         ; {Set the attribute bytes for the portal in the buffer at
;      inc  hl                         ; INC HL            ; #R23552 attr_buffer_2
       movb a,*hl                      ; LD (HL),A         ; 
       li   de,31                      ; LD DE,31          ; 
       a    de,hl                      ; ADD HL,DE         ; 
       movb a,*hl+                     ; LD (HL),A         ;
;      inc  hl                         ; INC HL            ;
       movb a,*hl                      ; LD (HL),A         ; }
       li   de,portal_sprites          ; LD DE,32912       ; Point #REGde at the graphic data for the portal at
                                                           ; #R32912
       movb @portal_location_2+1,h     ; LD HL,(32946)     ; Pick up the address of the portal's location in the
       movb @portal_location_2,@l                          ; screen buffer at #R24576 scrn_buffer_2 from #R32946
       sb   @c,@c                      ; LD C,0            ; #REGc=0: overwrite mode
       jmp  draw_sprite_1
* This routine continues into the one at #R36852.

* Draw a sprite
* 
* Used by the routines at #R34252 (to draw Willy on the title screen), #R34574
* (to draw the remaining lives), #R35140 (to draw Willy, the boot and the
* plinth during the game over sequence), #R36266 (to draw horizontal
* guardians), #R36344 (to draw Eugene in #R49152(Eugene's Lair)), #R36469 (to
* draw the Skylabs in #R58368(Skylab Landing Bay)), #R36593 (to draw vertical
* guardians), #R36805 (to draw the portal in the current cavern), #R36904 (to
* draw Willy above ground and the swordfish graphic over the portal in
* #R64512(The Final Barrier)) and #R37173 (to draw the Kong Beast in
* #R52224(Miner Willy meets the Kong Beast) and #R56320(Return of the Alien
* Kong Beast)). If #REGc=1 on entry, this routine returns with the zero flag
* reset if any of the set bits in the sprite being drawn collides with a set
* bit in the background.
* 
* C Drawing mode: 0 (overwrite) or 1 (blend)
* DE Address of sprite graphic data
* HL Address to draw at
draw_sprite:                           ; 36852
       mov  @sprite_attr_table_addr,r0
       jeq  draw_sprite_1
       bl   @ti_draw_sprite
       .ret_eq
draw_sprite_1:
       movb @bytes+16,b                ; LD B,16           ; There are 16 rows of pixels to draw
draw_sprite_loop:
*      Left byte
       movb *de+,a                     ; LD A,(DE)         ; Pick up a sprite graphic byte
       movb @c,r0                      ; BIT 0,C           ; Set the zero flag if we're in overwrite mode
;      andi r0,1*256                   ;
;      movb *de,a                      ; LD A,(DE)         ; Pick up a sprite graphic byte
       jeq  _36863                     ; JR Z,36863        ; Jump if we're in overwrite mode
       movb *hl,r0
       inv  r0
       movb a,r1
       szcb  r0,r1                     ; AND (HL)          ; {Return with the zero flag reset if any of the set bits
       jeq  !                          ; RET NZ            ; in the sprite graphic byte collide with a set bit in the
       .ret                            ;                   ; background (e.g. in Willy's sprite)}
;      movb *de,a                      ; LD A,(DE)         ; Pick up the sprite graphic byte again
!      socb *hl,a                      ; OR (HL)           ; Blend it with the background byte
_36863:
       movb a,*hl+                     ; LD (HL),A         ; Copy the graphic byte to its destination cell
*      Update source and dest
;      ab   one,@l                     ; INC L             ; Move #REGhl along to the next cell on the right
;      inc  de                         ; INC DE            ; Point #REGde at the next sprite graphic byte
*      Right byte
       movb *de+,a                     ; LD A,(DE)         ; Pick up a sprite graphic byte
       movb @c,r0                      ; BIT 0,C           ; Set the zero flag if we're in overwrite mode
;      andi r0,1*256                   ;
;      movb *de,a                      ; LD A,(DE)         ; Pick up a sprite graphic byte
       jeq  _36875                     ; JR Z,36875        ; Jump if we're in overwrite mode
       movb *hl,r0
       inv  r0
       movb a,r1
       szcb r0,r1                      ; AND (HL)          ; {Return with the zero flag reset if any of the set bits
       jeq  !                          ; RET NZ            ; in the sprite graphic byte collide with a set bit in the
       .ret                            ;                   ; background (e.g. in Willy's sprite)}
;      movb *de,a                      ; LD A,(DE)         ; Pick up the sprite graphic byte again
!      socb *hl,a                      ; OR (HL)           ; Blend it with the background byte
_36875:
       movb a,*hl                      ; LD (HL),A         ; Copy the graphic byte to its destination cell
*      Update source and dest
       sb   one,@l                     ; DEC L             ; {Move #REGhl to the next pixel row down in the cell on
       ab   one,h                      ; INC H             ; the left}
;      inc  de                         ; INC DE            ; Point #REGde at the next sprite graphic byte
*      Handle moving from one character block to another
       movb h,a                        ; LD A,H            ; {Have we drawn the bottom pixel row in this pair of
       andi a,7*256                    ; AND 7             ; cells yet?}
       jne  _36900                     ; JR NZ,36900       ; Jump if not
;      movb h,a                        ; LD A,H            ; {Otherwise move #REGhl to the top pixel row in the cell
;      sb   @bytes+8,a                 ; SUB 8             ; below
;      movb a,h                        ; LD H,A            ;
       sb   @bytes+8,h
;      movb @l,a                       ; LD A,L            ;
;      ab   @bytes+32,a                ; ADD A,32          ;
;      movb a,@l                       ; LD L,A            ; }
       ab   @bytes+32,@l
       movb @l,a
       andi a,224*256                  ; AND 224           ; Was the last pair of cells at y-coordinate 7 or 15?
       jne  _36900                     ; JR NZ,36900       ; Jump if not
;      movb h,a                        ; LD A,H            ; {Otherwise adjust #REGhl to account for the movement
;      ab   @bytes+8,a                 ; ADD A,8           ; from the top or middle third of the screen to the next
;      movb a,h                        ; LD H,A            ; one down}
       ab   @bytes+8,h
_36900:
*      Loop
       sb   one,b                      ; DJNZ 36854        ; Jump back until all 16 rows of pixels have been drawn
       jne  draw_sprite_loop                     ;
       sb   a,a                        ; XOR A             ; Set the zero flag (to indicate no collision)
       .ret_eq                         ; RET               ;

* Move to the next cavern
* 
* Used by the routines at #R34574 and #R36805.
next_cavern:                           ; 36904
       bl   @mute_sound
       bl   @reset_sprite_attr_table
       movb @cavern,a                  ; LD A,(33799)      ; Pick up the number of the current cavern from #R33799
       ab   one,a                      ; INC A             ; Increment the cavern number
       cb   a,@bytes+20                ; CP 20             ; Is the current cavern #R64512(The Final Barrier)?
       jne  _37009                     ; JR NZ,37009       ; Jump if not
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
;      socb a,a                        ; OR A              ; Are we in demo mode?
       jeq  !                          ; JP NZ,37008       ; Jump if so
       b    @_37008                    ;                   
!
       movb @cheat,a                   ; LD A,(33885)      ; Pick up the 6031769 key counter from #R33885
       cb   a,@bytes+7                 ; CP 7              ; Is cheat mode activated?
       jeq  _37008                     ; JR Z,37008        ; Jump if so

* Willy has made it through #R64512(The Final Barrier) without cheating.
       sb   @c,@c                      ; LD C,0            ; {Draw Willy at (2,19) on the ground above the portal
       li   de,willyr_sprites_3        ; LD DE,33376       ;
       li   hl,zx_screen+83            ; LD HL,16467       ; 
       .call @draw_sprite              ; CALL 36852        ; }
       seto @caverns_0_6_bank_select
       li   de,swordfish               ; LD DE,45792       ; {Draw the swordfish graphic (see #R45792) over the
       li   hl,zx_screen+179           ; LD HL,16563       ; portal
       .call @draw_sprite              ; CALL 36852        ; }
       li   hl,zx_attrs+83             ; LD HL,22611       ; Point #REGhl at (2,19) in the attribute file
       li   de,31                      ; LD DE,31          ; Prepare #REGde for addition
       movb @bytes+47,*hl              ; LD (HL),47        ; {Set the attributes for the upper half of Willy's sprite
       inc  hl                         ; INC HL            ; at (2,19) and (2,20) to #b47 (INK 7: PAPER 5)
       movb @bytes+47,*hl              ; LD (HL),47        ; }
       a    de,hl                      ; ADD HL,DE         ; {Set the attributes for the lower half of Willy's sprite
       movb @bytes+39,*hl              ; LD (HL),39        ; at (3,19) and (3,20) to #b39 (INK 7: PAPER 4)
       inc  hl                         ; INC HL            ; 
       movb @bytes+39,*hl              ; LD (HL),39        ; }
       a    de,hl                      ; ADD HL,DE         ; {Point #REGhl at (5,19) in the attribute file
       inc  hl                         ; INC HL            ; 
       a    de,hl                      ; ADD HL,DE         ; }
       movb @bytes+69,*hl              ; LD (HL),69        ; {Set the attributes for the fish at (5,19) and (5,20) to
       inc  hl                         ; INC HL            ; #b69 (INK 5: PAPER 0: BRIGHT 1)
       movb @bytes+69,*hl              ; LD (HL),69        ; }
       a    de,hl                      ; ADD HL,DE         ; {Set the attribute for the handle of the sword at (6,19)
       movb @bytes+70,*hl              ; LD (HL),70        ; to #b70 (INK 6: PAPER 0: BRIGHT 1)}
       inc  hl                         ; INC HL            ; {Set the attribute for the blade of the sword at (6,20)
       movb @bytes+71,*hl              ; LD (HL),71        ; to #b71 (INK 7: PAPER 0: BRIGHT 1)}
       a    de,hl                      ; ADD HL,DE         ; {Set the attributes at (7,19) and (7,20) to #b0 (to hide
       sb   *hl,*hl                    ; LD (HL),0         ; Willy's feet just below where the portal was)
       inc  hl                         ; INC HL            ; 
       sb   *hl,*hl                    ; LD (HL),0         ; }

       bl   @upload_zx_screen

* Now play a celebratory sound effect.
       li   bc,0                       ; LD BC,0           ; {Prepare #REGc and #REGd for the celebratory sound
       movb @bytes+20,d                ; LD D,50           ; effect}
       sb   a,a                        ; XOR A             ; #REGa=0 (black border)
       bl   @ti_set_border_color
_36989:
       movb a,r1
       bl   @play_note_ch_2
;      OUT (254),A                     ; OUT (254),A       ; {Produce the celebratory sound effect: Willy has escaped
       li   r0,24*256                  ; XOR 24            ; from the mine
       xor  r0,a                       ;
       movb a,@e                       ; LD E,A            ;
       movb @c,a                       ; LD A,C            ;
       ab   d,a                        ; ADD A,D           ;
       ab   d,a                        ; ADD A,D           ;
       ab   d,a                        ; ADD A,D           ;
       movb a,b                        ; LD B,A            ;
       movb @e,a                       ; LD A,E            ;
_37000:
       sb   one,b                      ; DJNZ 37000        ;
       jne  _37000                     ;
       sb   one,@c                     ; DEC C             ;
       jne  _36989                     ; JR NZ,36989       ;
       sb   one,d                      ; DEC D             ;
       jne  _36989                     ; JR NZ,36989       ; }
       bl   @mute_sound

_37008:
       sb   a,a                        ; XOR A             ; #REGa=#b0 (the next cavern will be #R45056(Central
                                                           ; Cavern))
_37009:
       movb a,@cavern                   ; LD (33799),A      ; Update the cavern number at #R33799
* The next section of code cycles the INK and PAPER colours of the current
* cavern.
       movb @bytes+16,a                ; LD A,63           ; Initialise #REGa to #b63 (INK 7: PAPER 7)
_37014:
;      li   hl,zx_attrs                ; LD HL,22528       ; {Set the attributes for the top two-thirds of the screen
;      li   de,zx_attrs+1              ; LD DE,22529       ; to the value in #REGa
;      li   bc,511                     ; LD BC,511         ;
;      movb a,*hl                      ; LD (HL),A         ;
;      .ldir                           ; LDIR              ; }
       li   de,zx_attrs
       li   bc,512
       bl   @fill
       bl   @upload_top_middle_attributes

;      li   bc,4                       ; LD BC,4           ; {Pause for about 0.004s
;_37029:
;      sb   one,b                      ; DJNZ 37029        ;
;      jne  _37029                     ;
;      sb   one,@c                     ; DEC C             ;
;      jne  _37029                     ; JR NZ,37029       ; }

       sb   one,a                      ; DEC A             ; Decrement the attribute value in #REGa
       jne  _37014                     ; JR NZ,37014       ; Jump back until we've gone through all attribute values
                                                           ; from #b63 down to #b1
       movb @demo,a                    ; LD A,(33882)      ; Pick up the game mode indicator from #R33882
;      socb a,a                        ; OR A              ; Are we in demo mode?
       jeq  !                          ; JP NZ,34449       ; If so, demo the next cavern
       b    @new_cavern                ;
!
* The following loop increases the score and decreases the air supply until it
* runs out, while playing a sound effect.
dec_air_loop:
       .call @dec_air                  ; CALL 35388        ; Decrease the air remaining in the current cavern
       jne  !                          ; JP Z,34449        ; Move to the next cavern if the air supply is now gone
       b    @new_cavern                ;
!
       li   hl,scorbuf+5               ; LD HL,33838       ; {Add 1 to the score
       .call @incscore_1               ; CALL 37118        ; }
       movb @clock,a
       andi a,>1f00
       jne  !
       li   ix,scorbuf                 ; LD IX,33833       ; {Print the new score at (19,26)
       movb @bytes+6,@c                ; LD C,6            ; 
       li   de,zx_screen+4218          ; LD DE,20602       ; 
       .call @pmess                    ; CALL 37562        ; }
       li   r1,zx_screen+4218          ; Upload score
       li   r2,6
       bl   @upload_patterns
!
       movb @bytes+4,@c                ; LD C,4            ; This value determines the duration of the sound effect
       movb @air,a                     ; LD A,(32956)      ; Pick up the remaining air supply (S) from #R32956
       inv  a                          ; CPL               ; {#REGd=2*(63-S); this value determines the pitch of the
       andi a,63*256                   ; AND 63            ; sound effect (which decreases with the amount of air
       sla  a,1                        ; RLC A             ; remaining)
       movb a,r1
       bl   @play_note_ch_2
;       movb a,d                        ; LD D,A            ; }
;_37079:
;       sb   a,a                        ; LD A,0            ; {Produce a short note
;       ; OUT (254),A                   ; OUT (254),A       ;
;       movb d,b                        ; LD B,D            ;
;_37084:
;       sb   one,b                      ; DJNZ 37084        ;
;       jne  _37084                     ;
;       movb @bytes+24,a                ; LD A,24           ;
;       ; OUT (254),A                   ; OUT (254),A       ;
;       movb d,b                        ; LD B,D            ;
;_37091:
;       sb   one,b                      ; DJNZ 37091        ;
;       jne  _37091                     ;
;       sb   one,@c                     ; DEC C             ;
;       jne  _37079                     ; JR NZ,37079       ; }

       jmp  dec_air_loop                ; JR 37044          ; Jump back to decrease the air supply again

* Add to the score
* 
* The entry point to this routine is at #R37118.
incscore:                              ; 37098
       movb @bytes+48,*hl              ; LD (HL),48        ; Roll the digit over from '9' to '0'
       dec  hl                         ; DEC HL            ; Point #REGhl at the next digit to the left
;      movb @l,a                       ; LD A,L            ; {Is this the 10000s digit?
;      cb   a,@bytes+42                ; CP 42             ; }
       ci   hl,scorbuf+1
       jne  incscore_1                 ; JR NZ,37118       ; Jump if not
* Willy has scored another 10000 points. Give him an extra life.
       movb @bytes+8,a                 ; LD A,8            ; {Set the screen flash counter at #R33880 to 8
       movb a,@flash                   ; LD (33880),A      ; }
       movb @lives,a                   ; LD A,(33879)      ; {Increment the number of lives remaining at #R33879
       ab   one,a                      ; INC A             ; 
       movb a,@lives                   ; LD (33879),A      ; }
* The entry point to this routine is here and is used by the routines at
* #R36707, #R36904 and #R37173 with #REGhl pointing at the digit of the score
* (see #R33833) to be incremented.
incscore_1:
       movb *hl,a                      ; LD A,(HL)         ; Pick up a digit of the score
       cb   a,@bytes+57                ; CP 57             ; Is it '9'?
       jeq  incscore                   ; JR Z,37098        ; Jump if so
       ab   one,*hl                    ; INC (HL)          ; Increment the digit
       .ret                            ; RET               ; 

* Move the conveyor in the current cavern
* 
* Used by the routine at #R34574.
move_conveyor:                            ; 37125
       movb @convloc+1,h               ; LD HL,(32880)     ; Pick up the address of the conveyor's location in the
       movb @convloc,@l                ; screen buffer at #R28672 scrn_buffer_1 from #R32880
;      movb @l,@e                      ; LD E,L            ; {Copy this address to #REGde
;      movb h,d                        ; LD D,H            ; }
       mov  hl,de
       movb @convlen,b                 ; LD A,(32882)      ; Pick up the length of the conveyor from #R32882
;      movb a,b                        ; LD B,A            ; #REGb will count the conveyor tiles
       movb @convdir,a                 ; LD A,(32879)      ; Pick up the direction of the conveyor from #R32879
;      socb a,a                        ; OR A              ; Is the conveyor moving right?
       jne  _37159                     ; JR NZ,37159       ; Jump if so
* The conveyor is moving left.
       movb *hl,r0                     ; LD A,(HL)         ; Copy the first pixel row of the conveyor tile to #REGa
       movb r0,@r0lb                   ; RLC A             ; {Rotate it left twice
       src  r0,14                       ; RLC A            ; }
       movb r0,a
;      ab   one,h                      ; INC H             ; {Point #REGhl at the third pixel row of the conveyor
       ab   @bytes+2,h                 ; INC H             ; tile}
       movb *hl,r0                     ; LD C,(HL)         ; Copy this pixel row to #REGc
       movb r0,@r0lb
       src  r0,2                       ; RRC C             ; {Rotate it right twice
       movb r0,@c
       ; RRC C                         ; RRC C             ; }
_37152:
       movb a,*de+                     ; LD (DE),A         ; {Update the first and third pixel rows of every conveyor
       movb @c,*hl+                    ; LD (HL),C         ; tile in the screen buffer at #R28672 scrn_buffer_1
;      ab   one,@l                     ; INC L             ;
;      ab   one,@e                     ; INC E             ;
       sb   one,b                      ; DJNZ 37152        ; }
       jne  _37152                     ;                   
       .ret                            ; RET               ;
* The conveyor is moving right.
_37159:
       movb *hl,r0                     ; LD A,(HL)         ; Copy the first pixel row of the conveyor tile to #REGa
       movb r0,@r0lb                   ; RRC A             ; {Rotate it right twice
       src  r0,2                       ; RRC A             ; }
       mov  r0,a
;      ab   one,h                      ; INC H             ; {Point #REGhl at the third pixel row of the conveyor
       ab   @bytes+2,h                 ; INC H             ; tile}
       movb *hl,r0                     ; LD C,(HL)         ; Copy this pixel row to #REGc
       movb r0,@r0lb                   ; RLC C             ; {Rotate it left twice
       src  r0,14                      ; RLC C             ; }
       movb r0,@c
       jmp  _37152                     ; JR 37152          ; Jump back to update the first and third pixel rows of
                                                           ; every conveyor tile

* Move and draw the Kong Beast in the current cavern
* 
* Used by the routine at #R34574.
kong_beast:                             ; 37173
       li   hl,attr_buffer_2+6         ; LD HL,23558       ; {Flip the left-hand switch at (0,6) if Willy is touching
       .call @chkswitch                ; CALL 37403        ; it}
       movb @eugdir,a                  ; LD A,(32987)      ; Pick up the Kong Beast's status from #R32987
       cb   a,@bytes+2                 ; CP 2              ; Is the Kong Beast already dead?
       jne  !                          ; RET Z             ; Return if so
       .ret                            ;                   
!
       movb @scrn_buffer_1+1286,a      ; LD A,(29958)      ; Pick up the sixth pixel row of the left-hand switch from
                                                           ; the screen buffer at #R28672 scrn_buffer_1
       cb   a,@bytes+16                ; CP 16             ; Has the switch been flipped?
       jne  !                          ; JP Z,37369        ; Jump if not
       b    @_37369                    ;                   
!
* The left-hand switch has been flipped. Deal with opening up the wall if that
* is still in progress.
       movb @attr_buffer_1+369,a       ; LD A,(24433)      ; Pick up the attribute byte of the tile at (11,17) in the
                                                           ; buffer at #R24064 attr_buffer_1
;      socb a,a                        ; OR A              ; Has the wall there been removed yet?
       jeq  _37238                     ; JR Z,37238        ; Jump if so
       li   hl,scrn_buffer_1+3953      ; LD HL,32625       ; Point #REGhl at the bottom row of pixels of the wall
                                                           ; tile at (11,17) in the screen buffer at #R28672 scrn_buffer_1
       mov  hl,r1
       andi r1,>f8ff
       bl   @add_tile_update
       ai   r1,32
       bl   @add_tile_update

_37202:
       movb *hl,a                      ; LD A,(HL)         ; Pick up a pixel row
;      socb a,a                        ; OR A              ; Is it blank yet?
       jne  _37228                     ; JR NZ,37228       ; Jump if not
       sb   one,h                      ; DEC H             ; Point #REGhl at the next pixel row up
       movb h,a                        ; LD A,H            ; {Have we checked all 8 pixel rows yet?
       cb   a,@bytes+scrn_buffer_1_msb+7                   ; CP 119            ; }
       jne  _37202                     ; JR NZ,37202       ; If not, jump back to check the next one
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       movb a,@attr_buffer_1+369       ; LD (24433),A      ; {Change the attributes at (11,17) and (12,17) in the
       movb a,@attr_buffer_1+401       ; LD (24465),A      ; buffer at #R24064 attr_buffer_1 to match the background tile (the wall
                                                           ; there is now gone)}
       movb @bytes+114,a               ; LD A,114          ; {Update the seventh byte of the guardian definition at
       movb a,@hguard2+6               ; LD (32971),A      ; #R32965 so that the guardian moves through the opening
                                                           ; in the wall}
       jmp  _37238                     ; JR 37238          ; 
_37228:
       sb   *hl,*hl                    ; LD (HL),0         ; Clear a pixel row of the wall tile at (11,17) in the
                                                           ; screen buffer at #R28672 scrn_buffer_1
       movb @bytes+145,@l              ; LD L,145          ; {Point #REGhl at the opposite pixel row of the wall tile
       movb h,a                        ; LD A,H            ; one cell down at (12,17)
       li   r0,7*256                   ; XOR 7             ; 
       xor  r0,a                       ;                   
       movb a,h                        ; LD H,A            ; }
       sb   *hl,*hl                    ; LD (HL),0         ; Clear that pixel row as well
* Now check the right-hand switch.
_37238:
       li   hl,attr_buffer_2+18        ; LD HL,23570       ; {Flip the right-hand switch at (0,18) if Willy is
       .call @chkswitch                ; CALL 37403        ; touching it (and it hasn't already been flipped)}
       jne  _37277                     ; JR NZ,37277       ; Jump if the switch was not flipped
       sb   a,a                        ; XOR A             ; {Initialise the Kong Beast's pixel y-coordinate at
       movb a,@eughgt                  ; LD (32988),A      ; #R32988 to 0}
       ab   one,a                      ; INC A             ; {Update the Kong Beast's status at #R32987 to 1: he is
       movb a,@eugdir                  ; LD (32987),A      ; falling}
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       movb a,@attr_buffer_1+79        ; LD (24143),A      ; {Change the attributes of the floor beneath the Kong
       movb a,@attr_buffer_1+80        ; LD (24144),A      ; Beast in the buffer at #R24064 attr_buffer_1 to match that of the
                                                           ; background tile}
       li   hl,scrn_buffer_1+79        ; LD HL,28751       ; Point #REGhl at (2,15) in the screen buffer at #R28672 scrn_buffer_1

       mov  hl,r1
       bl   @add_tile_update
       inc  r1
       bl   @add_tile_update

       movb @bytes+8,b                 ; LD B,8            ; {Clear the cells at (2,15) and (2,16), removing the
_37268:
       sb   *hl,*hl                    ; LD (HL),0         ; floor beneath the Kong Beast
       ab   one,@l                     ; INC L             ; 
       sb   *hl,*hl                    ; LD (HL),0         ; 
       sb   one,@l                     ; DEC L             ; 
       ab   one,h                      ; INC H             ; 
       sb   one,b                      ; DJNZ 37268        ; }
       jne  _37268                     ;                   
_37277:
       movb @eugdir,a                  ; LD A,(32987)      ; Pick up the Kong Beast's status from #R32987
;      socb a,a                        ; OR A              ; Is the Kong Beast still on the ledge?
       jeq  _37369                     ; JR Z,37369        ; Jump if so
* The Kong Beast is falling.
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the Kong Beast's pixel y-coordinate from #R32988
       cb   a,@bytes+100               ; CP 100            ; Has he fallen into the portal yet?
       jeq  _37363                     ; JR Z,37363        ; Jump if so
       ab   @bytes+4,a                 ; ADD A,4           ; {Add 4 to the Kong Beast's pixel y-coordinate at #R32988
       movb a,@eughgt                  ; LD (32988),A      ; (moving him downwards)}

       movb a,r1                       ; LD C,A            ; Copy the pixel y-coordinate to #REGc; this value
       bl   @play_note_ch_2                                ; determines the pitch of the sound effect

;      movb @bytes+16,d                ; LD D,16           ; This value determines the duration of the sound effect
;      movb @border,a                  ; LD A,(32883)      ; Pick up the border colour for the current cavern from
;                                                          ; #R32883
;_37301:
;      ; OUT (254),A                   ; OUT (254),A       ; {Make a falling sound effect
;      li   r0,24*256                  ; XOR 24            ;
;      xor  r0,a                       ;
;      movb @c,b                       ; LD B,C            ;
;_37306:
;      sb   one,b                      ; DJNZ 37306        ;
;      jne  _37306                     ;
;      sb   one,d                      ; DEC D             ;
;      jne  _37301                     ; JR NZ,37301       ; }
;

*      RM: Swapping order of attributes and sprites
*      to make the attributes available to the hardware sprite drawing routine
*      Attributes
       movb @eughgt,a                  ; LD A,(32988)      ; Pick up the Kong Beast's pixel y-coordinate from #R32988
       andi a,120*256                  ; AND 120 >78       ; {Point #REGhl at the address of the Kong Beast's
       movb a,@l                       ; LD L,A            ; location in the attribute buffer at #R23552 attr_buffer_2
       movb @bytes+attr2_msb_div_4,h   ; LD H,23
       a    hl,hl                      ; ADD HL,HL         ; x2
       a    hl,hl                      ; ADD HL,HL         ; x4
       movb @l,a                       ; LD A,L            ;
       socb @bytes+15,a                ; OR 15             ;
       movb a,@l                       ; LD L,A            ; }
       movb @bytes+6,a                 ; LD A,6            ; The Kong Beast is drawn with yellow INK
       .call @draw_sprite_attributes   ; JP 36447          ; Set the attribute bytes for the Kong Beast
*      Sprite
       movb @eughgt,a                  ; LD A,C            ; Copy the Kong Beast's pixel y-coordinate back into #REGa
       sla  a,1                        ; RLCA              ; {Point #REGde at the entry in the screen buffer address
       movb a,@e                       ; LD E,A            ; lookup table at #R33536 that corresponds to the Kong
       movb @sbufaddrs_msb_byte,d      ; LD D,131          ; Beast's pixel y-coordinate}
       movb *de,a                      ; LD A,(DE)         ; {Point #REGhl at the address of the Kong Beast's
       socb @bytes+15,a                ; OR 15             ; location in the screen buffer at #R24576 scrn_buffer_2
       movb a,@l                       ; LD L,A            ; 
       inc  de                         ; INC DE            ; 
       movb *de,a                      ; LD A,(DE)         ; 
       movb a,h                        ; LD H,A            ; }
       movb @bytes+ggdata_msb,d        ; LD D,129          ; {Use bit 5 of the value of the game clock at #R32957
       movb @clock,a                   ; LD A,(32957)      ; (which is toggled once every eight passes through the
       andi a,32*256                   ; AND 32            ; main loop) to point #REGde at the graphic data for the
       socb @bytes+64,a                ; OR 64             ; appropriate Kong Beast sprite
       movb a,@e                       ; LD E,A            ; }
       sb   @c,@c                      ; LD C,0            ; {Draw the Kong Beast to the screen buffer at #R24576 scrn_buffer_2
       .call @draw_sprite              ; CALL 36852        ; }

       li   hl,scorbuf+3               ; LD HL,33836       ; {Add 100 to the score
       .call @incscore_1               ; CALL 37118        ; }
       .ret
* The Kong Beast has fallen into the portal.
_37363:
       movb @bytes+2,a                 ; LD A,2            ; {Set the Kong Beast's status at #R32987 to 2: he is dead
       movb a,@eugdir                  ; LD (32987),A      ; }
       .ret                            ; RET               ; 
* The Kong Beast is still on the ledge.
_37369:
*      RM: Swapping order of attributes and sprites
*      to make the attributes available to the hardware sprite drawing routine
*      Attributes
       movb @bytes+68,a                ; LD A,68           ; #REGa=#b68 (INK 4: PAPER 0: BRIGHT 1)
       movb a,@attr_buffer_2+47        ; LD (23599),A      ; {Set the attribute bytes for the Kong Beast in the
       movb a,@attr_buffer_2+48        ; LD (23600),A      ; buffer at #R23552 attr_buffer_2
       movb a,@attr_buffer_2+15        ; LD (23567),A      ;
       movb a,@attr_buffer_2+16        ; LD (23568),A      ; }
*      Sprite
       movb @clock,a                   ; LD A,(32957)      ; Pick up the value of the game clock at #R32957
       andi a,32*256                   ; AND 32            ; {Use bit 5 of this value (which is toggled once every
       movb a,@e                       ; LD E,A            ; eight passes through the main loop) to point #REGde at
       movb @bytes+ggdata_msb,d        ; LD D,129          ; the graphic data for the appropriate Kong Beast sprite}
       li   hl,scrn_buffer_2+15        ; LD HL,24591       ; {Draw the Kong Beast at (0,15) in the screen buffer at
       movb one,@c                     ; LD C,1            ; #R24576 scrn_buffer_2
       .call @draw_sprite              ; CALL 36852        ; }
       jeq  !                          ; JP NZ,36102       ; Kill Willy if he collided with the Kong Beast
       .ifeq can_die,1
       b    @kill_willy_2              ;
       .else
       nop
       .endif
!
       .ret                            ; RET               ;

* Flip a switch in a Kong Beast cavern if Willy is touching it
* 
* Used by the routine at #R37173. Returns with the zero flag set if Willy flips
* the switch.
* 
* HL Address of the switch's location in the attribute buffer at #R23552 attr_buffer_2
chkswitch:                             ; 37403
       movb @location,a                ; LD A,(32876)      ; Pick up the LSB of the address of Willy's location in
                                                           ; the attribute buffer at #R23552 attr_buffer_2 from #R32876
       ab   one,a                      ; INC A             ; {Is it equal to or one less than the LSB of the address
       andi a,254*256                  ; AND 254           ; of the switch's location?
       cb   a,@l                       ; CP L              ; }
       jeq  !                          ; RET NZ            ; Return (with the zero flag reset) if not
       .ret                            ;                   
!
       movb @location+1,a              ; LD A,(32877)      ; Pick up the MSB of the address of Willy's location in
                                                           ; the attribute buffer at #R23552 attr_buffer_2 from #R32876(#N32877)
       cb   a,h                        ; CP H              ; Does it match the MSB of the address of the switch's
                                                           ; location?
       jeq  !                          ; RET NZ            ; Return (with the zero flag reset) if not
       .ret                            ;                   
!
       movb @extra+6,a                 ; LD A,(32869)      ; Pick up the sixth byte of the graphic data for the
                                                           ; switch tile from #R32863(#N32869)
       movb @bytes+scrn_buffer_1_msb+5,h ; LD H,117        ; Point #REGhl at the sixth row of pixels of the switch
                                                           ; tile in the screen buffer at #R28672 scrn_buffer_1
       cb   a,*hl                      ; CP (HL)           ; Has the switch already been flipped?
       jeq  !                          ; RET NZ            ; Return (with the zero flag reset) if so
       .ret                            ;
!
* Willy is flipping the switch.
       movb @bytes+8,*hl               ; LD (HL),8         ; {Update the sixth, seventh and eighth rows of pixels of
       ab   one,h                      ; INC H             ; the switch tile in the screen buffer at #R28672 scrn_buffer_1 to make
       movb @bytes+6,*hl               ; LD (HL),6         ; it appear flipped
       ab   one,h                      ; INC H             ; 
       movb @bytes+6,*hl               ; LD (HL),6         ; }
       sb   a,a                        ; XOR A             ; Set the zero flag: Willy has flipped the switch
       mov  hl,r1
       andi r1,>f8ff
       bl   @add_tile_update
;      socb a,a                        ; OR A              ; This instruction is redundant
       .ret_eq                         ; RET               ;

* Check and set the attribute bytes for Willy's sprite in the buffer at #N23552
* 
* Used by the routine at #R34574.
willy_attrs:                           ; 37434
       movb  @location+1,h             ; LD HL,(32876)     ; Pick up the address of Willy's location in the attribute
       movb  @location,@l                                  ; buffer at #R23552 attr_buffer_2 from #R32876
       li   de,31                      ; LD DE,31          ; Prepare #REGde for addition
       movb @bytes+15,@c               ; LD C,15           ; Set #REGc=#b15 for the top two rows of cells (to make
                                                           ; the routine at #R37471 force white INK)
       .call @willy_attr               ; CALL 37471        ; Check and set the attribute byte for the top-left cell
       inc  hl                         ; INC HL            ; Move #REGhl to the next cell to the right
       .call @willy_attr               ; CALL 37471        ; Check and set the attribute byte for the top-right cell
       a    de,hl                      ; ADD HL,DE         ; Move #REGhl down a row and back one cell to the left
       .call @willy_attr               ; CALL 37471        ; Check and set the attribute byte for the mid-left cell
       inc  hl                         ; INC HL            ; Move #REGhl to the next cell to the right
       .call @willy_attr               ; CALL 37471        ; Check and set the attribute byte for the mid-right cell
       movb @willy_y,a                 ; LD A,(32872)      ; Pick up Willy's y-coordinate from #R32872
       movb a,@c                       ; LD C,A            ; Copy it to #REGc
       a    de,hl                      ; ADD HL,DE         ; Move #REGhl down a row and back one cell to the left
       .call @willy_attr               ; CALL 37471        ; Check and set the attribute byte for the bottom-left
                                                           ; cell
       inc  hl                         ; INC HL            ; Move #REGhl to the next cell to the right
       .call @willy_attr               ; CALL 37471        ; Check and set the attribute byte for the bottom-right
                                                           ; cell
       jmp  draw_willy                 ; JR 37503          ; Draw Willy to the screen buffer at #R24576 scrn_buffer_2

* Check and set the attribute byte for a cell occupied by Willy's sprite
* 
* Used by the routine at #R37434.
* 
* C #b15 or Willy's y-coordinate
* HL Address of the cell in the attribute buffer at #R23552 attr_buffer_2
willy_attr:                            ; 37471
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       cb   a,*hl                      ; CP (HL)           ; Does this cell contain a background tile?
       jne  _37488                     ; JR NZ,37488       ; Jump if not
       movb @c,a                       ; LD A,C            ; {Set the zero flag if we are going to retain the INK
       andi a,15*256                   ; AND 15            ; colour in this cell; this happens only if the cell is in
                                                           ; the bottom row and Willy's sprite is confined to the top
                                                           ; two rows}
       jeq  _37488                     ; JR Z,37488        ; Jump if we are going to retain the current INK colour in
                                                           ; this cell
       movb @background,a              ; LD A,(32800)      ; Pick up the attribute byte of the background tile for
                                                           ; the current cavern from #R32800
       socb @bytes+7,a                 ; OR 7              ; Set bits 0-2, making the INK white
       movb a,*hl                      ; LD (HL),A         ; Set the attribute byte for this cell in the buffer at
                                                           ; #R23552 attr_buffer_2
_37488:
       movb @nasty1,a                  ; LD A,(32845)      ; Pick up the attribute byte of the first nasty tile for
                                                           ; the current cavern from #R32845
       cb   a,*hl                      ; CP (HL)           ; Has Willy hit a nasty of the first kind?
       jne  !                          ; JP Z,36101        ; Kill Willy if so
       .ifeq can_die,1
       b    @kill_willy_1              ;
       .else
       nop
       .endif
!
       movb @nasty2,a                  ; LD A,(32854)      ; Pick up the attribute byte of the second nasty tile for
                                                           ; the current cavern from #R32854
       cb   a,*hl                      ; CP (HL)           ; Has Willy hit a nasty of the second kind?
       jne  !                          ; JP Z,36101        ; Kill Willy if so
       .ifeq can_die,1
       b    @kill_willy_1              ;
       .else
       nop
       .endif
!
       .ret                            ; RET               ; 

* Draw Willy to the screen buffer at #N24576
* 
* Used by the routine at #R37434.
draw_willy:                            ; 37503
       movb @willy_y,a                 ; LD A,(32872)      ; Pick up Willy's y-coordinate from #R32872
       movb @sbufaddrs_msb_byte,ix     ; LD IXH,131        ; {Point #REGix at the entry in the screen buffer address
       movb a,@ixl                     ; LD IXL,A          ; lookup table at #R33536 that corresponds to Willy's
                                                           ; y-coordinate}
       movb @dmflags,a                 ; LD A,(32874)      ; Pick up Willy's direction and movement flags from
                                                           ; #R32874
       andi a,1*256                    ; AND 1             ; {Now #REGe=#b0 if Willy is facing right, or #b128 if
       sla  a,7                        ; RRCA              ; he's facing left
       movb a,@e                       ; LD E,A            ; }
       movb @frame,a                   ; LD A,(32873)      ; Pick up Willy's animation frame (0-3) from #R32873
       andi a,3*256                    ; AND 3             ; {Point #REGde at the sprite graphic data for Willy's
;      srl  a,1                        ; RRCA              ; current animation frame (see #R33280)
;      srl  a,1                        ; RRCA              ;
       sla  a,5                        ; RRCA              ;
       socb @e,a                       ; OR E              ; 
       movb a,@e                       ; LD E,A            ; 
       movb @bytes+mandat_msb,d        ; LD D,130          ; }
       movb @bytes+16,b                ; LD B,16           ; There are 16 rows of pixels to copy
       movb @location,a                ; LD A,(32876)      ; {Pick up Willy's screen x-coordinate (0-31) from #R32876
       andi a,31*256                   ; AND 31            ; }
       movb a,@c                       ; LD C,A            ; Copy it to #REGc

       movb *ix+,h
       socb a,h
       swpb hl
       movb *ix,h
       dec  ix
       bl   @ti_draw_sprite
       .ret
_37538:
       movb *ix+,@l                    ; LD A,(IX+0)       ; {Set #REGhl to the address in the screen buffer at
       movb *ix+,h                     ; LD H,(IX+1)       ; #R24576 scrn_buffer_2 that corresponds to where we are going to draw
       socb @c,@l                      ; OR C              ; the next pixel row of the sprite graphic
;      movb a,@l                       ; LD L,A            ; }
;      movb *de+,a                     ; LD A,(DE)         ; Pick up a sprite graphic byte
       socb *de+,*hl+                  ; OR (HL)           ; Merge it with the background
;      movb a,*hl+                     ; LD (HL),A         ; Save the resultant byte to the screen buffer
;      inc  hl                         ; INC HL            ; Move #REGhl along to the next cell to the right
;      inc  de                         ; INC DE            ; Point #REGde at the next sprite graphic byte
;      movb *de+,a                     ; LD A,(DE)         ; Pick it up in #REGa
       socb *de+,*hl                   ; OR (HL)           ; Merge it with the background
;      movb a,*hl                      ; LD (HL),A         ; Save the resultant byte to the screen buffer
;      inc  ix                         ; INC IX            ; {Point #REGix at the next entry in the screen buffer
;      inc  ix                         ; INC IX            ; address lookup table at #R33536}
;      inc  de                         ; INC DE            ; Point #REGde at the next sprite graphic byte
       sb   one,b                      ; DJNZ 37538        ; Jump back until all 16 rows of pixels have been drawn
       jne  _37538                     ;                   
       .ret                            ; RET               ; 

* Print a message
* 
* Used by the routines at #R34252, #R34436, #R34574, #R35140 and #R36904.
* 
* IX Address of the message
* C Length of the message
* DE Display file address
pmess:                                 ; 37562
       movb *ix,a                      ; LD A,(IX+0)       ; Collect a character from the message
       .call @print_char                ; CALL 37579        ; Print it
       inc  ix                         ; INC IX            ; Point #REGix at the next character in the message
       ab   one,@e                     ; INC E             ; {Point #REGde at the next character cell (subtracting 8
       movb d,a                        ; LD A,D            ; from #REGd compensates for the operations performed by
       sb   @bytes+8,a                 ; SUB 8             ; the routine at #R37579)
       movb a,d                        ; LD D,A            ; }
       sb   one,@c                     ; DEC C             ; Have we printed the entire message yet?
       jne  pmess                      ; JR NZ,37562       ; If not, jump back to print the next character
       .ret                            ; RET               ; 

* Print a single character
* 
* Used by the routine at #R37562.
* 
* A ASCII code of the character
* DE Display file address
print_char:                             ; 37579
;      movb @bytes+7,h                 ; LD H,7            ; {Point #REGhl at the bitmap for the character (in the
;      movb a,@l                       ; LD L,A            ; ROM)
;      socb @bits+7,@l                 ; SET 7,L           ;
;      a    hl,hl                      ; ADD HL,HL         ;
;      a    hl,hl                      ; ADD HL,HL         ;
;      a    hl,hl                      ; ADD HL,HL         ; }
       sb   @bytes+32,a
       clr  hl
       movb a,h
       srl  hl,5
       ai   hl,font
       movb @bytes+8,b                 ; LD B,8            ; There are eight pixel rows in a character bitmap
* This entry point is used by the routine at #R36707 to draw an item in the
* current cavern.
print_char_1:
;      movb *hl,a                      ; LD A,(HL)         ; {Copy the character bitmap to the screen (or item
;      movb a,*de                      ; LD (DE),A         ; graphic to the screen buffer)
;      inc  hl                         ; INC HL            ;
       movb *hl+,*de
       ab   one,d                      ; INC D             ;
       sb   one,b                      ; DJNZ 37589        ; }
       jne  print_char_1               ;
       .ret                            ; RET               ; 

* Play the theme tune (The Blue Danube)
* 
* Used by the routine at #R34252. Returns with the zero flag reset if ENTER or
* the fire button is pressed while the tune is being played.
* 
* IY #R33902 (tune data)
playtune:                              ; 37596
       movb *iy,a                      ; LD A,(IY+0)       ; Pick up the next byte of tune data from the table at
                                                           ; #R33902
       cb   a,@b255                    ; CP 255            ; Has the tune finished?
       jne  !                          ; RET Z             ; Return (with the zero flag set) if so
       bl   @mute_sound
       .ret_eq                         ;
!
       li   r0,JOY_FI
       bl   @ti_check_key
       jne  !
       li   r0,KEY_EN
       bl   @ti_check_key
       jeq  !!
!      bl   @mute_sound
      .ret
!
       movb a,@c                       ; LD C,A            ; Copy the first byte of data for this note (which
                                                           ; determines the duration) to #REGc
       sb   b,b                        ; LD B,0            ; Initialise #REGb, which will be used as a delay counter
                                                           ; in the note-producing loop
;      sb   a,a                        ; XOR A             ; Set #REGa=0 (for no apparent reasaon)
       movb @1(iy),d                   ; LD D,(IY+1)       ; Pick up the second byte of data for this note
       movb d,a                        ; LD A,D            ; Copy it to #REGa
       .call @pianokey                 ; CALL 37675        ; Calculate the attribute file address for the
                                                           ; corresponding piano key
       movb @bytes+80,*hl              ; LD (HL),80        ; Set the attribute byte for the piano key to #b80 (INK 0:
                                                           ; PAPER 2: BRIGHT 1)
       movb @2(iy),@e                  ; LD E,(IY+2)       ; Pick up the third byte of data for this note
       movb @e,a                       ; LD A,E            ; Copy it to #REGa
       .call @pianokey                 ; CALL 37675        ; Calculate the attribute file address for the
                                                           ; corresponding piano key
       movb @bytes+40,*hl              ; LD (HL),40        ; Set the attribute byte for the piano key to #b40 (INK 0:
                                                           ; PAPER 5: BRIGHT 0)
       bl   @upload_middle_part

       movb d,r1
       bl   @play_note_ch_1
       movb @e,r1
       bl   @play_note_ch_2

       sb   @bytes+25,@c
       jeq  !
_37624:
;      OUT (254),A                   ; OUT (254),A         ; {Produce a sound based on the frequency parameters in
;      sb   one,d                      ; DEC D             ; the second and third bytes of data for this note (copied
;      jne  _37634                     ; JR NZ,37634       ; into #REGd and #REGe)
;      movb @1(iy),d                   ; LD D,(IY+1)       ;
;      li   r0,24*256                  ; XOR 24            ;
;      xor  r0,a                       ;
;_37634:
;      sb   one,@e                     ; DEC E             ;
;      jne  _37642                     ; JR NZ,37642       ;
;      movb @2(iy),@e                  ; LD E,(IY+2)       ;
;      li   r0,24*256                  ; XOR 24            ;
;      xor  r0,a                       ;
;_37642:
       sb   one,b                      ; DJNZ 37624        ;
       jne  _37624                     ;
       sb   one,@c                     ; DEC C             ;
       jne  _37624                     ; JR NZ,37624       ; }
!

;      .call @checkenter               ; CALL 37687        ; Check whether ENTER or the fire button is being pressed
;      jeq  !                          ; RET NZ            ; Return (with the zero flag reset) if it is
;      .ret                            ;
;!

       li   r0,JOY_FI
       bl   @ti_check_key
       jne  !
       li   r0,KEY_EN
       bl   @ti_check_key
       jeq  !!
!      bl   @mute_sound
      .ret
!
       movb @1(iy),a                   ; LD A,(IY+1)       ; Pick up the second byte of data for this note
       .call @pianokey                 ; CALL 37675        ; Calculate the attribute file address for the
                                                           ; corresponding piano key
       movb @bytes+56,*hl              ; LD (HL),56        ; Set the attribute byte for the piano key back to #b56
                                                           ; (INK 0: PAPER 7: BRIGHT 0)
       movb @2(iy),a                   ; LD A,(IY+2)       ; Pick up the third byte of data for this note
       .call @pianokey                 ; CALL 37675        ; Calculate the attribute file address for the
                                                           ; corresponding piano key
       movb @bytes+56,*hl              ; LD (HL),56        ; Set the attribute byte for the piano key back to #b56
                                                           ; (INK 0: PAPER 7: BRIGHT 0)
       bl   @upload_middle_part

       inc  iy                         ; INC IY            ; {Move #REGiy along to the data for the next note in the
       inc  iy                         ; INC IY            ; tune
       inc  iy                         ; INC IY            ; }
       b    @playtune                  ; JR 37596          ; Jump back to play the next note

* Calculate the attribute file address for a piano key
* 
* Used by the routine at #R37596. Returns with the attribute file address in
* #REGhl.
* 
* A Frequency parameter from the tune data table at #R33902
pianokey:                              ; 37675
       sb   @bytes+8,a                 ; SUB 8             ; {Compute the piano key index (K) based on the frequency
;      srl  a,1                        ; RRCA              ; parameter (F), and store it in bits 0-4 of #REGa:
;      srl  a,1                        ; RRCA              ; K=31-INT((F-8)/8)
       srl  a,3                        ; RRCA              ; .
       inv  a                          ; CPL               ; }
       socb @bytes+224,a               ; OR 224            ; #REGa=#b224+K; this is the LSB
       movb a,@l                       ; LD L,A            ; {Set #REGhl to the attribute file address for the piano
       movb @bytes+zx_attrs_msb+1,h    ; LD H,89           ; key}
       .ret                            ; RET               ;

* Check whether ENTER or the fire button is being pressed
* 
* Used by the routine at #R37596. Returns with the zero flag reset if ENTER or
* the fire button on the joystick is being pressed.
checkenter:                            ; 37687
       movb @kemp,a                    ; LD A,(33881)      ; Pick up the Kempston joystick indicator from #R33881
;      socb a,a                        ; OR A              ; Is the joystick connected?
       jeq  _37698                     ; JR Z,37698        ; Jump if not
       ; IN A,(31)                     ; IN A,(31)         ; Collect input from the joystick
       movb a,r0                       ; BIT 4,A           ; Is the fire button being pressed?
       andi r0,16*256                  ;                   
       jeq  !                          ; RET NZ            ; Return (with the zero flag reset) if so
       .ret                            ;                   
!
_37698:
       li   bc,cavern3+1022            ; LD BC,49150       ; {Read keys H-J-K-L-ENTER
       ; IN A,(C)                      ; IN A,(C)          ; }
       andi a,1*256                    ; AND 1             ; Keep only bit 0 of the result (ENTER)
       cb   a,one                      ; CP 1              ; Reset the zero flag if ENTER is being pressed
       .ret                            ; RET               ; 
